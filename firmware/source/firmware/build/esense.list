
build/esense.elf:     file format elf32-littlearm


Disassembly of section .text:

08002160 <Reset_Handler>:
 8002160:	b672      	cpsid	i
 8002162:	4826      	ldr	r0, [pc, #152]	; (80021fc <endfiniloop+0x6>)
 8002164:	f380 8809 	msr	PSP, r0
 8002168:	4825      	ldr	r0, [pc, #148]	; (8002200 <endfiniloop+0xa>)
 800216a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800216e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8002172:	6008      	str	r0, [r1, #0]
 8002174:	2002      	movs	r0, #2
 8002176:	f380 8814 	msr	CONTROL, r0
 800217a:	f3bf 8f6f 	isb	sy
 800217e:	f009 f801 	bl	800b184 <__core_init>
 8002182:	f009 f82f 	bl	800b1e4 <__early_init>
 8002186:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800218a:	491e      	ldr	r1, [pc, #120]	; (8002204 <endfiniloop+0xe>)
 800218c:	4a1e      	ldr	r2, [pc, #120]	; (8002208 <endfiniloop+0x12>)

0800218e <msloop>:
 800218e:	4291      	cmp	r1, r2
 8002190:	bf3c      	itt	cc
 8002192:	f841 0b04 	strcc.w	r0, [r1], #4
 8002196:	e7fa      	bcc.n	800218e <msloop>
 8002198:	491c      	ldr	r1, [pc, #112]	; (800220c <endfiniloop+0x16>)
 800219a:	4a18      	ldr	r2, [pc, #96]	; (80021fc <endfiniloop+0x6>)

0800219c <psloop>:
 800219c:	4291      	cmp	r1, r2
 800219e:	bf3c      	itt	cc
 80021a0:	f841 0b04 	strcc.w	r0, [r1], #4
 80021a4:	e7fa      	bcc.n	800219c <psloop>
 80021a6:	491a      	ldr	r1, [pc, #104]	; (8002210 <endfiniloop+0x1a>)
 80021a8:	4a1a      	ldr	r2, [pc, #104]	; (8002214 <endfiniloop+0x1e>)
 80021aa:	4b1b      	ldr	r3, [pc, #108]	; (8002218 <endfiniloop+0x22>)

080021ac <dloop>:
 80021ac:	429a      	cmp	r2, r3
 80021ae:	bf3e      	ittt	cc
 80021b0:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80021b4:	f842 0b04 	strcc.w	r0, [r2], #4
 80021b8:	e7f8      	bcc.n	80021ac <dloop>
 80021ba:	2000      	movs	r0, #0
 80021bc:	4917      	ldr	r1, [pc, #92]	; (800221c <endfiniloop+0x26>)
 80021be:	4a18      	ldr	r2, [pc, #96]	; (8002220 <endfiniloop+0x2a>)

080021c0 <bloop>:
 80021c0:	4291      	cmp	r1, r2
 80021c2:	bf3c      	itt	cc
 80021c4:	f841 0b04 	strcc.w	r0, [r1], #4
 80021c8:	e7fa      	bcc.n	80021c0 <bloop>
 80021ca:	f008 ffdf 	bl	800b18c <__init_ram_areas>
 80021ce:	f008 ffda 	bl	800b186 <__late_init>
 80021d2:	4c14      	ldr	r4, [pc, #80]	; (8002224 <endfiniloop+0x2e>)
 80021d4:	4d14      	ldr	r5, [pc, #80]	; (8002228 <endfiniloop+0x32>)

080021d6 <initloop>:
 80021d6:	42ac      	cmp	r4, r5
 80021d8:	da03      	bge.n	80021e2 <endinitloop>
 80021da:	f854 1b04 	ldr.w	r1, [r4], #4
 80021de:	4788      	blx	r1
 80021e0:	e7f9      	b.n	80021d6 <initloop>

080021e2 <endinitloop>:
 80021e2:	f009 f83f 	bl	800b264 <main>
 80021e6:	4c11      	ldr	r4, [pc, #68]	; (800222c <endfiniloop+0x36>)
 80021e8:	4d11      	ldr	r5, [pc, #68]	; (8002230 <endfiniloop+0x3a>)

080021ea <finiloop>:
 80021ea:	42ac      	cmp	r4, r5
 80021ec:	da03      	bge.n	80021f6 <endfiniloop>
 80021ee:	f854 1b04 	ldr.w	r1, [r4], #4
 80021f2:	4788      	blx	r1
 80021f4:	e7f9      	b.n	80021ea <finiloop>

080021f6 <endfiniloop>:
 80021f6:	f008 bfc7 	b.w	800b188 <__default_exit>
 80021fa:	0000      	.short	0x0000
 80021fc:	20000800 	.word	0x20000800
 8002200:	08002000 	.word	0x08002000
 8002204:	20000000 	.word	0x20000000
 8002208:	20000400 	.word	0x20000400
 800220c:	20000400 	.word	0x20000400
 8002210:	0800cd48 	.word	0x0800cd48
 8002214:	20000800 	.word	0x20000800
 8002218:	20000928 	.word	0x20000928
 800221c:	20000928 	.word	0x20000928
 8002220:	20001650 	.word	0x20001650
 8002224:	08002160 	.word	0x08002160
 8002228:	08002160 	.word	0x08002160
 800222c:	08002160 	.word	0x08002160
 8002230:	08002160 	.word	0x08002160

08002234 <_binary_data_license_bin_start>:
 8002234:	2a2a2a2a 	.word	0x2a2a2a2a
 8002238:	2a2a2a2a 	.word	0x2a2a2a2a
 800223c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002240:	2a2a2a2a 	.word	0x2a2a2a2a
 8002244:	2a2a2a2a 	.word	0x2a2a2a2a
 8002248:	2a2a2a2a 	.word	0x2a2a2a2a
 800224c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002250:	2a2a2a2a 	.word	0x2a2a2a2a
 8002254:	2a2a2a2a 	.word	0x2a2a2a2a
 8002258:	2a2a2a2a 	.word	0x2a2a2a2a
 800225c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002260:	2a2a2a2a 	.word	0x2a2a2a2a
 8002264:	2a2a2a2a 	.word	0x2a2a2a2a
 8002268:	2a2a2a2a 	.word	0x2a2a2a2a
 800226c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002270:	2a2a2a2a 	.word	0x2a2a2a2a
 8002274:	2a2a2a2a 	.word	0x2a2a2a2a
 8002278:	2a2a2a2a 	.word	0x2a2a2a2a
 800227c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002280:	2a2a2a2a 	.word	0x2a2a2a2a
 8002284:	0a0d2a2a 	.word	0x0a0d2a2a
 8002288:	65657246 	.word	0x65657246
 800228c:	534f5452 	.word	0x534f5452
 8002290:	72654b20 	.word	0x72654b20
 8002294:	206c656e 	.word	0x206c656e
 8002298:	2e303156 	.word	0x2e303156
 800229c:	0d302e30 	.word	0x0d302e30
 80022a0:	706f430a 	.word	0x706f430a
 80022a4:	67697279 	.word	0x67697279
 80022a8:	28207468 	.word	0x28207468
 80022ac:	32202943 	.word	0x32202943
 80022b0:	20373130 	.word	0x20373130
 80022b4:	7a616d41 	.word	0x7a616d41
 80022b8:	632e6e6f 	.word	0x632e6e6f
 80022bc:	202c6d6f 	.word	0x202c6d6f
 80022c0:	2e636e49 	.word	0x2e636e49
 80022c4:	20726f20 	.word	0x20726f20
 80022c8:	20737469 	.word	0x20737469
 80022cc:	69666661 	.word	0x69666661
 80022d0:	7461696c 	.word	0x7461696c
 80022d4:	202e7365 	.word	0x202e7365
 80022d8:	6c6c4120 	.word	0x6c6c4120
 80022dc:	67695220 	.word	0x67695220
 80022e0:	20737468 	.word	0x20737468
 80022e4:	65736552 	.word	0x65736552
 80022e8:	64657672 	.word	0x64657672
 80022ec:	0d0a0d2e 	.word	0x0d0a0d2e
 80022f0:	7265500a 	.word	0x7265500a
 80022f4:	7373696d 	.word	0x7373696d
 80022f8:	206e6f69 	.word	0x206e6f69
 80022fc:	68207369 	.word	0x68207369
 8002300:	62657265 	.word	0x62657265
 8002304:	72672079 	.word	0x72672079
 8002308:	65746e61 	.word	0x65746e61
 800230c:	66202c64 	.word	0x66202c64
 8002310:	20656572 	.word	0x20656572
 8002314:	6320666f 	.word	0x6320666f
 8002318:	67726168 	.word	0x67726168
 800231c:	74202c65 	.word	0x74202c65
 8002320:	6e61206f 	.word	0x6e61206f
 8002324:	65702079 	.word	0x65702079
 8002328:	6e6f7372 	.word	0x6e6f7372
 800232c:	74626f20 	.word	0x74626f20
 8002330:	696e6961 	.word	0x696e6961
 8002334:	6120676e 	.word	0x6120676e
 8002338:	706f6320 	.word	0x706f6320
 800233c:	666f2079 	.word	0x666f2079
 8002340:	68740a0d 	.word	0x68740a0d
 8002344:	73207369 	.word	0x73207369
 8002348:	7774666f 	.word	0x7774666f
 800234c:	20657261 	.word	0x20657261
 8002350:	20646e61 	.word	0x20646e61
 8002354:	6f737361 	.word	0x6f737361
 8002358:	74616963 	.word	0x74616963
 800235c:	64206465 	.word	0x64206465
 8002360:	6d75636f 	.word	0x6d75636f
 8002364:	61746e65 	.word	0x61746e65
 8002368:	6e6f6974 	.word	0x6e6f6974
 800236c:	6c696620 	.word	0x6c696620
 8002370:	28207365 	.word	0x28207365
 8002374:	20656874 	.word	0x20656874
 8002378:	666f5322 	.word	0x666f5322
 800237c:	72617774 	.word	0x72617774
 8002380:	2c292265 	.word	0x2c292265
 8002384:	206f7420 	.word	0x206f7420
 8002388:	6c616564 	.word	0x6c616564
 800238c:	0d6e6920 	.word	0x0d6e6920
 8002390:	6568740a 	.word	0x6568740a
 8002394:	666f5320 	.word	0x666f5320
 8002398:	72617774 	.word	0x72617774
 800239c:	69772065 	.word	0x69772065
 80023a0:	756f6874 	.word	0x756f6874
 80023a4:	65722074 	.word	0x65722074
 80023a8:	69727473 	.word	0x69727473
 80023ac:	6f697463 	.word	0x6f697463
 80023b0:	69202c6e 	.word	0x69202c6e
 80023b4:	756c636e 	.word	0x756c636e
 80023b8:	676e6964 	.word	0x676e6964
 80023bc:	74697720 	.word	0x74697720
 80023c0:	74756f68 	.word	0x74756f68
 80023c4:	6d696c20 	.word	0x6d696c20
 80023c8:	74617469 	.word	0x74617469
 80023cc:	206e6f69 	.word	0x206e6f69
 80023d0:	20656874 	.word	0x20656874
 80023d4:	68676972 	.word	0x68676972
 80023d8:	74207374 	.word	0x74207374
 80023dc:	750a0d6f 	.word	0x750a0d6f
 80023e0:	202c6573 	.word	0x202c6573
 80023e4:	79706f63 	.word	0x79706f63
 80023e8:	6f6d202c 	.word	0x6f6d202c
 80023ec:	79666964 	.word	0x79666964
 80023f0:	656d202c 	.word	0x656d202c
 80023f4:	2c656772 	.word	0x2c656772
 80023f8:	62757020 	.word	0x62757020
 80023fc:	6873696c 	.word	0x6873696c
 8002400:	6964202c 	.word	0x6964202c
 8002404:	69727473 	.word	0x69727473
 8002408:	65747562 	.word	0x65747562
 800240c:	7573202c 	.word	0x7573202c
 8002410:	63696c62 	.word	0x63696c62
 8002414:	65736e65 	.word	0x65736e65
 8002418:	6e61202c 	.word	0x6e61202c
 800241c:	726f2f64 	.word	0x726f2f64
 8002420:	6c657320 	.word	0x6c657320
 8002424:	6f63206c 	.word	0x6f63206c
 8002428:	73656970 	.word	0x73656970
 800242c:	0d666f20 	.word	0x0d666f20
 8002430:	6568740a 	.word	0x6568740a
 8002434:	666f5320 	.word	0x666f5320
 8002438:	72617774 	.word	0x72617774
 800243c:	61202c65 	.word	0x61202c65
 8002440:	7420646e 	.word	0x7420646e
 8002444:	6570206f 	.word	0x6570206f
 8002448:	74696d72 	.word	0x74696d72
 800244c:	72657020 	.word	0x72657020
 8002450:	736e6f73 	.word	0x736e6f73
 8002454:	206f7420 	.word	0x206f7420
 8002458:	6d6f6877 	.word	0x6d6f6877
 800245c:	65687420 	.word	0x65687420
 8002460:	666f5320 	.word	0x666f5320
 8002464:	72617774 	.word	0x72617774
 8002468:	73692065 	.word	0x73692065
 800246c:	72756620 	.word	0x72756620
 8002470:	6873696e 	.word	0x6873696e
 8002474:	74206465 	.word	0x74206465
 8002478:	6f64206f 	.word	0x6f64206f
 800247c:	2c6f7320 	.word	0x2c6f7320
 8002480:	75730a0d 	.word	0x75730a0d
 8002484:	63656a62 	.word	0x63656a62
 8002488:	6f742074 	.word	0x6f742074
 800248c:	65687420 	.word	0x65687420
 8002490:	6c6f6620 	.word	0x6c6f6620
 8002494:	69776f6c 	.word	0x69776f6c
 8002498:	6320676e 	.word	0x6320676e
 800249c:	69646e6f 	.word	0x69646e6f
 80024a0:	6e6f6974 	.word	0x6e6f6974
 80024a4:	0a0d3a73 	.word	0x0a0d3a73
 80024a8:	68540a0d 	.word	0x68540a0d
 80024ac:	62612065 	.word	0x62612065
 80024b0:	2065766f 	.word	0x2065766f
 80024b4:	79706f63 	.word	0x79706f63
 80024b8:	68676972 	.word	0x68676972
 80024bc:	6f6e2074 	.word	0x6f6e2074
 80024c0:	65636974 	.word	0x65636974
 80024c4:	646e6120 	.word	0x646e6120
 80024c8:	69687420 	.word	0x69687420
 80024cc:	65702073 	.word	0x65702073
 80024d0:	73696d72 	.word	0x73696d72
 80024d4:	6e6f6973 	.word	0x6e6f6973
 80024d8:	746f6e20 	.word	0x746f6e20
 80024dc:	20656369 	.word	0x20656369
 80024e0:	6c616873 	.word	0x6c616873
 80024e4:	6562206c 	.word	0x6562206c
 80024e8:	636e6920 	.word	0x636e6920
 80024ec:	6564756c 	.word	0x6564756c
 80024f0:	6e692064 	.word	0x6e692064
 80024f4:	6c6c6120 	.word	0x6c6c6120
 80024f8:	6f630a0d 	.word	0x6f630a0d
 80024fc:	73656970 	.word	0x73656970
 8002500:	20726f20 	.word	0x20726f20
 8002504:	73627573 	.word	0x73627573
 8002508:	746e6174 	.word	0x746e6174
 800250c:	206c6169 	.word	0x206c6169
 8002510:	74726f70 	.word	0x74726f70
 8002514:	736e6f69 	.word	0x736e6f69
 8002518:	20666f20 	.word	0x20666f20
 800251c:	20656874 	.word	0x20656874
 8002520:	74666f53 	.word	0x74666f53
 8002524:	65726177 	.word	0x65726177
 8002528:	6649202e 	.word	0x6649202e
 800252c:	756f7920 	.word	0x756f7920
 8002530:	73697720 	.word	0x73697720
 8002534:	6f742068 	.word	0x6f742068
 8002538:	65737520 	.word	0x65737520
 800253c:	72756f20 	.word	0x72756f20
 8002540:	616d4120 	.word	0x616d4120
 8002544:	0d6e6f7a 	.word	0x0d6e6f7a
 8002548:	6572460a 	.word	0x6572460a
 800254c:	4f545265 	.word	0x4f545265
 8002550:	616e2053 	.word	0x616e2053
 8002554:	202c656d 	.word	0x202c656d
 8002558:	61656c70 	.word	0x61656c70
 800255c:	64206573 	.word	0x64206573
 8002560:	6f73206f 	.word	0x6f73206f
 8002564:	206e6920 	.word	0x206e6920
 8002568:	61662061 	.word	0x61662061
 800256c:	75207269 	.word	0x75207269
 8002570:	77206573 	.word	0x77206573
 8002574:	74207961 	.word	0x74207961
 8002578:	20746168 	.word	0x20746168
 800257c:	73656f64 	.word	0x73656f64
 8002580:	746f6e20 	.word	0x746f6e20
 8002584:	75616320 	.word	0x75616320
 8002588:	63206573 	.word	0x63206573
 800258c:	75666e6f 	.word	0x75666e6f
 8002590:	6e6f6973 	.word	0x6e6f6973
 8002594:	0d0a0d2e 	.word	0x0d0a0d2e
 8002598:	4548540a 	.word	0x4548540a
 800259c:	464f5320 	.word	0x464f5320
 80025a0:	52415754 	.word	0x52415754
 80025a4:	53492045 	.word	0x53492045
 80025a8:	4f525020 	.word	0x4f525020
 80025ac:	45444956 	.word	0x45444956
 80025b0:	41222044 	.word	0x41222044
 80025b4:	53492053 	.word	0x53492053
 80025b8:	57202c22 	.word	0x57202c22
 80025bc:	4f485449 	.word	0x4f485449
 80025c0:	57205455 	.word	0x57205455
 80025c4:	41525241 	.word	0x41525241
 80025c8:	2059544e 	.word	0x2059544e
 80025cc:	4120464f 	.word	0x4120464f
 80025d0:	4b20594e 	.word	0x4b20594e
 80025d4:	2c444e49 	.word	0x2c444e49
 80025d8:	50584520 	.word	0x50584520
 80025dc:	53534552 	.word	0x53534552
 80025e0:	0d524f20 	.word	0x0d524f20
 80025e4:	504d490a 	.word	0x504d490a
 80025e8:	4445494c 	.word	0x4445494c
 80025ec:	4e49202c 	.word	0x4e49202c
 80025f0:	44554c43 	.word	0x44554c43
 80025f4:	20474e49 	.word	0x20474e49
 80025f8:	20545542 	.word	0x20545542
 80025fc:	20544f4e 	.word	0x20544f4e
 8002600:	494d494c 	.word	0x494d494c
 8002604:	20444554 	.word	0x20444554
 8002608:	54204f54 	.word	0x54204f54
 800260c:	57204548 	.word	0x57204548
 8002610:	41525241 	.word	0x41525241
 8002614:	4549544e 	.word	0x4549544e
 8002618:	464f2053 	.word	0x464f2053
 800261c:	52454d20 	.word	0x52454d20
 8002620:	4e414843 	.word	0x4e414843
 8002624:	49424154 	.word	0x49424154
 8002628:	5954494c 	.word	0x5954494c
 800262c:	4946202c 	.word	0x4946202c
 8002630:	53454e54 	.word	0x53454e54
 8002634:	460a0d53 	.word	0x460a0d53
 8002638:	4120524f 	.word	0x4120524f
 800263c:	52415020 	.word	0x52415020
 8002640:	55434954 	.word	0x55434954
 8002644:	2052414c 	.word	0x2052414c
 8002648:	50525550 	.word	0x50525550
 800264c:	2045534f 	.word	0x2045534f
 8002650:	20444e41 	.word	0x20444e41
 8002654:	494e4f4e 	.word	0x494e4f4e
 8002658:	4952464e 	.word	0x4952464e
 800265c:	4d45474e 	.word	0x4d45474e
 8002660:	2e544e45 	.word	0x2e544e45
 8002664:	204e4920 	.word	0x204e4920
 8002668:	45204f4e 	.word	0x45204f4e
 800266c:	544e4556 	.word	0x544e4556
 8002670:	41485320 	.word	0x41485320
 8002674:	54204c4c 	.word	0x54204c4c
 8002678:	41204548 	.word	0x41204548
 800267c:	4f485455 	.word	0x4f485455
 8002680:	4f205352 	.word	0x4f205352
 8002684:	430a0d52 	.word	0x430a0d52
 8002688:	5259504f 	.word	0x5259504f
 800268c:	54484749 	.word	0x54484749
 8002690:	4c4f4820 	.word	0x4c4f4820
 8002694:	53524544 	.word	0x53524544
 8002698:	20454220 	.word	0x20454220
 800269c:	4241494c 	.word	0x4241494c
 80026a0:	4620454c 	.word	0x4620454c
 80026a4:	4120524f 	.word	0x4120524f
 80026a8:	4320594e 	.word	0x4320594e
 80026ac:	4d49414c 	.word	0x4d49414c
 80026b0:	4144202c 	.word	0x4144202c
 80026b4:	4547414d 	.word	0x4547414d
 80026b8:	524f2053 	.word	0x524f2053
 80026bc:	48544f20 	.word	0x48544f20
 80026c0:	4c205245 	.word	0x4c205245
 80026c4:	49424149 	.word	0x49424149
 80026c8:	5954494c 	.word	0x5954494c
 80026cc:	4857202c 	.word	0x4857202c
 80026d0:	45485445 	.word	0x45485445
 80026d4:	490a0d52 	.word	0x490a0d52
 80026d8:	4e41204e 	.word	0x4e41204e
 80026dc:	54434120 	.word	0x54434120
 80026e0:	204e4f49 	.word	0x204e4f49
 80026e4:	4320464f 	.word	0x4320464f
 80026e8:	52544e4f 	.word	0x52544e4f
 80026ec:	2c544341 	.word	0x2c544341
 80026f0:	524f5420 	.word	0x524f5420
 80026f4:	524f2054 	.word	0x524f2054
 80026f8:	48544f20 	.word	0x48544f20
 80026fc:	49575245 	.word	0x49575245
 8002700:	202c4553 	.word	0x202c4553
 8002704:	53495241 	.word	0x53495241
 8002708:	20474e49 	.word	0x20474e49
 800270c:	4d4f5246 	.word	0x4d4f5246
 8002710:	554f202c 	.word	0x554f202c
 8002714:	464f2054 	.word	0x464f2054
 8002718:	20524f20 	.word	0x20524f20
 800271c:	0a0d4e49 	.word	0x0a0d4e49
 8002720:	4e4e4f43 	.word	0x4e4e4f43
 8002724:	49544345 	.word	0x49544345
 8002728:	57204e4f 	.word	0x57204e4f
 800272c:	20485449 	.word	0x20485449
 8002730:	20454854 	.word	0x20454854
 8002734:	54464f53 	.word	0x54464f53
 8002738:	45524157 	.word	0x45524157
 800273c:	20524f20 	.word	0x20524f20
 8002740:	20454854 	.word	0x20454854
 8002744:	20455355 	.word	0x20455355
 8002748:	4f20524f 	.word	0x4f20524f
 800274c:	52454854 	.word	0x52454854
 8002750:	41454420 	.word	0x41454420
 8002754:	474e494c 	.word	0x474e494c
 8002758:	4e492053 	.word	0x4e492053
 800275c:	45485420 	.word	0x45485420
 8002760:	464f5320 	.word	0x464f5320
 8002764:	52415754 	.word	0x52415754
 8002768:	0a0d2e45 	.word	0x0a0d2e45
 800276c:	74680a0d 	.word	0x74680a0d
 8002770:	2f3a7074 	.word	0x2f3a7074
 8002774:	7777772f 	.word	0x7777772f
 8002778:	6572462e 	.word	0x6572462e
 800277c:	4f545265 	.word	0x4f545265
 8002780:	726f2e53 	.word	0x726f2e53
 8002784:	680a0d67 	.word	0x680a0d67
 8002788:	3a707474 	.word	0x3a707474
 800278c:	77612f2f 	.word	0x77612f2f
 8002790:	6d612e73 	.word	0x6d612e73
 8002794:	6e6f7a61 	.word	0x6e6f7a61
 8002798:	6d6f632e 	.word	0x6d6f632e
 800279c:	6572662f 	.word	0x6572662f
 80027a0:	6f747265 	.word	0x6f747265
 80027a4:	2a0a0d73 	.word	0x2a0a0d73
 80027a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027cc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027dc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027ec:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f8:	430a0d2a 	.word	0x430a0d2a
 80027fc:	5259504f 	.word	0x5259504f
 8002800:	54484749 	.word	0x54484749
 8002804:	20296328 	.word	0x20296328
 8002808:	36313032 	.word	0x36313032
 800280c:	4d545320 	.word	0x4d545320
 8002810:	6f726369 	.word	0x6f726369
 8002814:	63656c65 	.word	0x63656c65
 8002818:	6e6f7274 	.word	0x6e6f7274
 800281c:	0d736369 	.word	0x0d736369
 8002820:	520a0d0a 	.word	0x520a0d0a
 8002824:	73696465 	.word	0x73696465
 8002828:	62697274 	.word	0x62697274
 800282c:	6f697475 	.word	0x6f697475
 8002830:	6e61206e 	.word	0x6e61206e
 8002834:	73752064 	.word	0x73752064
 8002838:	6e692065 	.word	0x6e692065
 800283c:	756f7320 	.word	0x756f7320
 8002840:	20656372 	.word	0x20656372
 8002844:	20646e61 	.word	0x20646e61
 8002848:	616e6962 	.word	0x616e6962
 800284c:	66207972 	.word	0x66207972
 8002850:	736d726f 	.word	0x736d726f
 8002854:	6977202c 	.word	0x6977202c
 8002858:	6f206874 	.word	0x6f206874
 800285c:	69772072 	.word	0x69772072
 8002860:	756f6874 	.word	0x756f6874
 8002864:	6f6d2074 	.word	0x6f6d2074
 8002868:	69666964 	.word	0x69666964
 800286c:	69746163 	.word	0x69746163
 8002870:	0d2c6e6f 	.word	0x0d2c6e6f
 8002874:	6572610a 	.word	0x6572610a
 8002878:	72657020 	.word	0x72657020
 800287c:	7474696d 	.word	0x7474696d
 8002880:	70206465 	.word	0x70206465
 8002884:	69766f72 	.word	0x69766f72
 8002888:	20646564 	.word	0x20646564
 800288c:	74616874 	.word	0x74616874
 8002890:	65687420 	.word	0x65687420
 8002894:	6c6f6620 	.word	0x6c6f6620
 8002898:	69776f6c 	.word	0x69776f6c
 800289c:	6320676e 	.word	0x6320676e
 80028a0:	69646e6f 	.word	0x69646e6f
 80028a4:	6e6f6974 	.word	0x6e6f6974
 80028a8:	72612073 	.word	0x72612073
 80028ac:	656d2065 	.word	0x656d2065
 80028b0:	0a0d3a74 	.word	0x0a0d3a74
 80028b4:	2e312020 	.word	0x2e312020
 80028b8:	64655220 	.word	0x64655220
 80028bc:	72747369 	.word	0x72747369
 80028c0:	74756269 	.word	0x74756269
 80028c4:	736e6f69 	.word	0x736e6f69
 80028c8:	20666f20 	.word	0x20666f20
 80028cc:	72756f73 	.word	0x72756f73
 80028d0:	63206563 	.word	0x63206563
 80028d4:	2065646f 	.word	0x2065646f
 80028d8:	7473756d 	.word	0x7473756d
 80028dc:	74657220 	.word	0x74657220
 80028e0:	206e6961 	.word	0x206e6961
 80028e4:	20656874 	.word	0x20656874
 80028e8:	766f6261 	.word	0x766f6261
 80028ec:	6f632065 	.word	0x6f632065
 80028f0:	69727970 	.word	0x69727970
 80028f4:	20746867 	.word	0x20746867
 80028f8:	69746f6e 	.word	0x69746f6e
 80028fc:	0d2c6563 	.word	0x0d2c6563
 8002900:	2020200a 	.word	0x2020200a
 8002904:	68742020 	.word	0x68742020
 8002908:	6c207369 	.word	0x6c207369
 800290c:	20747369 	.word	0x20747369
 8002910:	6320666f 	.word	0x6320666f
 8002914:	69646e6f 	.word	0x69646e6f
 8002918:	6e6f6974 	.word	0x6e6f6974
 800291c:	6e612073 	.word	0x6e612073
 8002920:	68742064 	.word	0x68742064
 8002924:	6f662065 	.word	0x6f662065
 8002928:	776f6c6c 	.word	0x776f6c6c
 800292c:	20676e69 	.word	0x20676e69
 8002930:	63736964 	.word	0x63736964
 8002934:	6d69616c 	.word	0x6d69616c
 8002938:	0d2e7265 	.word	0x0d2e7265
 800293c:	3220200a 	.word	0x3220200a
 8002940:	6552202e 	.word	0x6552202e
 8002944:	74736964 	.word	0x74736964
 8002948:	75626972 	.word	0x75626972
 800294c:	6e6f6974 	.word	0x6e6f6974
 8002950:	6e692073 	.word	0x6e692073
 8002954:	6e696220 	.word	0x6e696220
 8002958:	20797261 	.word	0x20797261
 800295c:	6d726f66 	.word	0x6d726f66
 8002960:	73756d20 	.word	0x73756d20
 8002964:	65722074 	.word	0x65722074
 8002968:	646f7270 	.word	0x646f7270
 800296c:	20656375 	.word	0x20656375
 8002970:	20656874 	.word	0x20656874
 8002974:	766f6261 	.word	0x766f6261
 8002978:	6f632065 	.word	0x6f632065
 800297c:	69727970 	.word	0x69727970
 8002980:	20746867 	.word	0x20746867
 8002984:	69746f6e 	.word	0x69746f6e
 8002988:	0d2c6563 	.word	0x0d2c6563
 800298c:	2020200a 	.word	0x2020200a
 8002990:	68742020 	.word	0x68742020
 8002994:	6c207369 	.word	0x6c207369
 8002998:	20747369 	.word	0x20747369
 800299c:	6320666f 	.word	0x6320666f
 80029a0:	69646e6f 	.word	0x69646e6f
 80029a4:	6e6f6974 	.word	0x6e6f6974
 80029a8:	6e612073 	.word	0x6e612073
 80029ac:	68742064 	.word	0x68742064
 80029b0:	6f662065 	.word	0x6f662065
 80029b4:	776f6c6c 	.word	0x776f6c6c
 80029b8:	20676e69 	.word	0x20676e69
 80029bc:	63736964 	.word	0x63736964
 80029c0:	6d69616c 	.word	0x6d69616c
 80029c4:	69207265 	.word	0x69207265
 80029c8:	6874206e 	.word	0x6874206e
 80029cc:	6f642065 	.word	0x6f642065
 80029d0:	656d7563 	.word	0x656d7563
 80029d4:	7461746e 	.word	0x7461746e
 80029d8:	0d6e6f69 	.word	0x0d6e6f69
 80029dc:	2020200a 	.word	0x2020200a
 80029e0:	6e612020 	.word	0x6e612020
 80029e4:	726f2f64 	.word	0x726f2f64
 80029e8:	68746f20 	.word	0x68746f20
 80029ec:	6d207265 	.word	0x6d207265
 80029f0:	72657461 	.word	0x72657461
 80029f4:	736c6169 	.word	0x736c6169
 80029f8:	6f727020 	.word	0x6f727020
 80029fc:	65646976 	.word	0x65646976
 8002a00:	69772064 	.word	0x69772064
 8002a04:	74206874 	.word	0x74206874
 8002a08:	64206568 	.word	0x64206568
 8002a0c:	72747369 	.word	0x72747369
 8002a10:	74756269 	.word	0x74756269
 8002a14:	2e6e6f69 	.word	0x2e6e6f69
 8002a18:	20200a0d 	.word	0x20200a0d
 8002a1c:	4e202e33 	.word	0x4e202e33
 8002a20:	68746965 	.word	0x68746965
 8002a24:	74207265 	.word	0x74207265
 8002a28:	6e206568 	.word	0x6e206568
 8002a2c:	20656d61 	.word	0x20656d61
 8002a30:	5320666f 	.word	0x5320666f
 8002a34:	63694d54 	.word	0x63694d54
 8002a38:	6c656f72 	.word	0x6c656f72
 8002a3c:	72746365 	.word	0x72746365
 8002a40:	63696e6f 	.word	0x63696e6f
 8002a44:	6f6e2073 	.word	0x6f6e2073
 8002a48:	68742072 	.word	0x68742072
 8002a4c:	616e2065 	.word	0x616e2065
 8002a50:	2073656d 	.word	0x2073656d
 8002a54:	6920666f 	.word	0x6920666f
 8002a58:	63207374 	.word	0x63207374
 8002a5c:	72746e6f 	.word	0x72746e6f
 8002a60:	74756269 	.word	0x74756269
 8002a64:	0d73726f 	.word	0x0d73726f
 8002a68:	2020200a 	.word	0x2020200a
 8002a6c:	616d2020 	.word	0x616d2020
 8002a70:	65622079 	.word	0x65622079
 8002a74:	65737520 	.word	0x65737520
 8002a78:	6f742064 	.word	0x6f742064
 8002a7c:	646e6520 	.word	0x646e6520
 8002a80:	6573726f 	.word	0x6573726f
 8002a84:	20726f20 	.word	0x20726f20
 8002a88:	6d6f7270 	.word	0x6d6f7270
 8002a8c:	2065746f 	.word	0x2065746f
 8002a90:	646f7270 	.word	0x646f7270
 8002a94:	73746375 	.word	0x73746375
 8002a98:	72656420 	.word	0x72656420
 8002a9c:	64657669 	.word	0x64657669
 8002aa0:	6f726620 	.word	0x6f726620
 8002aa4:	6874206d 	.word	0x6874206d
 8002aa8:	73207369 	.word	0x73207369
 8002aac:	7774666f 	.word	0x7774666f
 8002ab0:	0d657261 	.word	0x0d657261
 8002ab4:	2020200a 	.word	0x2020200a
 8002ab8:	69772020 	.word	0x69772020
 8002abc:	756f6874 	.word	0x756f6874
 8002ac0:	70732074 	.word	0x70732074
 8002ac4:	66696365 	.word	0x66696365
 8002ac8:	70206369 	.word	0x70206369
 8002acc:	726f6972 	.word	0x726f6972
 8002ad0:	69727720 	.word	0x69727720
 8002ad4:	6e657474 	.word	0x6e657474
 8002ad8:	72657020 	.word	0x72657020
 8002adc:	7373696d 	.word	0x7373696d
 8002ae0:	2e6e6f69 	.word	0x2e6e6f69
 8002ae4:	20200a0d 	.word	0x20200a0d
 8002ae8:	48540a0d 	.word	0x48540a0d
 8002aec:	53205349 	.word	0x53205349
 8002af0:	5754464f 	.word	0x5754464f
 8002af4:	20455241 	.word	0x20455241
 8002af8:	50205349 	.word	0x50205349
 8002afc:	49564f52 	.word	0x49564f52
 8002b00:	20444544 	.word	0x20444544
 8002b04:	54205942 	.word	0x54205942
 8002b08:	43204548 	.word	0x43204548
 8002b0c:	5259504f 	.word	0x5259504f
 8002b10:	54484749 	.word	0x54484749
 8002b14:	4c4f4820 	.word	0x4c4f4820
 8002b18:	53524544 	.word	0x53524544
 8002b1c:	444e4120 	.word	0x444e4120
 8002b20:	4e4f4320 	.word	0x4e4f4320
 8002b24:	42495254 	.word	0x42495254
 8002b28:	524f5455 	.word	0x524f5455
 8002b2c:	41222053 	.word	0x41222053
 8002b30:	53492053 	.word	0x53492053
 8002b34:	410a0d22 	.word	0x410a0d22
 8002b38:	4120444e 	.word	0x4120444e
 8002b3c:	4520594e 	.word	0x4520594e
 8002b40:	45525058 	.word	0x45525058
 8002b44:	4f205353 	.word	0x4f205353
 8002b48:	4d492052 	.word	0x4d492052
 8002b4c:	45494c50 	.word	0x45494c50
 8002b50:	41572044 	.word	0x41572044
 8002b54:	4e415252 	.word	0x4e415252
 8002b58:	53454954 	.word	0x53454954
 8002b5c:	4e49202c 	.word	0x4e49202c
 8002b60:	44554c43 	.word	0x44554c43
 8002b64:	2c474e49 	.word	0x2c474e49
 8002b68:	54554220 	.word	0x54554220
 8002b6c:	544f4e20 	.word	0x544f4e20
 8002b70:	4d494c20 	.word	0x4d494c20
 8002b74:	44455449 	.word	0x44455449
 8002b78:	2c4f5420 	.word	0x2c4f5420
 8002b7c:	45485420 	.word	0x45485420
 8002b80:	4d490a0d 	.word	0x4d490a0d
 8002b84:	45494c50 	.word	0x45494c50
 8002b88:	41572044 	.word	0x41572044
 8002b8c:	4e415252 	.word	0x4e415252
 8002b90:	53454954 	.word	0x53454954
 8002b94:	20464f20 	.word	0x20464f20
 8002b98:	4352454d 	.word	0x4352454d
 8002b9c:	544e4148 	.word	0x544e4148
 8002ba0:	4c494241 	.word	0x4c494241
 8002ba4:	20595449 	.word	0x20595449
 8002ba8:	20444e41 	.word	0x20444e41
 8002bac:	4e544946 	.word	0x4e544946
 8002bb0:	20535345 	.word	0x20535345
 8002bb4:	20524f46 	.word	0x20524f46
 8002bb8:	41502041 	.word	0x41502041
 8002bbc:	43495452 	.word	0x43495452
 8002bc0:	52414c55 	.word	0x52414c55
 8002bc4:	52555020 	.word	0x52555020
 8002bc8:	45534f50 	.word	0x45534f50
 8002bcc:	45524120 	.word	0x45524120
 8002bd0:	49440a0d 	.word	0x49440a0d
 8002bd4:	414c4353 	.word	0x414c4353
 8002bd8:	44454d49 	.word	0x44454d49
 8002bdc:	4e49202e 	.word	0x4e49202e
 8002be0:	204f4e20 	.word	0x204f4e20
 8002be4:	4e455645 	.word	0x4e455645
 8002be8:	48532054 	.word	0x48532054
 8002bec:	204c4c41 	.word	0x204c4c41
 8002bf0:	20454854 	.word	0x20454854
 8002bf4:	59504f43 	.word	0x59504f43
 8002bf8:	48474952 	.word	0x48474952
 8002bfc:	4f482054 	.word	0x4f482054
 8002c00:	5245444c 	.word	0x5245444c
 8002c04:	20524f20 	.word	0x20524f20
 8002c08:	544e4f43 	.word	0x544e4f43
 8002c0c:	55424952 	.word	0x55424952
 8002c10:	53524f54 	.word	0x53524f54
 8002c14:	20454220 	.word	0x20454220
 8002c18:	4241494c 	.word	0x4241494c
 8002c1c:	0a0d454c 	.word	0x0a0d454c
 8002c20:	20524f46 	.word	0x20524f46
 8002c24:	20594e41 	.word	0x20594e41
 8002c28:	45524944 	.word	0x45524944
 8002c2c:	202c5443 	.word	0x202c5443
 8002c30:	49444e49 	.word	0x49444e49
 8002c34:	54434552 	.word	0x54434552
 8002c38:	4e49202c 	.word	0x4e49202c
 8002c3c:	45444943 	.word	0x45444943
 8002c40:	4c41544e 	.word	0x4c41544e
 8002c44:	5053202c 	.word	0x5053202c
 8002c48:	41494345 	.word	0x41494345
 8002c4c:	45202c4c 	.word	0x45202c4c
 8002c50:	504d4558 	.word	0x504d4558
 8002c54:	5952414c 	.word	0x5952414c
 8002c58:	524f202c 	.word	0x524f202c
 8002c5c:	4e4f4320 	.word	0x4e4f4320
 8002c60:	55514553 	.word	0x55514553
 8002c64:	49544e45 	.word	0x49544e45
 8002c68:	0a0d4c41 	.word	0x0a0d4c41
 8002c6c:	414d4144 	.word	0x414d4144
 8002c70:	20534547 	.word	0x20534547
 8002c74:	434e4928 	.word	0x434e4928
 8002c78:	4944554c 	.word	0x4944554c
 8002c7c:	202c474e 	.word	0x202c474e
 8002c80:	20545542 	.word	0x20545542
 8002c84:	20544f4e 	.word	0x20544f4e
 8002c88:	494d494c 	.word	0x494d494c
 8002c8c:	20444554 	.word	0x20444554
 8002c90:	202c4f54 	.word	0x202c4f54
 8002c94:	434f5250 	.word	0x434f5250
 8002c98:	4d455255 	.word	0x4d455255
 8002c9c:	20544e45 	.word	0x20544e45
 8002ca0:	5320464f 	.word	0x5320464f
 8002ca4:	54534255 	.word	0x54534255
 8002ca8:	54555449 	.word	0x54555449
 8002cac:	4f472045 	.word	0x4f472045
 8002cb0:	2053444f 	.word	0x2053444f
 8002cb4:	0a0d524f 	.word	0x0a0d524f
 8002cb8:	56524553 	.word	0x56524553
 8002cbc:	53454349 	.word	0x53454349
 8002cc0:	4f4c203b 	.word	0x4f4c203b
 8002cc4:	4f205353 	.word	0x4f205353
 8002cc8:	53552046 	.word	0x53552046
 8002ccc:	44202c45 	.word	0x44202c45
 8002cd0:	2c415441 	.word	0x2c415441
 8002cd4:	20524f20 	.word	0x20524f20
 8002cd8:	464f5250 	.word	0x464f5250
 8002cdc:	3b535449 	.word	0x3b535449
 8002ce0:	20524f20 	.word	0x20524f20
 8002ce4:	49535542 	.word	0x49535542
 8002ce8:	5353454e 	.word	0x5353454e
 8002cec:	544e4920 	.word	0x544e4920
 8002cf0:	55525245 	.word	0x55525245
 8002cf4:	4f495450 	.word	0x4f495450
 8002cf8:	4820294e 	.word	0x4820294e
 8002cfc:	5645574f 	.word	0x5645574f
 8002d00:	0a0d5245 	.word	0x0a0d5245
 8002d04:	53554143 	.word	0x53554143
 8002d08:	41204445 	.word	0x41204445
 8002d0c:	4f20444e 	.word	0x4f20444e
 8002d10:	4e41204e 	.word	0x4e41204e
 8002d14:	48542059 	.word	0x48542059
 8002d18:	59524f45 	.word	0x59524f45
 8002d1c:	20464f20 	.word	0x20464f20
 8002d20:	4241494c 	.word	0x4241494c
 8002d24:	54494c49 	.word	0x54494c49
 8002d28:	57202c59 	.word	0x57202c59
 8002d2c:	48544548 	.word	0x48544548
 8002d30:	49205245 	.word	0x49205245
 8002d34:	4f43204e 	.word	0x4f43204e
 8002d38:	4152544e 	.word	0x4152544e
 8002d3c:	202c5443 	.word	0x202c5443
 8002d40:	49525453 	.word	0x49525453
 8002d44:	4c205443 	.word	0x4c205443
 8002d48:	49424149 	.word	0x49424149
 8002d4c:	5954494c 	.word	0x5954494c
 8002d50:	4f0a0d2c 	.word	0x4f0a0d2c
 8002d54:	4f542052 	.word	0x4f542052
 8002d58:	28205452 	.word	0x28205452
 8002d5c:	4c434e49 	.word	0x4c434e49
 8002d60:	4e494455 	.word	0x4e494455
 8002d64:	454e2047 	.word	0x454e2047
 8002d68:	47494c47 	.word	0x47494c47
 8002d6c:	45434e45 	.word	0x45434e45
 8002d70:	20524f20 	.word	0x20524f20
 8002d74:	4548544f 	.word	0x4548544f
 8002d78:	53495752 	.word	0x53495752
 8002d7c:	41202945 	.word	0x41202945
 8002d80:	49534952 	.word	0x49534952
 8002d84:	4920474e 	.word	0x4920474e
 8002d88:	4e41204e 	.word	0x4e41204e
 8002d8c:	41572059 	.word	0x41572059
 8002d90:	554f2059 	.word	0x554f2059
 8002d94:	464f2054 	.word	0x464f2054
 8002d98:	45485420 	.word	0x45485420
 8002d9c:	45535520 	.word	0x45535520
 8002da0:	464f0a0d 	.word	0x464f0a0d
 8002da4:	49485420 	.word	0x49485420
 8002da8:	4f532053 	.word	0x4f532053
 8002dac:	41575446 	.word	0x41575446
 8002db0:	202c4552 	.word	0x202c4552
 8002db4:	4e455645 	.word	0x4e455645
 8002db8:	20464920 	.word	0x20464920
 8002dbc:	49564441 	.word	0x49564441
 8002dc0:	20444553 	.word	0x20444553
 8002dc4:	5420464f 	.word	0x5420464f
 8002dc8:	50204548 	.word	0x50204548
 8002dcc:	4953534f 	.word	0x4953534f
 8002dd0:	494c4942 	.word	0x494c4942
 8002dd4:	4f205954 	.word	0x4f205954
 8002dd8:	55532046 	.word	0x55532046
 8002ddc:	44204843 	.word	0x44204843
 8002de0:	47414d41 	.word	0x47414d41
 8002de4:	0a0d2e45 	.word	0x0a0d2e45
 8002de8:	2a2a2a2a 	.word	0x2a2a2a2a
 8002dec:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df0:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df4:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df8:	2a2a2a2a 	.word	0x2a2a2a2a
 8002dfc:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e00:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e04:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e08:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e0c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e10:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e14:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e18:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e1c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e20:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e24:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e28:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e2c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e30:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e34:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e38:	0a0d2a2a 	.word	0x0a0d2a2a
 8002e3c:	62696843 	.word	0x62696843
 8002e40:	20534f69 	.word	0x20534f69
 8002e44:	6f43202d 	.word	0x6f43202d
 8002e48:	69727970 	.word	0x69727970
 8002e4c:	20746867 	.word	0x20746867
 8002e50:	20294328 	.word	0x20294328
 8002e54:	36303032 	.word	0x36303032
 8002e58:	30322e2e 	.word	0x30322e2e
 8002e5c:	47203631 	.word	0x47203631
 8002e60:	61766f69 	.word	0x61766f69
 8002e64:	20696e6e 	.word	0x20696e6e
 8002e68:	53206944 	.word	0x53206944
 8002e6c:	6f697269 	.word	0x6f697269
 8002e70:	0a0d0a0d 	.word	0x0a0d0a0d
 8002e74:	6563694c 	.word	0x6563694c
 8002e78:	6465736e 	.word	0x6465736e
 8002e7c:	646e7520 	.word	0x646e7520
 8002e80:	74207265 	.word	0x74207265
 8002e84:	41206568 	.word	0x41206568
 8002e88:	68636170 	.word	0x68636170
 8002e8c:	694c2065 	.word	0x694c2065
 8002e90:	736e6563 	.word	0x736e6563
 8002e94:	56202c65 	.word	0x56202c65
 8002e98:	69737265 	.word	0x69737265
 8002e9c:	32206e6f 	.word	0x32206e6f
 8002ea0:	2820302e 	.word	0x2820302e
 8002ea4:	20656874 	.word	0x20656874
 8002ea8:	63694c22 	.word	0x63694c22
 8002eac:	65736e65 	.word	0x65736e65
 8002eb0:	0d3b2922 	.word	0x0d3b2922
 8002eb4:	756f790a 	.word	0x756f790a
 8002eb8:	79616d20 	.word	0x79616d20
 8002ebc:	746f6e20 	.word	0x746f6e20
 8002ec0:	65737520 	.word	0x65737520
 8002ec4:	69687420 	.word	0x69687420
 8002ec8:	69662073 	.word	0x69662073
 8002ecc:	6520656c 	.word	0x6520656c
 8002ed0:	70656378 	.word	0x70656378
 8002ed4:	6e692074 	.word	0x6e692074
 8002ed8:	6d6f6320 	.word	0x6d6f6320
 8002edc:	61696c70 	.word	0x61696c70
 8002ee0:	2065636e 	.word	0x2065636e
 8002ee4:	68746977 	.word	0x68746977
 8002ee8:	65687420 	.word	0x65687420
 8002eec:	63694c20 	.word	0x63694c20
 8002ef0:	65736e65 	.word	0x65736e65
 8002ef4:	590a0d2e 	.word	0x590a0d2e
 8002ef8:	6d20756f 	.word	0x6d20756f
 8002efc:	6f207961 	.word	0x6f207961
 8002f00:	69617462 	.word	0x69617462
 8002f04:	2061206e 	.word	0x2061206e
 8002f08:	79706f63 	.word	0x79706f63
 8002f0c:	20666f20 	.word	0x20666f20
 8002f10:	20656874 	.word	0x20656874
 8002f14:	6563694c 	.word	0x6563694c
 8002f18:	2065736e 	.word	0x2065736e
 8002f1c:	0a0d7461 	.word	0x0a0d7461
 8002f20:	20200a0d 	.word	0x20200a0d
 8002f24:	74682020 	.word	0x74682020
 8002f28:	2f3a7074 	.word	0x2f3a7074
 8002f2c:	7777772f 	.word	0x7777772f
 8002f30:	6170612e 	.word	0x6170612e
 8002f34:	2e656863 	.word	0x2e656863
 8002f38:	2f67726f 	.word	0x2f67726f
 8002f3c:	6563696c 	.word	0x6563696c
 8002f40:	7365736e 	.word	0x7365736e
 8002f44:	43494c2f 	.word	0x43494c2f
 8002f48:	45534e45 	.word	0x45534e45
 8002f4c:	302e322d 	.word	0x302e322d
 8002f50:	0a0d0a0d 	.word	0x0a0d0a0d
 8002f54:	656c6e55 	.word	0x656c6e55
 8002f58:	72207373 	.word	0x72207373
 8002f5c:	69757165 	.word	0x69757165
 8002f60:	20646572 	.word	0x20646572
 8002f64:	61207962 	.word	0x61207962
 8002f68:	696c7070 	.word	0x696c7070
 8002f6c:	6c626163 	.word	0x6c626163
 8002f70:	616c2065 	.word	0x616c2065
 8002f74:	726f2077 	.word	0x726f2077
 8002f78:	72676120 	.word	0x72676120
 8002f7c:	20646565 	.word	0x20646565
 8002f80:	69206f74 	.word	0x69206f74
 8002f84:	7277206e 	.word	0x7277206e
 8002f88:	6e697469 	.word	0x6e697469
 8002f8c:	73202c67 	.word	0x73202c67
 8002f90:	7774666f 	.word	0x7774666f
 8002f94:	0d657261 	.word	0x0d657261
 8002f98:	7369640a 	.word	0x7369640a
 8002f9c:	62697274 	.word	0x62697274
 8002fa0:	64657475 	.word	0x64657475
 8002fa4:	646e7520 	.word	0x646e7520
 8002fa8:	74207265 	.word	0x74207265
 8002fac:	4c206568 	.word	0x4c206568
 8002fb0:	6e656369 	.word	0x6e656369
 8002fb4:	69206573 	.word	0x69206573
 8002fb8:	69642073 	.word	0x69642073
 8002fbc:	69727473 	.word	0x69727473
 8002fc0:	65747562 	.word	0x65747562
 8002fc4:	6e6f2064 	.word	0x6e6f2064
 8002fc8:	206e6120 	.word	0x206e6120
 8002fcc:	20534122 	.word	0x20534122
 8002fd0:	20225349 	.word	0x20225349
 8002fd4:	49534142 	.word	0x49534142
 8002fd8:	0a0d2c53 	.word	0x0a0d2c53
 8002fdc:	48544957 	.word	0x48544957
 8002fe0:	2054554f 	.word	0x2054554f
 8002fe4:	52524157 	.word	0x52524157
 8002fe8:	49544e41 	.word	0x49544e41
 8002fec:	4f205345 	.word	0x4f205345
 8002ff0:	4f432052 	.word	0x4f432052
 8002ff4:	5449444e 	.word	0x5449444e
 8002ff8:	534e4f49 	.word	0x534e4f49
 8002ffc:	20464f20 	.word	0x20464f20
 8003000:	20594e41 	.word	0x20594e41
 8003004:	444e494b 	.word	0x444e494b
 8003008:	6965202c 	.word	0x6965202c
 800300c:	72656874 	.word	0x72656874
 8003010:	70786520 	.word	0x70786520
 8003014:	73736572 	.word	0x73736572
 8003018:	20726f20 	.word	0x20726f20
 800301c:	6c706d69 	.word	0x6c706d69
 8003020:	2e646569 	.word	0x2e646569
 8003024:	65530a0d 	.word	0x65530a0d
 8003028:	68742065 	.word	0x68742065
 800302c:	694c2065 	.word	0x694c2065
 8003030:	736e6563 	.word	0x736e6563
 8003034:	6f662065 	.word	0x6f662065
 8003038:	68742072 	.word	0x68742072
 800303c:	70732065 	.word	0x70732065
 8003040:	66696365 	.word	0x66696365
 8003044:	6c206369 	.word	0x6c206369
 8003048:	75676e61 	.word	0x75676e61
 800304c:	20656761 	.word	0x20656761
 8003050:	65766f67 	.word	0x65766f67
 8003054:	6e696e72 	.word	0x6e696e72
 8003058:	65702067 	.word	0x65702067
 800305c:	73696d72 	.word	0x73696d72
 8003060:	6e6f6973 	.word	0x6e6f6973
 8003064:	6e612073 	.word	0x6e612073
 8003068:	6c0a0d64 	.word	0x6c0a0d64
 800306c:	74696d69 	.word	0x74696d69
 8003070:	6f697461 	.word	0x6f697461
 8003074:	7520736e 	.word	0x7520736e
 8003078:	7265646e 	.word	0x7265646e
 800307c:	65687420 	.word	0x65687420
 8003080:	63694c20 	.word	0x63694c20
 8003084:	65736e65 	.word	0x65736e65
 8003088:	2a0a0d2e 	.word	0x2a0a0d2e
 800308c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003090:	2a2a2a2a 	.word	0x2a2a2a2a
 8003094:	2a2a2a2a 	.word	0x2a2a2a2a
 8003098:	2a2a2a2a 	.word	0x2a2a2a2a
 800309c:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030cc:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030dc:	430a0d2a 	.word	0x430a0d2a
 80030e0:	7279706f 	.word	0x7279706f
 80030e4:	74686769 	.word	0x74686769
 80030e8:	29632820 	.word	0x29632820
 80030ec:	31303220 	.word	0x31303220
 80030f0:	30322d37 	.word	0x30322d37
 80030f4:	202c3831 	.word	0x202c3831
 80030f8:	74726542 	.word	0x74726542
 80030fc:	20646c6f 	.word	0x20646c6f
 8003100:	206e6156 	.word	0x206e6156
 8003104:	206e6564 	.word	0x206e6564
 8003108:	67726542 	.word	0x67726542
 800310c:	76282068 	.word	0x76282068
 8003110:	65646e61 	.word	0x65646e61
 8003114:	7265626e 	.word	0x7265626e
 8003118:	62406867 	.word	0x62406867
 800311c:	6f747265 	.word	0x6f747265
 8003120:	6f2e646c 	.word	0x6f2e646c
 8003124:	0d296772 	.word	0x0d296772
 8003128:	6c6c410a 	.word	0x6c6c410a
 800312c:	67697220 	.word	0x67697220
 8003130:	20737468 	.word	0x20737468
 8003134:	65736572 	.word	0x65736572
 8003138:	64657672 	.word	0x64657672
 800313c:	540a0d2e 	.word	0x540a0d2e
 8003140:	20736968 	.word	0x20736968
 8003144:	6b726f77 	.word	0x6b726f77
 8003148:	73616820 	.word	0x73616820
 800314c:	65656220 	.word	0x65656220
 8003150:	6564206e 	.word	0x6564206e
 8003154:	6f6c6576 	.word	0x6f6c6576
 8003158:	20646570 	.word	0x20646570
 800315c:	73206f74 	.word	0x73206f74
 8003160:	6f707075 	.word	0x6f707075
 8003164:	72207472 	.word	0x72207472
 8003168:	61657365 	.word	0x61657365
 800316c:	20686372 	.word	0x20686372
 8003170:	646e7566 	.word	0x646e7566
 8003174:	62206465 	.word	0x62206465
 8003178:	220a0d79 	.word	0x220a0d79
 800317c:	646e7546 	.word	0x646e7546
 8003180:	726f6620 	.word	0x726f6620
 8003184:	69635320 	.word	0x69635320
 8003188:	69746e65 	.word	0x69746e65
 800318c:	20636966 	.word	0x20636966
 8003190:	65736552 	.word	0x65736552
 8003194:	68637261 	.word	0x68637261
 8003198:	6c46202c 	.word	0x6c46202c
 800319c:	65646e61 	.word	0x65646e61
 80031a0:	20227372 	.word	0x20227372
 80031a4:	572e4628 	.word	0x572e4628
 80031a8:	2d2e4f2e 	.word	0x2d2e4f2e
 80031ac:	61616c56 	.word	0x61616c56
 80031b0:	7265646e 	.word	0x7265646e
 80031b4:	2e296e65 	.word	0x2e296e65
 80031b8:	0a0d0a0d 	.word	0x0a0d0a0d
 80031bc:	69646552 	.word	0x69646552
 80031c0:	69727473 	.word	0x69727473
 80031c4:	69747562 	.word	0x69747562
 80031c8:	61206e6f 	.word	0x61206e6f
 80031cc:	7520646e 	.word	0x7520646e
 80031d0:	69206573 	.word	0x69206573
 80031d4:	6f73206e 	.word	0x6f73206e
 80031d8:	65637275 	.word	0x65637275
 80031dc:	646e6120 	.word	0x646e6120
 80031e0:	6e696220 	.word	0x6e696220
 80031e4:	20797261 	.word	0x20797261
 80031e8:	6d726f66 	.word	0x6d726f66
 80031ec:	77202c73 	.word	0x77202c73
 80031f0:	20687469 	.word	0x20687469
 80031f4:	7720726f 	.word	0x7720726f
 80031f8:	6f687469 	.word	0x6f687469
 80031fc:	0a0d7475 	.word	0x0a0d7475
 8003200:	69646f6d 	.word	0x69646f6d
 8003204:	61636966 	.word	0x61636966
 8003208:	6e6f6974 	.word	0x6e6f6974
 800320c:	7261202c 	.word	0x7261202c
 8003210:	65702065 	.word	0x65702065
 8003214:	74696d72 	.word	0x74696d72
 8003218:	20646574 	.word	0x20646574
 800321c:	766f7270 	.word	0x766f7270
 8003220:	64656469 	.word	0x64656469
 8003224:	61687420 	.word	0x61687420
 8003228:	68742074 	.word	0x68742074
 800322c:	6f662065 	.word	0x6f662065
 8003230:	776f6c6c 	.word	0x776f6c6c
 8003234:	20676e69 	.word	0x20676e69
 8003238:	646e6f63 	.word	0x646e6f63
 800323c:	6f697469 	.word	0x6f697469
 8003240:	6120736e 	.word	0x6120736e
 8003244:	6d206572 	.word	0x6d206572
 8003248:	0d3a7465 	.word	0x0d3a7465
 800324c:	2020200a 	.word	0x2020200a
 8003250:	52202a20 	.word	0x52202a20
 8003254:	73696465 	.word	0x73696465
 8003258:	62697274 	.word	0x62697274
 800325c:	6f697475 	.word	0x6f697475
 8003260:	6f20736e 	.word	0x6f20736e
 8003264:	6f732066 	.word	0x6f732066
 8003268:	65637275 	.word	0x65637275
 800326c:	646f6320 	.word	0x646f6320
 8003270:	756d2065 	.word	0x756d2065
 8003274:	72207473 	.word	0x72207473
 8003278:	69617465 	.word	0x69617465
 800327c:	6874206e 	.word	0x6874206e
 8003280:	62612065 	.word	0x62612065
 8003284:	2065766f 	.word	0x2065766f
 8003288:	79706f63 	.word	0x79706f63
 800328c:	68676972 	.word	0x68676972
 8003290:	200a0d74 	.word	0x200a0d74
 8003294:	20202020 	.word	0x20202020
 8003298:	746f6e20 	.word	0x746f6e20
 800329c:	2c656369 	.word	0x2c656369
 80032a0:	69687420 	.word	0x69687420
 80032a4:	696c2073 	.word	0x696c2073
 80032a8:	6f207473 	.word	0x6f207473
 80032ac:	6f632066 	.word	0x6f632066
 80032b0:	7469646e 	.word	0x7469646e
 80032b4:	736e6f69 	.word	0x736e6f69
 80032b8:	646e6120 	.word	0x646e6120
 80032bc:	65687420 	.word	0x65687420
 80032c0:	6c6f6620 	.word	0x6c6f6620
 80032c4:	69776f6c 	.word	0x69776f6c
 80032c8:	6420676e 	.word	0x6420676e
 80032cc:	6c637369 	.word	0x6c637369
 80032d0:	656d6961 	.word	0x656d6961
 80032d4:	0a0d2e72 	.word	0x0a0d2e72
 80032d8:	20202020 	.word	0x20202020
 80032dc:	6552202a 	.word	0x6552202a
 80032e0:	74736964 	.word	0x74736964
 80032e4:	75626972 	.word	0x75626972
 80032e8:	6e6f6974 	.word	0x6e6f6974
 80032ec:	6e692073 	.word	0x6e692073
 80032f0:	6e696220 	.word	0x6e696220
 80032f4:	20797261 	.word	0x20797261
 80032f8:	6d726f66 	.word	0x6d726f66
 80032fc:	73756d20 	.word	0x73756d20
 8003300:	65722074 	.word	0x65722074
 8003304:	646f7270 	.word	0x646f7270
 8003308:	20656375 	.word	0x20656375
 800330c:	20656874 	.word	0x20656874
 8003310:	766f6261 	.word	0x766f6261
 8003314:	6f632065 	.word	0x6f632065
 8003318:	69727970 	.word	0x69727970
 800331c:	0d746867 	.word	0x0d746867
 8003320:	2020200a 	.word	0x2020200a
 8003324:	6e202020 	.word	0x6e202020
 8003328:	6369746f 	.word	0x6369746f
 800332c:	74202c65 	.word	0x74202c65
 8003330:	20736968 	.word	0x20736968
 8003334:	7473696c 	.word	0x7473696c
 8003338:	20666f20 	.word	0x20666f20
 800333c:	646e6f63 	.word	0x646e6f63
 8003340:	6f697469 	.word	0x6f697469
 8003344:	6120736e 	.word	0x6120736e
 8003348:	7420646e 	.word	0x7420646e
 800334c:	66206568 	.word	0x66206568
 8003350:	6f6c6c6f 	.word	0x6f6c6c6f
 8003354:	676e6977 	.word	0x676e6977
 8003358:	73696420 	.word	0x73696420
 800335c:	69616c63 	.word	0x69616c63
 8003360:	2072656d 	.word	0x2072656d
 8003364:	74206e69 	.word	0x74206e69
 8003368:	0a0d6568 	.word	0x0a0d6568
 800336c:	20202020 	.word	0x20202020
 8003370:	6f642020 	.word	0x6f642020
 8003374:	656d7563 	.word	0x656d7563
 8003378:	7461746e 	.word	0x7461746e
 800337c:	206e6f69 	.word	0x206e6f69
 8003380:	2f646e61 	.word	0x2f646e61
 8003384:	6f20726f 	.word	0x6f20726f
 8003388:	72656874 	.word	0x72656874
 800338c:	74616d20 	.word	0x74616d20
 8003390:	61697265 	.word	0x61697265
 8003394:	7020736c 	.word	0x7020736c
 8003398:	69766f72 	.word	0x69766f72
 800339c:	20646564 	.word	0x20646564
 80033a0:	68746977 	.word	0x68746977
 80033a4:	65687420 	.word	0x65687420
 80033a8:	73696420 	.word	0x73696420
 80033ac:	62697274 	.word	0x62697274
 80033b0:	6f697475 	.word	0x6f697475
 80033b4:	0a0d2e6e 	.word	0x0a0d2e6e
 80033b8:	20202020 	.word	0x20202020
 80033bc:	654e202a 	.word	0x654e202a
 80033c0:	65687469 	.word	0x65687469
 80033c4:	68742072 	.word	0x68742072
 80033c8:	616e2065 	.word	0x616e2065
 80033cc:	6f20656d 	.word	0x6f20656d
 80033d0:	68742066 	.word	0x68742066
 80033d4:	75612065 	.word	0x75612065
 80033d8:	726f6874 	.word	0x726f6874
 80033dc:	726f6e20 	.word	0x726f6e20
 80033e0:	65687420 	.word	0x65687420
 80033e4:	20200a0d 	.word	0x20200a0d
 80033e8:	20202020 	.word	0x20202020
 80033ec:	656d616e 	.word	0x656d616e
 80033f0:	666f2073 	.word	0x666f2073
 80033f4:	73746920 	.word	0x73746920
 80033f8:	6e6f6320 	.word	0x6e6f6320
 80033fc:	62697274 	.word	0x62697274
 8003400:	726f7475 	.word	0x726f7475
 8003404:	616d2073 	.word	0x616d2073
 8003408:	65622079 	.word	0x65622079
 800340c:	65737520 	.word	0x65737520
 8003410:	6f742064 	.word	0x6f742064
 8003414:	646e6520 	.word	0x646e6520
 8003418:	6573726f 	.word	0x6573726f
 800341c:	20726f20 	.word	0x20726f20
 8003420:	6d6f7270 	.word	0x6d6f7270
 8003424:	2065746f 	.word	0x2065746f
 8003428:	646f7270 	.word	0x646f7270
 800342c:	73746375 	.word	0x73746375
 8003430:	20200a0d 	.word	0x20200a0d
 8003434:	20202020 	.word	0x20202020
 8003438:	69726564 	.word	0x69726564
 800343c:	20646576 	.word	0x20646576
 8003440:	6d6f7266 	.word	0x6d6f7266
 8003444:	69687420 	.word	0x69687420
 8003448:	6f732073 	.word	0x6f732073
 800344c:	61777466 	.word	0x61777466
 8003450:	77206572 	.word	0x77206572
 8003454:	6f687469 	.word	0x6f687469
 8003458:	73207475 	.word	0x73207475
 800345c:	69636570 	.word	0x69636570
 8003460:	20636966 	.word	0x20636966
 8003464:	6f697270 	.word	0x6f697270
 8003468:	72772072 	.word	0x72772072
 800346c:	65747469 	.word	0x65747469
 8003470:	6570206e 	.word	0x6570206e
 8003474:	73696d72 	.word	0x73696d72
 8003478:	6e6f6973 	.word	0x6e6f6973
 800347c:	0d0a0d2e 	.word	0x0d0a0d2e
 8003480:	4948540a 	.word	0x4948540a
 8003484:	4f532053 	.word	0x4f532053
 8003488:	41575446 	.word	0x41575446
 800348c:	49204552 	.word	0x49204552
 8003490:	52502053 	.word	0x52502053
 8003494:	4449564f 	.word	0x4449564f
 8003498:	42204445 	.word	0x42204445
 800349c:	48542059 	.word	0x48542059
 80034a0:	4f432045 	.word	0x4f432045
 80034a4:	49525950 	.word	0x49525950
 80034a8:	20544847 	.word	0x20544847
 80034ac:	444c4f48 	.word	0x444c4f48
 80034b0:	20535245 	.word	0x20535245
 80034b4:	20444e41 	.word	0x20444e41
 80034b8:	544e4f43 	.word	0x544e4f43
 80034bc:	55424952 	.word	0x55424952
 80034c0:	53524f54 	.word	0x53524f54
 80034c4:	53412220 	.word	0x53412220
 80034c8:	22534920 	.word	0x22534920
 80034cc:	444e4120 	.word	0x444e4120
 80034d0:	4e410a0d 	.word	0x4e410a0d
 80034d4:	58452059 	.word	0x58452059
 80034d8:	53455250 	.word	0x53455250
 80034dc:	524f2053 	.word	0x524f2053
 80034e0:	504d4920 	.word	0x504d4920
 80034e4:	4445494c 	.word	0x4445494c
 80034e8:	52415720 	.word	0x52415720
 80034ec:	544e4152 	.word	0x544e4152
 80034f0:	2c534549 	.word	0x2c534549
 80034f4:	434e4920 	.word	0x434e4920
 80034f8:	4944554c 	.word	0x4944554c
 80034fc:	202c474e 	.word	0x202c474e
 8003500:	20545542 	.word	0x20545542
 8003504:	20544f4e 	.word	0x20544f4e
 8003508:	494d494c 	.word	0x494d494c
 800350c:	20444554 	.word	0x20444554
 8003510:	202c4f54 	.word	0x202c4f54
 8003514:	20454854 	.word	0x20454854
 8003518:	4c504d49 	.word	0x4c504d49
 800351c:	0d444549 	.word	0x0d444549
 8003520:	5241570a 	.word	0x5241570a
 8003524:	544e4152 	.word	0x544e4152
 8003528:	20534549 	.word	0x20534549
 800352c:	4d20464f 	.word	0x4d20464f
 8003530:	48435245 	.word	0x48435245
 8003534:	41544e41 	.word	0x41544e41
 8003538:	494c4942 	.word	0x494c4942
 800353c:	41205954 	.word	0x41205954
 8003540:	4620444e 	.word	0x4620444e
 8003544:	454e5449 	.word	0x454e5449
 8003548:	46205353 	.word	0x46205353
 800354c:	4120524f 	.word	0x4120524f
 8003550:	52415020 	.word	0x52415020
 8003554:	55434954 	.word	0x55434954
 8003558:	2052414c 	.word	0x2052414c
 800355c:	50525550 	.word	0x50525550
 8003560:	2045534f 	.word	0x2045534f
 8003564:	0d455241 	.word	0x0d455241
 8003568:	5349440a 	.word	0x5349440a
 800356c:	49414c43 	.word	0x49414c43
 8003570:	2e44454d 	.word	0x2e44454d
 8003574:	204e4920 	.word	0x204e4920
 8003578:	45204f4e 	.word	0x45204f4e
 800357c:	544e4556 	.word	0x544e4556
 8003580:	41485320 	.word	0x41485320
 8003584:	54204c4c 	.word	0x54204c4c
 8003588:	41204548 	.word	0x41204548
 800358c:	4f485455 	.word	0x4f485455
 8003590:	524f2052 	.word	0x524f2052
 8003594:	53494420 	.word	0x53494420
 8003598:	42495254 	.word	0x42495254
 800359c:	524f5455 	.word	0x524f5455
 80035a0:	20454220 	.word	0x20454220
 80035a4:	4241494c 	.word	0x4241494c
 80035a8:	4620454c 	.word	0x4620454c
 80035ac:	4120524f 	.word	0x4120524f
 80035b0:	0a0d594e 	.word	0x0a0d594e
 80035b4:	45524944 	.word	0x45524944
 80035b8:	202c5443 	.word	0x202c5443
 80035bc:	49444e49 	.word	0x49444e49
 80035c0:	54434552 	.word	0x54434552
 80035c4:	4e49202c 	.word	0x4e49202c
 80035c8:	45444943 	.word	0x45444943
 80035cc:	4c41544e 	.word	0x4c41544e
 80035d0:	5053202c 	.word	0x5053202c
 80035d4:	41494345 	.word	0x41494345
 80035d8:	45202c4c 	.word	0x45202c4c
 80035dc:	504d4558 	.word	0x504d4558
 80035e0:	5952414c 	.word	0x5952414c
 80035e4:	524f202c 	.word	0x524f202c
 80035e8:	4e4f4320 	.word	0x4e4f4320
 80035ec:	55514553 	.word	0x55514553
 80035f0:	49544e45 	.word	0x49544e45
 80035f4:	44204c41 	.word	0x44204c41
 80035f8:	47414d41 	.word	0x47414d41
 80035fc:	0a0d5345 	.word	0x0a0d5345
 8003600:	434e4928 	.word	0x434e4928
 8003604:	4944554c 	.word	0x4944554c
 8003608:	202c474e 	.word	0x202c474e
 800360c:	20545542 	.word	0x20545542
 8003610:	20544f4e 	.word	0x20544f4e
 8003614:	494d494c 	.word	0x494d494c
 8003618:	20444554 	.word	0x20444554
 800361c:	202c4f54 	.word	0x202c4f54
 8003620:	434f5250 	.word	0x434f5250
 8003624:	4d455255 	.word	0x4d455255
 8003628:	20544e45 	.word	0x20544e45
 800362c:	5320464f 	.word	0x5320464f
 8003630:	54534255 	.word	0x54534255
 8003634:	54555449 	.word	0x54555449
 8003638:	4f472045 	.word	0x4f472045
 800363c:	2053444f 	.word	0x2053444f
 8003640:	5320524f 	.word	0x5320524f
 8003644:	49565245 	.word	0x49565245
 8003648:	3b534543 	.word	0x3b534543
 800364c:	4f4c0a0d 	.word	0x4f4c0a0d
 8003650:	4f205353 	.word	0x4f205353
 8003654:	53552046 	.word	0x53552046
 8003658:	44202c45 	.word	0x44202c45
 800365c:	2c415441 	.word	0x2c415441
 8003660:	20524f20 	.word	0x20524f20
 8003664:	464f5250 	.word	0x464f5250
 8003668:	3b535449 	.word	0x3b535449
 800366c:	20524f20 	.word	0x20524f20
 8003670:	49535542 	.word	0x49535542
 8003674:	5353454e 	.word	0x5353454e
 8003678:	544e4920 	.word	0x544e4920
 800367c:	55525245 	.word	0x55525245
 8003680:	4f495450 	.word	0x4f495450
 8003684:	4820294e 	.word	0x4820294e
 8003688:	5645574f 	.word	0x5645574f
 800368c:	43205245 	.word	0x43205245
 8003690:	45535541 	.word	0x45535541
 8003694:	4e412044 	.word	0x4e412044
 8003698:	4f0a0d44 	.word	0x4f0a0d44
 800369c:	4e41204e 	.word	0x4e41204e
 80036a0:	48542059 	.word	0x48542059
 80036a4:	59524f45 	.word	0x59524f45
 80036a8:	20464f20 	.word	0x20464f20
 80036ac:	4241494c 	.word	0x4241494c
 80036b0:	54494c49 	.word	0x54494c49
 80036b4:	57202c59 	.word	0x57202c59
 80036b8:	48544548 	.word	0x48544548
 80036bc:	49205245 	.word	0x49205245
 80036c0:	4f43204e 	.word	0x4f43204e
 80036c4:	4152544e 	.word	0x4152544e
 80036c8:	202c5443 	.word	0x202c5443
 80036cc:	49525453 	.word	0x49525453
 80036d0:	4c205443 	.word	0x4c205443
 80036d4:	49424149 	.word	0x49424149
 80036d8:	5954494c 	.word	0x5954494c
 80036dc:	524f202c 	.word	0x524f202c
 80036e0:	524f5420 	.word	0x524f5420
 80036e4:	280a0d54 	.word	0x280a0d54
 80036e8:	4c434e49 	.word	0x4c434e49
 80036ec:	4e494455 	.word	0x4e494455
 80036f0:	454e2047 	.word	0x454e2047
 80036f4:	47494c47 	.word	0x47494c47
 80036f8:	45434e45 	.word	0x45434e45
 80036fc:	20524f20 	.word	0x20524f20
 8003700:	4548544f 	.word	0x4548544f
 8003704:	53495752 	.word	0x53495752
 8003708:	41202945 	.word	0x41202945
 800370c:	49534952 	.word	0x49534952
 8003710:	4920474e 	.word	0x4920474e
 8003714:	4e41204e 	.word	0x4e41204e
 8003718:	41572059 	.word	0x41572059
 800371c:	554f2059 	.word	0x554f2059
 8003720:	464f2054 	.word	0x464f2054
 8003724:	45485420 	.word	0x45485420
 8003728:	45535520 	.word	0x45535520
 800372c:	20464f20 	.word	0x20464f20
 8003730:	53494854 	.word	0x53494854
 8003734:	4f530a0d 	.word	0x4f530a0d
 8003738:	41575446 	.word	0x41575446
 800373c:	202c4552 	.word	0x202c4552
 8003740:	4e455645 	.word	0x4e455645
 8003744:	20464920 	.word	0x20464920
 8003748:	49564441 	.word	0x49564441
 800374c:	20444553 	.word	0x20444553
 8003750:	5420464f 	.word	0x5420464f
 8003754:	50204548 	.word	0x50204548
 8003758:	4953534f 	.word	0x4953534f
 800375c:	494c4942 	.word	0x494c4942
 8003760:	4f205954 	.word	0x4f205954
 8003764:	55532046 	.word	0x55532046
 8003768:	44204843 	.word	0x44204843
 800376c:	47414d41 	.word	0x47414d41
 8003770:	0a0d2e45 	.word	0x0a0d2e45
 8003774:	2a2a2a2a 	.word	0x2a2a2a2a
 8003778:	2a2a2a2a 	.word	0x2a2a2a2a
 800377c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003780:	2a2a2a2a 	.word	0x2a2a2a2a
 8003784:	2a2a2a2a 	.word	0x2a2a2a2a
 8003788:	2a2a2a2a 	.word	0x2a2a2a2a
 800378c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003790:	2a2a2a2a 	.word	0x2a2a2a2a
 8003794:	2a2a2a2a 	.word	0x2a2a2a2a
 8003798:	2a2a2a2a 	.word	0x2a2a2a2a
 800379c:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a4:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80037ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80037bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80037c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037c4:	0a0d2a2a 	.word	0x0a0d2a2a
 80037c8:	0d00      	.short	0x0d00
 80037ca:	0a          	.byte	0x0a

080037cb <_binary_data_license_bin_end>:
	...

080037cc <__aeabi_uldivmod>:
 80037cc:	b953      	cbnz	r3, 80037e4 <__aeabi_uldivmod+0x18>
 80037ce:	b94a      	cbnz	r2, 80037e4 <__aeabi_uldivmod+0x18>
 80037d0:	2900      	cmp	r1, #0
 80037d2:	bf08      	it	eq
 80037d4:	2800      	cmpeq	r0, #0
 80037d6:	bf1c      	itt	ne
 80037d8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80037dc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80037e0:	f000 b976 	b.w	8003ad0 <__aeabi_idiv0>
 80037e4:	f1ad 0c08 	sub.w	ip, sp, #8
 80037e8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80037ec:	f000 f806 	bl	80037fc <__udivmoddi4>
 80037f0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80037f4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80037f8:	b004      	add	sp, #16
 80037fa:	4770      	bx	lr

080037fc <__udivmoddi4>:
 80037fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003800:	9e08      	ldr	r6, [sp, #32]
 8003802:	460d      	mov	r5, r1
 8003804:	4604      	mov	r4, r0
 8003806:	4688      	mov	r8, r1
 8003808:	2b00      	cmp	r3, #0
 800380a:	d14d      	bne.n	80038a8 <__udivmoddi4+0xac>
 800380c:	428a      	cmp	r2, r1
 800380e:	4694      	mov	ip, r2
 8003810:	d968      	bls.n	80038e4 <__udivmoddi4+0xe8>
 8003812:	fab2 f282 	clz	r2, r2
 8003816:	b152      	cbz	r2, 800382e <__udivmoddi4+0x32>
 8003818:	fa01 f302 	lsl.w	r3, r1, r2
 800381c:	f1c2 0120 	rsb	r1, r2, #32
 8003820:	fa20 f101 	lsr.w	r1, r0, r1
 8003824:	fa0c fc02 	lsl.w	ip, ip, r2
 8003828:	ea41 0803 	orr.w	r8, r1, r3
 800382c:	4094      	lsls	r4, r2
 800382e:	ea4f 411c 	mov.w	r1, ip, lsr #16
 8003832:	fbb8 f7f1 	udiv	r7, r8, r1
 8003836:	fa1f fe8c 	uxth.w	lr, ip
 800383a:	fb01 8817 	mls	r8, r1, r7, r8
 800383e:	fb07 f00e 	mul.w	r0, r7, lr
 8003842:	0c23      	lsrs	r3, r4, #16
 8003844:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8003848:	4298      	cmp	r0, r3
 800384a:	d90a      	bls.n	8003862 <__udivmoddi4+0x66>
 800384c:	eb1c 0303 	adds.w	r3, ip, r3
 8003850:	f107 35ff 	add.w	r5, r7, #4294967295	; 0xffffffff
 8003854:	f080 811e 	bcs.w	8003a94 <__udivmoddi4+0x298>
 8003858:	4298      	cmp	r0, r3
 800385a:	f240 811b 	bls.w	8003a94 <__udivmoddi4+0x298>
 800385e:	3f02      	subs	r7, #2
 8003860:	4463      	add	r3, ip
 8003862:	1a1b      	subs	r3, r3, r0
 8003864:	fbb3 f0f1 	udiv	r0, r3, r1
 8003868:	fb01 3310 	mls	r3, r1, r0, r3
 800386c:	fb00 fe0e 	mul.w	lr, r0, lr
 8003870:	b2a4      	uxth	r4, r4
 8003872:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8003876:	45a6      	cmp	lr, r4
 8003878:	d90a      	bls.n	8003890 <__udivmoddi4+0x94>
 800387a:	eb1c 0404 	adds.w	r4, ip, r4
 800387e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8003882:	f080 8109 	bcs.w	8003a98 <__udivmoddi4+0x29c>
 8003886:	45a6      	cmp	lr, r4
 8003888:	f240 8106 	bls.w	8003a98 <__udivmoddi4+0x29c>
 800388c:	4464      	add	r4, ip
 800388e:	3802      	subs	r0, #2
 8003890:	2100      	movs	r1, #0
 8003892:	eba4 040e 	sub.w	r4, r4, lr
 8003896:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800389a:	b11e      	cbz	r6, 80038a4 <__udivmoddi4+0xa8>
 800389c:	2300      	movs	r3, #0
 800389e:	40d4      	lsrs	r4, r2
 80038a0:	e9c6 4300 	strd	r4, r3, [r6]
 80038a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80038a8:	428b      	cmp	r3, r1
 80038aa:	d908      	bls.n	80038be <__udivmoddi4+0xc2>
 80038ac:	2e00      	cmp	r6, #0
 80038ae:	f000 80ee 	beq.w	8003a8e <__udivmoddi4+0x292>
 80038b2:	2100      	movs	r1, #0
 80038b4:	e9c6 0500 	strd	r0, r5, [r6]
 80038b8:	4608      	mov	r0, r1
 80038ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80038be:	fab3 f183 	clz	r1, r3
 80038c2:	2900      	cmp	r1, #0
 80038c4:	d14a      	bne.n	800395c <__udivmoddi4+0x160>
 80038c6:	42ab      	cmp	r3, r5
 80038c8:	d302      	bcc.n	80038d0 <__udivmoddi4+0xd4>
 80038ca:	4282      	cmp	r2, r0
 80038cc:	f200 80fc 	bhi.w	8003ac8 <__udivmoddi4+0x2cc>
 80038d0:	1a84      	subs	r4, r0, r2
 80038d2:	eb65 0303 	sbc.w	r3, r5, r3
 80038d6:	2001      	movs	r0, #1
 80038d8:	4698      	mov	r8, r3
 80038da:	2e00      	cmp	r6, #0
 80038dc:	d0e2      	beq.n	80038a4 <__udivmoddi4+0xa8>
 80038de:	e9c6 4800 	strd	r4, r8, [r6]
 80038e2:	e7df      	b.n	80038a4 <__udivmoddi4+0xa8>
 80038e4:	b902      	cbnz	r2, 80038e8 <__udivmoddi4+0xec>
 80038e6:	deff      	udf	#255	; 0xff
 80038e8:	fab2 f282 	clz	r2, r2
 80038ec:	2a00      	cmp	r2, #0
 80038ee:	f040 8091 	bne.w	8003a14 <__udivmoddi4+0x218>
 80038f2:	eba1 000c 	sub.w	r0, r1, ip
 80038f6:	2101      	movs	r1, #1
 80038f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80038fc:	fa1f fe8c 	uxth.w	lr, ip
 8003900:	fbb0 f3f7 	udiv	r3, r0, r7
 8003904:	fb07 0013 	mls	r0, r7, r3, r0
 8003908:	0c25      	lsrs	r5, r4, #16
 800390a:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 800390e:	fb0e f003 	mul.w	r0, lr, r3
 8003912:	42a8      	cmp	r0, r5
 8003914:	d908      	bls.n	8003928 <__udivmoddi4+0x12c>
 8003916:	eb1c 0505 	adds.w	r5, ip, r5
 800391a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800391e:	d202      	bcs.n	8003926 <__udivmoddi4+0x12a>
 8003920:	42a8      	cmp	r0, r5
 8003922:	f200 80ce 	bhi.w	8003ac2 <__udivmoddi4+0x2c6>
 8003926:	4643      	mov	r3, r8
 8003928:	1a2d      	subs	r5, r5, r0
 800392a:	fbb5 f0f7 	udiv	r0, r5, r7
 800392e:	fb07 5510 	mls	r5, r7, r0, r5
 8003932:	fb0e fe00 	mul.w	lr, lr, r0
 8003936:	b2a4      	uxth	r4, r4
 8003938:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800393c:	45a6      	cmp	lr, r4
 800393e:	d908      	bls.n	8003952 <__udivmoddi4+0x156>
 8003940:	eb1c 0404 	adds.w	r4, ip, r4
 8003944:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8003948:	d202      	bcs.n	8003950 <__udivmoddi4+0x154>
 800394a:	45a6      	cmp	lr, r4
 800394c:	f200 80b6 	bhi.w	8003abc <__udivmoddi4+0x2c0>
 8003950:	4628      	mov	r0, r5
 8003952:	eba4 040e 	sub.w	r4, r4, lr
 8003956:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800395a:	e79e      	b.n	800389a <__udivmoddi4+0x9e>
 800395c:	f1c1 0720 	rsb	r7, r1, #32
 8003960:	408b      	lsls	r3, r1
 8003962:	fa22 fc07 	lsr.w	ip, r2, r7
 8003966:	ea4c 0c03 	orr.w	ip, ip, r3
 800396a:	fa25 fa07 	lsr.w	sl, r5, r7
 800396e:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8003972:	fbba f8f9 	udiv	r8, sl, r9
 8003976:	fa20 f307 	lsr.w	r3, r0, r7
 800397a:	fb09 aa18 	mls	sl, r9, r8, sl
 800397e:	408d      	lsls	r5, r1
 8003980:	fa1f fe8c 	uxth.w	lr, ip
 8003984:	431d      	orrs	r5, r3
 8003986:	fa00 f301 	lsl.w	r3, r0, r1
 800398a:	fb08 f00e 	mul.w	r0, r8, lr
 800398e:	0c2c      	lsrs	r4, r5, #16
 8003990:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 8003994:	42a0      	cmp	r0, r4
 8003996:	fa02 f201 	lsl.w	r2, r2, r1
 800399a:	d90b      	bls.n	80039b4 <__udivmoddi4+0x1b8>
 800399c:	eb1c 0404 	adds.w	r4, ip, r4
 80039a0:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80039a4:	f080 8088 	bcs.w	8003ab8 <__udivmoddi4+0x2bc>
 80039a8:	42a0      	cmp	r0, r4
 80039aa:	f240 8085 	bls.w	8003ab8 <__udivmoddi4+0x2bc>
 80039ae:	f1a8 0802 	sub.w	r8, r8, #2
 80039b2:	4464      	add	r4, ip
 80039b4:	1a24      	subs	r4, r4, r0
 80039b6:	fbb4 f0f9 	udiv	r0, r4, r9
 80039ba:	fb09 4410 	mls	r4, r9, r0, r4
 80039be:	fb00 fe0e 	mul.w	lr, r0, lr
 80039c2:	b2ad      	uxth	r5, r5
 80039c4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 80039c8:	45a6      	cmp	lr, r4
 80039ca:	d908      	bls.n	80039de <__udivmoddi4+0x1e2>
 80039cc:	eb1c 0404 	adds.w	r4, ip, r4
 80039d0:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 80039d4:	d26c      	bcs.n	8003ab0 <__udivmoddi4+0x2b4>
 80039d6:	45a6      	cmp	lr, r4
 80039d8:	d96a      	bls.n	8003ab0 <__udivmoddi4+0x2b4>
 80039da:	3802      	subs	r0, #2
 80039dc:	4464      	add	r4, ip
 80039de:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80039e2:	fba0 9502 	umull	r9, r5, r0, r2
 80039e6:	eba4 040e 	sub.w	r4, r4, lr
 80039ea:	42ac      	cmp	r4, r5
 80039ec:	46c8      	mov	r8, r9
 80039ee:	46ae      	mov	lr, r5
 80039f0:	d356      	bcc.n	8003aa0 <__udivmoddi4+0x2a4>
 80039f2:	d053      	beq.n	8003a9c <__udivmoddi4+0x2a0>
 80039f4:	2e00      	cmp	r6, #0
 80039f6:	d069      	beq.n	8003acc <__udivmoddi4+0x2d0>
 80039f8:	ebb3 0208 	subs.w	r2, r3, r8
 80039fc:	eb64 040e 	sbc.w	r4, r4, lr
 8003a00:	fa22 f301 	lsr.w	r3, r2, r1
 8003a04:	fa04 f707 	lsl.w	r7, r4, r7
 8003a08:	431f      	orrs	r7, r3
 8003a0a:	40cc      	lsrs	r4, r1
 8003a0c:	e9c6 7400 	strd	r7, r4, [r6]
 8003a10:	2100      	movs	r1, #0
 8003a12:	e747      	b.n	80038a4 <__udivmoddi4+0xa8>
 8003a14:	fa0c fc02 	lsl.w	ip, ip, r2
 8003a18:	f1c2 0120 	rsb	r1, r2, #32
 8003a1c:	fa25 f301 	lsr.w	r3, r5, r1
 8003a20:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8003a24:	fa20 f101 	lsr.w	r1, r0, r1
 8003a28:	4095      	lsls	r5, r2
 8003a2a:	430d      	orrs	r5, r1
 8003a2c:	fbb3 f1f7 	udiv	r1, r3, r7
 8003a30:	fb07 3311 	mls	r3, r7, r1, r3
 8003a34:	fa1f fe8c 	uxth.w	lr, ip
 8003a38:	0c28      	lsrs	r0, r5, #16
 8003a3a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8003a3e:	fb01 f30e 	mul.w	r3, r1, lr
 8003a42:	4283      	cmp	r3, r0
 8003a44:	fa04 f402 	lsl.w	r4, r4, r2
 8003a48:	d908      	bls.n	8003a5c <__udivmoddi4+0x260>
 8003a4a:	eb1c 0000 	adds.w	r0, ip, r0
 8003a4e:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
 8003a52:	d22f      	bcs.n	8003ab4 <__udivmoddi4+0x2b8>
 8003a54:	4283      	cmp	r3, r0
 8003a56:	d92d      	bls.n	8003ab4 <__udivmoddi4+0x2b8>
 8003a58:	3902      	subs	r1, #2
 8003a5a:	4460      	add	r0, ip
 8003a5c:	1ac0      	subs	r0, r0, r3
 8003a5e:	fbb0 f3f7 	udiv	r3, r0, r7
 8003a62:	fb07 0013 	mls	r0, r7, r3, r0
 8003a66:	b2ad      	uxth	r5, r5
 8003a68:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 8003a6c:	fb03 f00e 	mul.w	r0, r3, lr
 8003a70:	42a8      	cmp	r0, r5
 8003a72:	d908      	bls.n	8003a86 <__udivmoddi4+0x28a>
 8003a74:	eb1c 0505 	adds.w	r5, ip, r5
 8003a78:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8003a7c:	d216      	bcs.n	8003aac <__udivmoddi4+0x2b0>
 8003a7e:	42a8      	cmp	r0, r5
 8003a80:	d914      	bls.n	8003aac <__udivmoddi4+0x2b0>
 8003a82:	3b02      	subs	r3, #2
 8003a84:	4465      	add	r5, ip
 8003a86:	1a28      	subs	r0, r5, r0
 8003a88:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003a8c:	e738      	b.n	8003900 <__udivmoddi4+0x104>
 8003a8e:	4631      	mov	r1, r6
 8003a90:	4630      	mov	r0, r6
 8003a92:	e707      	b.n	80038a4 <__udivmoddi4+0xa8>
 8003a94:	462f      	mov	r7, r5
 8003a96:	e6e4      	b.n	8003862 <__udivmoddi4+0x66>
 8003a98:	4618      	mov	r0, r3
 8003a9a:	e6f9      	b.n	8003890 <__udivmoddi4+0x94>
 8003a9c:	454b      	cmp	r3, r9
 8003a9e:	d2a9      	bcs.n	80039f4 <__udivmoddi4+0x1f8>
 8003aa0:	ebb9 0802 	subs.w	r8, r9, r2
 8003aa4:	eb65 0e0c 	sbc.w	lr, r5, ip
 8003aa8:	3801      	subs	r0, #1
 8003aaa:	e7a3      	b.n	80039f4 <__udivmoddi4+0x1f8>
 8003aac:	4643      	mov	r3, r8
 8003aae:	e7ea      	b.n	8003a86 <__udivmoddi4+0x28a>
 8003ab0:	4628      	mov	r0, r5
 8003ab2:	e794      	b.n	80039de <__udivmoddi4+0x1e2>
 8003ab4:	4641      	mov	r1, r8
 8003ab6:	e7d1      	b.n	8003a5c <__udivmoddi4+0x260>
 8003ab8:	46d0      	mov	r8, sl
 8003aba:	e77b      	b.n	80039b4 <__udivmoddi4+0x1b8>
 8003abc:	4464      	add	r4, ip
 8003abe:	3802      	subs	r0, #2
 8003ac0:	e747      	b.n	8003952 <__udivmoddi4+0x156>
 8003ac2:	3b02      	subs	r3, #2
 8003ac4:	4465      	add	r5, ip
 8003ac6:	e72f      	b.n	8003928 <__udivmoddi4+0x12c>
 8003ac8:	4608      	mov	r0, r1
 8003aca:	e706      	b.n	80038da <__udivmoddi4+0xde>
 8003acc:	4631      	mov	r1, r6
 8003ace:	e6e9      	b.n	80038a4 <__udivmoddi4+0xa8>

08003ad0 <__aeabi_idiv0>:
 8003ad0:	4770      	bx	lr
 8003ad2:	bf00      	nop

08003ad4 <memcpy>:
 8003ad4:	4684      	mov	ip, r0
 8003ad6:	ea41 0300 	orr.w	r3, r1, r0
 8003ada:	f013 0303 	ands.w	r3, r3, #3
 8003ade:	d149      	bne.n	8003b74 <memcpy+0xa0>
 8003ae0:	3a40      	subs	r2, #64	; 0x40
 8003ae2:	d323      	bcc.n	8003b2c <memcpy+0x58>
 8003ae4:	680b      	ldr	r3, [r1, #0]
 8003ae6:	6003      	str	r3, [r0, #0]
 8003ae8:	684b      	ldr	r3, [r1, #4]
 8003aea:	6043      	str	r3, [r0, #4]
 8003aec:	688b      	ldr	r3, [r1, #8]
 8003aee:	6083      	str	r3, [r0, #8]
 8003af0:	68cb      	ldr	r3, [r1, #12]
 8003af2:	60c3      	str	r3, [r0, #12]
 8003af4:	690b      	ldr	r3, [r1, #16]
 8003af6:	6103      	str	r3, [r0, #16]
 8003af8:	694b      	ldr	r3, [r1, #20]
 8003afa:	6143      	str	r3, [r0, #20]
 8003afc:	698b      	ldr	r3, [r1, #24]
 8003afe:	6183      	str	r3, [r0, #24]
 8003b00:	69cb      	ldr	r3, [r1, #28]
 8003b02:	61c3      	str	r3, [r0, #28]
 8003b04:	6a0b      	ldr	r3, [r1, #32]
 8003b06:	6203      	str	r3, [r0, #32]
 8003b08:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8003b0a:	6243      	str	r3, [r0, #36]	; 0x24
 8003b0c:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003b0e:	6283      	str	r3, [r0, #40]	; 0x28
 8003b10:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8003b12:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003b14:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8003b16:	6303      	str	r3, [r0, #48]	; 0x30
 8003b18:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8003b1a:	6343      	str	r3, [r0, #52]	; 0x34
 8003b1c:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8003b1e:	6383      	str	r3, [r0, #56]	; 0x38
 8003b20:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8003b22:	63c3      	str	r3, [r0, #60]	; 0x3c
 8003b24:	3040      	adds	r0, #64	; 0x40
 8003b26:	3140      	adds	r1, #64	; 0x40
 8003b28:	3a40      	subs	r2, #64	; 0x40
 8003b2a:	d2db      	bcs.n	8003ae4 <memcpy+0x10>
 8003b2c:	3230      	adds	r2, #48	; 0x30
 8003b2e:	d30b      	bcc.n	8003b48 <memcpy+0x74>
 8003b30:	680b      	ldr	r3, [r1, #0]
 8003b32:	6003      	str	r3, [r0, #0]
 8003b34:	684b      	ldr	r3, [r1, #4]
 8003b36:	6043      	str	r3, [r0, #4]
 8003b38:	688b      	ldr	r3, [r1, #8]
 8003b3a:	6083      	str	r3, [r0, #8]
 8003b3c:	68cb      	ldr	r3, [r1, #12]
 8003b3e:	60c3      	str	r3, [r0, #12]
 8003b40:	3010      	adds	r0, #16
 8003b42:	3110      	adds	r1, #16
 8003b44:	3a10      	subs	r2, #16
 8003b46:	d2f3      	bcs.n	8003b30 <memcpy+0x5c>
 8003b48:	320c      	adds	r2, #12
 8003b4a:	d305      	bcc.n	8003b58 <memcpy+0x84>
 8003b4c:	f851 3b04 	ldr.w	r3, [r1], #4
 8003b50:	f840 3b04 	str.w	r3, [r0], #4
 8003b54:	3a04      	subs	r2, #4
 8003b56:	d2f9      	bcs.n	8003b4c <memcpy+0x78>
 8003b58:	3204      	adds	r2, #4
 8003b5a:	d008      	beq.n	8003b6e <memcpy+0x9a>
 8003b5c:	07d2      	lsls	r2, r2, #31
 8003b5e:	bf1c      	itt	ne
 8003b60:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8003b64:	f800 3b01 	strbne.w	r3, [r0], #1
 8003b68:	d301      	bcc.n	8003b6e <memcpy+0x9a>
 8003b6a:	880b      	ldrh	r3, [r1, #0]
 8003b6c:	8003      	strh	r3, [r0, #0]
 8003b6e:	4660      	mov	r0, ip
 8003b70:	4770      	bx	lr
 8003b72:	bf00      	nop
 8003b74:	2a08      	cmp	r2, #8
 8003b76:	d313      	bcc.n	8003ba0 <memcpy+0xcc>
 8003b78:	078b      	lsls	r3, r1, #30
 8003b7a:	d0b1      	beq.n	8003ae0 <memcpy+0xc>
 8003b7c:	f010 0303 	ands.w	r3, r0, #3
 8003b80:	d0ae      	beq.n	8003ae0 <memcpy+0xc>
 8003b82:	f1c3 0304 	rsb	r3, r3, #4
 8003b86:	1ad2      	subs	r2, r2, r3
 8003b88:	07db      	lsls	r3, r3, #31
 8003b8a:	bf1c      	itt	ne
 8003b8c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8003b90:	f800 3b01 	strbne.w	r3, [r0], #1
 8003b94:	d3a4      	bcc.n	8003ae0 <memcpy+0xc>
 8003b96:	f831 3b02 	ldrh.w	r3, [r1], #2
 8003b9a:	f820 3b02 	strh.w	r3, [r0], #2
 8003b9e:	e79f      	b.n	8003ae0 <memcpy+0xc>
 8003ba0:	3a04      	subs	r2, #4
 8003ba2:	d3d9      	bcc.n	8003b58 <memcpy+0x84>
 8003ba4:	3a01      	subs	r2, #1
 8003ba6:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003baa:	f800 3b01 	strb.w	r3, [r0], #1
 8003bae:	d2f9      	bcs.n	8003ba4 <memcpy+0xd0>
 8003bb0:	780b      	ldrb	r3, [r1, #0]
 8003bb2:	7003      	strb	r3, [r0, #0]
 8003bb4:	784b      	ldrb	r3, [r1, #1]
 8003bb6:	7043      	strb	r3, [r0, #1]
 8003bb8:	788b      	ldrb	r3, [r1, #2]
 8003bba:	7083      	strb	r3, [r0, #2]
 8003bbc:	4660      	mov	r0, ip
 8003bbe:	4770      	bx	lr

08003bc0 <strcmp>:
 8003bc0:	ea80 0c01 	eor.w	ip, r0, r1
 8003bc4:	f01c 0f03 	tst.w	ip, #3
 8003bc8:	d137      	bne.n	8003c3a <strcmp+0x7a>
 8003bca:	f010 0c03 	ands.w	ip, r0, #3
 8003bce:	f020 0003 	bic.w	r0, r0, #3
 8003bd2:	f021 0103 	bic.w	r1, r1, #3
 8003bd6:	f850 2b04 	ldr.w	r2, [r0], #4
 8003bda:	bf08      	it	eq
 8003bdc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003be0:	d00e      	beq.n	8003c00 <strcmp+0x40>
 8003be2:	f08c 0c03 	eor.w	ip, ip, #3
 8003be6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8003bea:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8003bee:	fa23 fc0c 	lsr.w	ip, r3, ip
 8003bf2:	f851 3b04 	ldr.w	r3, [r1], #4
 8003bf6:	ea42 020c 	orr.w	r2, r2, ip
 8003bfa:	ea43 030c 	orr.w	r3, r3, ip
 8003bfe:	bf00      	nop
 8003c00:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003c04:	429a      	cmp	r2, r3
 8003c06:	bf01      	itttt	eq
 8003c08:	ea2c 0c02 	biceq.w	ip, ip, r2
 8003c0c:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8003c10:	f850 2b04 	ldreq.w	r2, [r0], #4
 8003c14:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003c18:	d0f2      	beq.n	8003c00 <strcmp+0x40>
 8003c1a:	ea4f 6002 	mov.w	r0, r2, lsl #24
 8003c1e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8003c22:	2801      	cmp	r0, #1
 8003c24:	bf28      	it	cs
 8003c26:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8003c2a:	bf08      	it	eq
 8003c2c:	0a1b      	lsreq	r3, r3, #8
 8003c2e:	d0f4      	beq.n	8003c1a <strcmp+0x5a>
 8003c30:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8003c34:	0e00      	lsrs	r0, r0, #24
 8003c36:	1ac0      	subs	r0, r0, r3
 8003c38:	4770      	bx	lr
 8003c3a:	f010 0f03 	tst.w	r0, #3
 8003c3e:	d00a      	beq.n	8003c56 <strcmp+0x96>
 8003c40:	f810 2b01 	ldrb.w	r2, [r0], #1
 8003c44:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003c48:	2a01      	cmp	r2, #1
 8003c4a:	bf28      	it	cs
 8003c4c:	429a      	cmpcs	r2, r3
 8003c4e:	d0f4      	beq.n	8003c3a <strcmp+0x7a>
 8003c50:	eba2 0003 	sub.w	r0, r2, r3
 8003c54:	4770      	bx	lr
 8003c56:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8003c5a:	f850 2b04 	ldr.w	r2, [r0], #4
 8003c5e:	f001 0503 	and.w	r5, r1, #3
 8003c62:	f021 0103 	bic.w	r1, r1, #3
 8003c66:	f851 3b04 	ldr.w	r3, [r1], #4
 8003c6a:	2d02      	cmp	r5, #2
 8003c6c:	d026      	beq.n	8003cbc <strcmp+0xfc>
 8003c6e:	d84d      	bhi.n	8003d0c <strcmp+0x14c>
 8003c70:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 8003c74:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 8003c78:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003c7c:	ea2c 0c02 	bic.w	ip, ip, r2
 8003c80:	d10d      	bne.n	8003c9e <strcmp+0xde>
 8003c82:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003c86:	bf08      	it	eq
 8003c88:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003c8c:	d10a      	bne.n	8003ca4 <strcmp+0xe4>
 8003c8e:	ea85 0502 	eor.w	r5, r5, r2
 8003c92:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 8003c96:	d10c      	bne.n	8003cb2 <strcmp+0xf2>
 8003c98:	f850 2b04 	ldr.w	r2, [r0], #4
 8003c9c:	e7e8      	b.n	8003c70 <strcmp+0xb0>
 8003c9e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8003ca2:	e05b      	b.n	8003d5c <strcmp+0x19c>
 8003ca4:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 8003ca8:	d154      	bne.n	8003d54 <strcmp+0x194>
 8003caa:	780b      	ldrb	r3, [r1, #0]
 8003cac:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8003cb0:	e054      	b.n	8003d5c <strcmp+0x19c>
 8003cb2:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8003cb6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8003cba:	e04f      	b.n	8003d5c <strcmp+0x19c>
 8003cbc:	ea4f 4502 	mov.w	r5, r2, lsl #16
 8003cc0:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003cc4:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8003cc8:	ea2c 0c02 	bic.w	ip, ip, r2
 8003ccc:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8003cd0:	d118      	bne.n	8003d04 <strcmp+0x144>
 8003cd2:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003cd6:	bf08      	it	eq
 8003cd8:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003cdc:	d107      	bne.n	8003cee <strcmp+0x12e>
 8003cde:	ea85 0502 	eor.w	r5, r5, r2
 8003ce2:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 8003ce6:	d109      	bne.n	8003cfc <strcmp+0x13c>
 8003ce8:	f850 2b04 	ldr.w	r2, [r0], #4
 8003cec:	e7e6      	b.n	8003cbc <strcmp+0xfc>
 8003cee:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 8003cf2:	d12f      	bne.n	8003d54 <strcmp+0x194>
 8003cf4:	880b      	ldrh	r3, [r1, #0]
 8003cf6:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8003cfa:	e02f      	b.n	8003d5c <strcmp+0x19c>
 8003cfc:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8003d00:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8003d04:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8003d08:	e028      	b.n	8003d5c <strcmp+0x19c>
 8003d0a:	bf00      	nop
 8003d0c:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8003d10:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 8003d14:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003d18:	ea2c 0c02 	bic.w	ip, ip, r2
 8003d1c:	d10d      	bne.n	8003d3a <strcmp+0x17a>
 8003d1e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003d22:	bf08      	it	eq
 8003d24:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003d28:	d10a      	bne.n	8003d40 <strcmp+0x180>
 8003d2a:	ea85 0502 	eor.w	r5, r5, r2
 8003d2e:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 8003d32:	d10a      	bne.n	8003d4a <strcmp+0x18a>
 8003d34:	f850 2b04 	ldr.w	r2, [r0], #4
 8003d38:	e7e8      	b.n	8003d0c <strcmp+0x14c>
 8003d3a:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8003d3e:	e00d      	b.n	8003d5c <strcmp+0x19c>
 8003d40:	f012 0fff 	tst.w	r2, #255	; 0xff
 8003d44:	d006      	beq.n	8003d54 <strcmp+0x194>
 8003d46:	f851 3b04 	ldr.w	r3, [r1], #4
 8003d4a:	ea4f 2512 	mov.w	r5, r2, lsr #8
 8003d4e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003d52:	e003      	b.n	8003d5c <strcmp+0x19c>
 8003d54:	f04f 0000 	mov.w	r0, #0
 8003d58:	bc20      	pop	{r5}
 8003d5a:	4770      	bx	lr
 8003d5c:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 8003d60:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8003d64:	2801      	cmp	r0, #1
 8003d66:	bf28      	it	cs
 8003d68:	4290      	cmpcs	r0, r2
 8003d6a:	bf04      	itt	eq
 8003d6c:	0a2d      	lsreq	r5, r5, #8
 8003d6e:	0a1b      	lsreq	r3, r3, #8
 8003d70:	d0f4      	beq.n	8003d5c <strcmp+0x19c>
 8003d72:	eba2 0000 	sub.w	r0, r2, r0
 8003d76:	bc20      	pop	{r5}
 8003d78:	4770      	bx	lr
 8003d7a:	bf00      	nop

08003d7c <Vector6C.part.0>:
extern UBaseType_t uxSavedInterruptStatus;

static inline void osalOsRescheduleS(void)
{
    osalDbgCheckClassS();
    if(uxYieldPending()) taskYIELD();
 8003d7c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003d80:	4a0d      	ldr	r2, [pc, #52]	; (8003db8 <Vector6C.part.0+0x3c>)
 8003d82:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003d86:	6011      	str	r1, [r2, #0]
 8003d88:	4a0c      	ldr	r2, [pc, #48]	; (8003dbc <Vector6C.part.0+0x40>)
 8003d8a:	6812      	ldr	r2, [r2, #0]
 8003d8c:	b14a      	cbz	r2, 8003da2 <Vector6C.part.0+0x26>
 8003d8e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003d92:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003d96:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003d9a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003d9e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003da2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003da6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003daa:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003dae:	f3bf 8f4f 	dsb	sy
 8003db2:	f3bf 8f6f 	isb	sy
}
 8003db6:	4770      	bx	lr
 8003db8:	2000134c 	.word	0x2000134c
 8003dbc:	20001358 	.word	0x20001358

08003dc0 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003dc0:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
bool sduRequestsHook(USBDriver *usbp) {
 8003dc4:	4603      	mov	r3, r0
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003dc6:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8003dca:	2a20      	cmp	r2, #32
 8003dcc:	d114      	bne.n	8003df8 <sduRequestsHook+0x38>
    switch (usbp->setup[1]) {
 8003dce:	f890 2075 	ldrb.w	r2, [r0, #117]	; 0x75
 8003dd2:	2000      	movs	r0, #0
 8003dd4:	2a21      	cmp	r2, #33	; 0x21
 8003dd6:	d802      	bhi.n	8003dde <sduRequestsHook+0x1e>
 8003dd8:	2a1f      	cmp	r2, #31
 8003dda:	d803      	bhi.n	8003de4 <sduRequestsHook+0x24>
 8003ddc:	4770      	bx	lr
 8003dde:	2a22      	cmp	r2, #34	; 0x22
 8003de0:	d007      	beq.n	8003df2 <sduRequestsHook+0x32>
 8003de2:	4770      	bx	lr
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8003de4:	4a05      	ldr	r2, [pc, #20]	; (8003dfc <sduRequestsHook+0x3c>)
 8003de6:	669a      	str	r2, [r3, #104]	; 0x68
 8003de8:	2207      	movs	r2, #7
 8003dea:	66da      	str	r2, [r3, #108]	; 0x6c
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003dec:	6718      	str	r0, [r3, #112]	; 0x70
      return true;
 8003dee:	2001      	movs	r0, #1
 8003df0:	4770      	bx	lr
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003df2:	e9c3 001a 	strd	r0, r0, [r3, #104]	; 0x68
 8003df6:	e7f9      	b.n	8003dec <sduRequestsHook+0x2c>
    default:
      return false;
    }
  }
  return false;
 8003df8:	2000      	movs	r0, #0
}
 8003dfa:	4770      	bx	lr
 8003dfc:	20000850 	.word	0x20000850

08003e00 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8003e00:	4770      	bx	lr
	...

08003e04 <set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 8003e04:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8003e08:	4a07      	ldr	r2, [pc, #28]	; (8003e28 <set_address+0x24>)
 8003e0a:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
 8003e0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
static void set_address(USBDriver *usbp) {
 8003e12:	b510      	push	{r4, lr}
 8003e14:	64d3      	str	r3, [r2, #76]	; 0x4c
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003e16:	6843      	ldr	r3, [r0, #4]
static void set_address(USBDriver *usbp) {
 8003e18:	4604      	mov	r4, r0
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003e1a:	681b      	ldr	r3, [r3, #0]
 8003e1c:	b10b      	cbz	r3, 8003e22 <set_address+0x1e>
 8003e1e:	2101      	movs	r1, #1
 8003e20:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8003e22:	2303      	movs	r3, #3
 8003e24:	7023      	strb	r3, [r4, #0]
}
 8003e26:	bd10      	pop	{r4, pc}
 8003e28:	40005c00 	.word	0x40005c00

08003e2c <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8003e2c:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8003e2e:	4b0b      	ldr	r3, [pc, #44]	; (8003e5c <Vector6C+0x30>)
 8003e30:	6819      	ldr	r1, [r3, #0]
 8003e32:	689a      	ldr	r2, [r3, #8]
 8003e34:	f001 010e 	and.w	r1, r1, #14
 8003e38:	420a      	tst	r2, r1
 8003e3a:	d005      	beq.n	8003e48 <Vector6C+0x1c>
 8003e3c:	4a08      	ldr	r2, [pc, #32]	; (8003e60 <Vector6C+0x34>)
 8003e3e:	6059      	str	r1, [r3, #4]
 8003e40:	6813      	ldr	r3, [r2, #0]
 8003e42:	b10b      	cbz	r3, 8003e48 <Vector6C+0x1c>
 8003e44:	6850      	ldr	r0, [r2, #4]
 8003e46:	4798      	blx	r3
UBaseType_t uxYieldPending( void )
{
    UBaseType_t isIt = xYieldPending;
    xYieldPending = pdFALSE;
 8003e48:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003e4a:	4b06      	ldr	r3, [pc, #24]	; (8003e64 <Vector6C+0x38>)
 8003e4c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003e4e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003e50:	b11a      	cbz	r2, 8003e5a <Vector6C+0x2e>
}
 8003e52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8003e56:	f7ff bf91 	b.w	8003d7c <Vector6C.part.0>
 8003e5a:	bd08      	pop	{r3, pc}
 8003e5c:	40020000 	.word	0x40020000
 8003e60:	20000fe8 	.word	0x20000fe8
 8003e64:	2000164c 	.word	0x2000164c

08003e68 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003e68:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8003e6a:	4b19      	ldr	r3, [pc, #100]	; (8003ed0 <Vector70+0x68>)
 8003e6c:	6819      	ldr	r1, [r3, #0]
 8003e6e:	69da      	ldr	r2, [r3, #28]
 8003e70:	0909      	lsrs	r1, r1, #4
 8003e72:	f001 010e 	and.w	r1, r1, #14
 8003e76:	420a      	tst	r2, r1
 8003e78:	d006      	beq.n	8003e88 <Vector70+0x20>
 8003e7a:	010a      	lsls	r2, r1, #4
 8003e7c:	605a      	str	r2, [r3, #4]
 8003e7e:	4a15      	ldr	r2, [pc, #84]	; (8003ed4 <Vector70+0x6c>)
 8003e80:	6893      	ldr	r3, [r2, #8]
 8003e82:	b10b      	cbz	r3, 8003e88 <Vector70+0x20>
 8003e84:	68d0      	ldr	r0, [r2, #12]
 8003e86:	4798      	blx	r3
 8003e88:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003e8a:	4b13      	ldr	r3, [pc, #76]	; (8003ed8 <Vector70+0x70>)
 8003e8c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003e8e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003e90:	b1e2      	cbz	r2, 8003ecc <Vector70+0x64>
 8003e92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003e96:	4a11      	ldr	r2, [pc, #68]	; (8003edc <Vector70+0x74>)
 8003e98:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003e9c:	6011      	str	r1, [r2, #0]
 8003e9e:	4a10      	ldr	r2, [pc, #64]	; (8003ee0 <Vector70+0x78>)
 8003ea0:	6812      	ldr	r2, [r2, #0]
 8003ea2:	b14a      	cbz	r2, 8003eb8 <Vector70+0x50>
 8003ea4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003ea8:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003eac:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003eb0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003eb4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003eb8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003ebc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003ec0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003ec4:	f3bf 8f4f 	dsb	sy
 8003ec8:	f3bf 8f6f 	isb	sy
}
 8003ecc:	bd08      	pop	{r3, pc}
 8003ece:	bf00      	nop
 8003ed0:	40020000 	.word	0x40020000
 8003ed4:	20000fe8 	.word	0x20000fe8
 8003ed8:	2000164c 	.word	0x2000164c
 8003edc:	2000134c 	.word	0x2000134c
 8003ee0:	20001358 	.word	0x20001358

08003ee4 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8003ee4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8003ee6:	4b19      	ldr	r3, [pc, #100]	; (8003f4c <Vector74+0x68>)
 8003ee8:	6819      	ldr	r1, [r3, #0]
 8003eea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003eec:	0a09      	lsrs	r1, r1, #8
 8003eee:	f001 010e 	and.w	r1, r1, #14
 8003ef2:	420a      	tst	r2, r1
 8003ef4:	d006      	beq.n	8003f04 <Vector74+0x20>
 8003ef6:	020a      	lsls	r2, r1, #8
 8003ef8:	605a      	str	r2, [r3, #4]
 8003efa:	4a15      	ldr	r2, [pc, #84]	; (8003f50 <Vector74+0x6c>)
 8003efc:	6913      	ldr	r3, [r2, #16]
 8003efe:	b10b      	cbz	r3, 8003f04 <Vector74+0x20>
 8003f00:	6950      	ldr	r0, [r2, #20]
 8003f02:	4798      	blx	r3
 8003f04:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003f06:	4b13      	ldr	r3, [pc, #76]	; (8003f54 <Vector74+0x70>)
 8003f08:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003f0a:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003f0c:	b1e2      	cbz	r2, 8003f48 <Vector74+0x64>
 8003f0e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f12:	4a11      	ldr	r2, [pc, #68]	; (8003f58 <Vector74+0x74>)
 8003f14:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003f18:	6011      	str	r1, [r2, #0]
 8003f1a:	4a10      	ldr	r2, [pc, #64]	; (8003f5c <Vector74+0x78>)
 8003f1c:	6812      	ldr	r2, [r2, #0]
 8003f1e:	b14a      	cbz	r2, 8003f34 <Vector74+0x50>
 8003f20:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003f24:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003f28:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003f2c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003f30:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003f34:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f38:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003f3c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003f40:	f3bf 8f4f 	dsb	sy
 8003f44:	f3bf 8f6f 	isb	sy
}
 8003f48:	bd08      	pop	{r3, pc}
 8003f4a:	bf00      	nop
 8003f4c:	40020000 	.word	0x40020000
 8003f50:	20000fe8 	.word	0x20000fe8
 8003f54:	2000164c 	.word	0x2000164c
 8003f58:	2000134c 	.word	0x2000134c
 8003f5c:	20001358 	.word	0x20001358

08003f60 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8003f60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8003f62:	4b19      	ldr	r3, [pc, #100]	; (8003fc8 <Vector78+0x68>)
 8003f64:	6819      	ldr	r1, [r3, #0]
 8003f66:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003f68:	0b09      	lsrs	r1, r1, #12
 8003f6a:	f001 010e 	and.w	r1, r1, #14
 8003f6e:	420a      	tst	r2, r1
 8003f70:	d006      	beq.n	8003f80 <Vector78+0x20>
 8003f72:	030a      	lsls	r2, r1, #12
 8003f74:	605a      	str	r2, [r3, #4]
 8003f76:	4a15      	ldr	r2, [pc, #84]	; (8003fcc <Vector78+0x6c>)
 8003f78:	6993      	ldr	r3, [r2, #24]
 8003f7a:	b10b      	cbz	r3, 8003f80 <Vector78+0x20>
 8003f7c:	69d0      	ldr	r0, [r2, #28]
 8003f7e:	4798      	blx	r3
 8003f80:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003f82:	4b13      	ldr	r3, [pc, #76]	; (8003fd0 <Vector78+0x70>)
 8003f84:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003f86:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003f88:	b1e2      	cbz	r2, 8003fc4 <Vector78+0x64>
 8003f8a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f8e:	4a11      	ldr	r2, [pc, #68]	; (8003fd4 <Vector78+0x74>)
 8003f90:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003f94:	6011      	str	r1, [r2, #0]
 8003f96:	4a10      	ldr	r2, [pc, #64]	; (8003fd8 <Vector78+0x78>)
 8003f98:	6812      	ldr	r2, [r2, #0]
 8003f9a:	b14a      	cbz	r2, 8003fb0 <Vector78+0x50>
 8003f9c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003fa0:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003fa4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003fa8:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003fac:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003fb0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003fb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003fb8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003fbc:	f3bf 8f4f 	dsb	sy
 8003fc0:	f3bf 8f6f 	isb	sy
}
 8003fc4:	bd08      	pop	{r3, pc}
 8003fc6:	bf00      	nop
 8003fc8:	40020000 	.word	0x40020000
 8003fcc:	20000fe8 	.word	0x20000fe8
 8003fd0:	2000164c 	.word	0x2000164c
 8003fd4:	2000134c 	.word	0x2000134c
 8003fd8:	20001358 	.word	0x20001358

08003fdc <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8003fdc:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8003fde:	4b19      	ldr	r3, [pc, #100]	; (8004044 <Vector7C+0x68>)
 8003fe0:	6819      	ldr	r1, [r3, #0]
 8003fe2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003fe4:	0c09      	lsrs	r1, r1, #16
 8003fe6:	f001 010e 	and.w	r1, r1, #14
 8003fea:	420a      	tst	r2, r1
 8003fec:	d006      	beq.n	8003ffc <Vector7C+0x20>
 8003fee:	040a      	lsls	r2, r1, #16
 8003ff0:	605a      	str	r2, [r3, #4]
 8003ff2:	4a15      	ldr	r2, [pc, #84]	; (8004048 <Vector7C+0x6c>)
 8003ff4:	6a13      	ldr	r3, [r2, #32]
 8003ff6:	b10b      	cbz	r3, 8003ffc <Vector7C+0x20>
 8003ff8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8003ffa:	4798      	blx	r3
 8003ffc:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003ffe:	4b13      	ldr	r3, [pc, #76]	; (800404c <Vector7C+0x70>)
 8004000:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8004002:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8004004:	b1e2      	cbz	r2, 8004040 <Vector7C+0x64>
 8004006:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800400a:	4a11      	ldr	r2, [pc, #68]	; (8004050 <Vector7C+0x74>)
 800400c:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004010:	6011      	str	r1, [r2, #0]
 8004012:	4a10      	ldr	r2, [pc, #64]	; (8004054 <Vector7C+0x78>)
 8004014:	6812      	ldr	r2, [r2, #0]
 8004016:	b14a      	cbz	r2, 800402c <Vector7C+0x50>
 8004018:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800401c:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004020:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004024:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004028:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800402c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004030:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004034:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004038:	f3bf 8f4f 	dsb	sy
 800403c:	f3bf 8f6f 	isb	sy
}
 8004040:	bd08      	pop	{r3, pc}
 8004042:	bf00      	nop
 8004044:	40020000 	.word	0x40020000
 8004048:	20000fe8 	.word	0x20000fe8
 800404c:	2000164c 	.word	0x2000164c
 8004050:	2000134c 	.word	0x2000134c
 8004054:	20001358 	.word	0x20001358

08004058 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8004058:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800405a:	4b19      	ldr	r3, [pc, #100]	; (80040c0 <Vector80+0x68>)
 800405c:	6819      	ldr	r1, [r3, #0]
 800405e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8004060:	0d09      	lsrs	r1, r1, #20
 8004062:	f001 010e 	and.w	r1, r1, #14
 8004066:	420a      	tst	r2, r1
 8004068:	d006      	beq.n	8004078 <Vector80+0x20>
 800406a:	050a      	lsls	r2, r1, #20
 800406c:	605a      	str	r2, [r3, #4]
 800406e:	4a15      	ldr	r2, [pc, #84]	; (80040c4 <Vector80+0x6c>)
 8004070:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8004072:	b10b      	cbz	r3, 8004078 <Vector80+0x20>
 8004074:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8004076:	4798      	blx	r3
 8004078:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 800407a:	4b13      	ldr	r3, [pc, #76]	; (80040c8 <Vector80+0x70>)
 800407c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 800407e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8004080:	b1e2      	cbz	r2, 80040bc <Vector80+0x64>
 8004082:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004086:	4a11      	ldr	r2, [pc, #68]	; (80040cc <Vector80+0x74>)
 8004088:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800408c:	6011      	str	r1, [r2, #0]
 800408e:	4a10      	ldr	r2, [pc, #64]	; (80040d0 <Vector80+0x78>)
 8004090:	6812      	ldr	r2, [r2, #0]
 8004092:	b14a      	cbz	r2, 80040a8 <Vector80+0x50>
 8004094:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004098:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800409c:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80040a0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80040a4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80040a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80040ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80040b0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80040b4:	f3bf 8f4f 	dsb	sy
 80040b8:	f3bf 8f6f 	isb	sy
}
 80040bc:	bd08      	pop	{r3, pc}
 80040be:	bf00      	nop
 80040c0:	40020000 	.word	0x40020000
 80040c4:	20000fe8 	.word	0x20000fe8
 80040c8:	2000164c 	.word	0x2000164c
 80040cc:	2000134c 	.word	0x2000134c
 80040d0:	20001358 	.word	0x20001358

080040d4 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80040d4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80040d6:	4b19      	ldr	r3, [pc, #100]	; (800413c <Vector84+0x68>)
 80040d8:	6819      	ldr	r1, [r3, #0]
 80040da:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80040de:	0e09      	lsrs	r1, r1, #24
 80040e0:	f001 010e 	and.w	r1, r1, #14
 80040e4:	420a      	tst	r2, r1
 80040e6:	d006      	beq.n	80040f6 <Vector84+0x22>
 80040e8:	060a      	lsls	r2, r1, #24
 80040ea:	605a      	str	r2, [r3, #4]
 80040ec:	4a14      	ldr	r2, [pc, #80]	; (8004140 <Vector84+0x6c>)
 80040ee:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80040f0:	b10b      	cbz	r3, 80040f6 <Vector84+0x22>
 80040f2:	6b50      	ldr	r0, [r2, #52]	; 0x34
 80040f4:	4798      	blx	r3
 80040f6:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 80040f8:	4b12      	ldr	r3, [pc, #72]	; (8004144 <Vector84+0x70>)
 80040fa:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 80040fc:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 80040fe:	b1e2      	cbz	r2, 800413a <Vector84+0x66>
 8004100:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004104:	4a10      	ldr	r2, [pc, #64]	; (8004148 <Vector84+0x74>)
 8004106:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800410a:	6011      	str	r1, [r2, #0]
 800410c:	4a0f      	ldr	r2, [pc, #60]	; (800414c <Vector84+0x78>)
 800410e:	6812      	ldr	r2, [r2, #0]
 8004110:	b14a      	cbz	r2, 8004126 <Vector84+0x52>
 8004112:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004116:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800411a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800411e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004122:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004126:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800412a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800412e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004132:	f3bf 8f4f 	dsb	sy
 8004136:	f3bf 8f6f 	isb	sy
}
 800413a:	bd08      	pop	{r3, pc}
 800413c:	40020000 	.word	0x40020000
 8004140:	20000fe8 	.word	0x20000fe8
 8004144:	2000164c 	.word	0x2000164c
 8004148:	2000134c 	.word	0x2000134c
 800414c:	20001358 	.word	0x20001358

08004150 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8004150:	4a02      	ldr	r2, [pc, #8]	; (800415c <notify3+0xc>)
 8004152:	68d3      	ldr	r3, [r2, #12]
 8004154:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004158:	60d3      	str	r3, [r2, #12]
}
 800415a:	4770      	bx	lr
 800415c:	40004800 	.word	0x40004800

08004160 <usb_packet_write_from_buffer>:
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8004160:	4b0d      	ldr	r3, [pc, #52]	; (8004198 <usb_packet_write_from_buffer+0x38>)
                                         size_t n) {
 8004162:	b510      	push	{r4, lr}
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8004164:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004166:	0104      	lsls	r4, r0, #4
 8004168:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800416c:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8004170:	eb03 1000 	add.w	r0, r3, r0, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8004174:	58e3      	ldr	r3, [r4, r3]
 8004176:	4411      	add	r1, r2
 8004178:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800417c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8004180:	005b      	lsls	r3, r3, #1
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8004182:	6042      	str	r2, [r0, #4]
  while (i > 0) {
 8004184:	2a00      	cmp	r2, #0
 8004186:	eba1 0002 	sub.w	r0, r1, r2
 800418a:	dc00      	bgt.n	800418e <usb_packet_write_from_buffer+0x2e>
}
 800418c:	bd10      	pop	{r4, pc}
    w |= *buf++ << 8;
 800418e:	8800      	ldrh	r0, [r0, #0]
    i -= 2;
 8004190:	3a02      	subs	r2, #2
    w |= *buf++ << 8;
 8004192:	f843 0b04 	str.w	r0, [r3], #4
    i -= 2;
 8004196:	e7f5      	b.n	8004184 <usb_packet_write_from_buffer+0x24>
 8004198:	40005c00 	.word	0x40005c00

0800419c <_put.lto_priv.2>:
}

static msg_t _put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 800419c:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
 80041a0:	429a      	cmp	r2, r3
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 80041a2:	bf1f      	itttt	ne
 80041a4:	6842      	ldrne	r2, [r0, #4]
 80041a6:	54d1      	strbne	r1, [r2, r3]
  msp->eos += 1;
 80041a8:	68c3      	ldrne	r3, [r0, #12]
 80041aa:	3301      	addne	r3, #1
 80041ac:	bf1a      	itte	ne
 80041ae:	60c3      	strne	r3, [r0, #12]
  return MSG_OK;
 80041b0:	2000      	movne	r0, #0
    return MSG_RESET;
 80041b2:	f06f 0001 	mvneq.w	r0, #1
}
 80041b6:	4770      	bx	lr

080041b8 <_get.lto_priv.2>:

static msg_t _get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 80041b8:	e9d0 2303 	ldrd	r2, r3, [r0, #12]
 80041bc:	429a      	cmp	r2, r3
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 80041be:	bf1f      	itttt	ne
 80041c0:	6842      	ldrne	r2, [r0, #4]
 80041c2:	5cd2      	ldrbne	r2, [r2, r3]
  msp->offset += 1;
 80041c4:	3301      	addne	r3, #1
 80041c6:	6103      	strne	r3, [r0, #16]
  return b;
 80041c8:	bf14      	ite	ne
 80041ca:	4610      	movne	r0, r2
    return MSG_RESET;
 80041cc:	f06f 0001 	mvneq.w	r0, #1
}
 80041d0:	4770      	bx	lr

080041d2 <strToInt>:

    return (result>=base)? -1 : result;
}

int32_t strToInt(char* string, uint8_t base)
{
 80041d2:	b570      	push	{r4, r5, r6, lr}
    uint32_t value = 0;
    bool invert = false;
    unsigned int i = 0;

    if(string[0] == '\0') {
 80041d4:	7803      	ldrb	r3, [r0, #0]
 80041d6:	b1e3      	cbz	r3, 8004212 <strToInt+0x40>
        return -1;
    }

    if(string[0] == '-') {
 80041d8:	2b2d      	cmp	r3, #45	; 0x2d
 80041da:	d127      	bne.n	800422c <strToInt+0x5a>
        invert = true;
        i++;
 80041dc:	2201      	movs	r2, #1
    bool invert = false;
 80041de:	4614      	mov	r4, r2
 80041e0:	4402      	add	r2, r0
        invert = true;
 80041e2:	2000      	movs	r0, #0
 80041e4:	e01b      	b.n	800421e <strToInt+0x4c>
    }

    for(; string[i]; i++) {
        value *= base;
 80041e6:	fb00 f501 	mul.w	r5, r0, r1
    if(input >= '0' && input <= '9') {
 80041ea:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80041ee:	b2c0      	uxtb	r0, r0
    input &=~ 0x20;
 80041f0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    if(input >= '0' && input <= '9') {
 80041f4:	2809      	cmp	r0, #9
    if(input >= 'A' && input <= 'Z') {
 80041f6:	f1a3 0641 	sub.w	r6, r3, #65	; 0x41
    int8_t result = -1;
 80041fa:	bf8c      	ite	hi
 80041fc:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
        result = input - '0';
 8004200:	b240      	sxtbls	r0, r0
    if(input >= 'A' && input <= 'Z') {
 8004202:	2e19      	cmp	r6, #25
 8004204:	d808      	bhi.n	8004218 <strToInt+0x46>
        result = input - 'A' + 10;
 8004206:	f1a3 0037 	sub.w	r0, r3, #55	; 0x37
 800420a:	b2c3      	uxtb	r3, r0
    if(result >= base) {
 800420c:	4299      	cmp	r1, r3
        result = input - 'A' + 10;
 800420e:	b240      	sxtb	r0, r0
    if(result >= base) {
 8004210:	d804      	bhi.n	800421c <strToInt+0x4a>
        return -1;
 8004212:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004216:	e008      	b.n	800422a <strToInt+0x58>

        int8_t ci = charToInt(string[i], base);
        if(ci < 0) {
 8004218:	1c43      	adds	r3, r0, #1
 800421a:	d006      	beq.n	800422a <strToInt+0x58>
            return -1;
        }

        value += ci;
 800421c:	4428      	add	r0, r5
    for(; string[i]; i++) {
 800421e:	f812 3b01 	ldrb.w	r3, [r2], #1
 8004222:	2b00      	cmp	r3, #0
 8004224:	d1df      	bne.n	80041e6 <strToInt+0x14>
    }

    return (invert)? -value : value;
 8004226:	b104      	cbz	r4, 800422a <strToInt+0x58>
 8004228:	4240      	negs	r0, r0
}
 800422a:	bd70      	pop	{r4, r5, r6, pc}
    unsigned int i = 0;
 800422c:	2200      	movs	r2, #0
 800422e:	e7d6      	b.n	80041de <strToInt+0xc>

08004230 <NVIC_SystemReset.lto_priv.0>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8004230:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004234:	4905      	ldr	r1, [pc, #20]	; (800424c <NVIC_SystemReset.lto_priv.0+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8004236:	4b06      	ldr	r3, [pc, #24]	; (8004250 <NVIC_SystemReset.lto_priv.0+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004238:	68ca      	ldr	r2, [r1, #12]
 800423a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800423e:	4313      	orrs	r3, r2
 8004240:	60cb      	str	r3, [r1, #12]
 8004242:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8004246:	bf00      	nop
 8004248:	e7fd      	b.n	8004246 <NVIC_SystemReset.lto_priv.0+0x16>
 800424a:	bf00      	nop
 800424c:	e000ed00 	.word	0xe000ed00
 8004250:	05fa0004 	.word	0x05fa0004

08004254 <shellCommandRegister>:
    {"license", cmdLicense, NULL},
    {"sanity", cmdSanity, NULL},
};

void shellCommandRegister(char* name, shellcmd_t function, void* user)
{
 8004254:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* -1 since there should be a final line with NULL, NULL, NULL */
    if(shellCommandsIndex >= sizeof(shellCommands)/sizeof(ShellCommand)-1) {
 8004256:	4d07      	ldr	r5, [pc, #28]	; (8004274 <shellCommandRegister+0x20>)
 8004258:	782b      	ldrb	r3, [r5, #0]
 800425a:	2b0d      	cmp	r3, #13
 800425c:	d808      	bhi.n	8004270 <shellCommandRegister+0x1c>
        return;
    }
    shellCommands[shellCommandsIndex].sc_name = name;
 800425e:	240c      	movs	r4, #12
 8004260:	435c      	muls	r4, r3
 8004262:	4f05      	ldr	r7, [pc, #20]	; (8004278 <shellCommandRegister+0x24>)
    shellCommands[shellCommandsIndex].sc_function = function;
    shellCommands[shellCommandsIndex].sc_user = user;
    shellCommandsIndex++;
 8004264:	3301      	adds	r3, #1
    shellCommands[shellCommandsIndex].sc_name = name;
 8004266:	193e      	adds	r6, r7, r4
    shellCommands[shellCommandsIndex].sc_user = user;
 8004268:	e9c6 1201 	strd	r1, r2, [r6, #4]
    shellCommands[shellCommandsIndex].sc_name = name;
 800426c:	5138      	str	r0, [r7, r4]
    shellCommandsIndex++;
 800426e:	702b      	strb	r3, [r5, #0]
}
 8004270:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004272:	bf00      	nop
 8004274:	20000910 	.word	0x20000910
 8004278:	2000085c 	.word	0x2000085c

0800427c <get_descriptor>:
        uint16_t lang)
{

    (void)usbp;
    (void)lang;
    switch (dtype) {
 800427c:	2902      	cmp	r1, #2
{
 800427e:	4613      	mov	r3, r2
 8004280:	b570      	push	{r4, r5, r6, lr}
    switch (dtype) {
 8004282:	d054      	beq.n	800432e <get_descriptor+0xb2>
 8004284:	2903      	cmp	r1, #3
 8004286:	d004      	beq.n	8004292 <get_descriptor+0x16>
        case USB_DESCRIPTOR_DEVICE:
            return &vcom_device_descriptor;
 8004288:	2901      	cmp	r1, #1
 800428a:	482b      	ldr	r0, [pc, #172]	; (8004338 <get_descriptor+0xbc>)
 800428c:	bf18      	it	ne
 800428e:	2000      	movne	r0, #0
                usbMakeSerial();
                return &vcom_strings[dindex];
            }
    }
    return NULL;
}
 8004290:	bd70      	pop	{r4, r5, r6, pc}
            if (dindex < 3)
 8004292:	2a02      	cmp	r2, #2
 8004294:	d803      	bhi.n	800429e <get_descriptor+0x22>
                return &vcom_strings[dindex];
 8004296:	4829      	ldr	r0, [pc, #164]	; (800433c <get_descriptor+0xc0>)
 8004298:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 800429c:	e7f8      	b.n	8004290 <get_descriptor+0x14>
            if (dindex == 3) {
 800429e:	2a03      	cmp	r2, #3
 80042a0:	d147      	bne.n	8004332 <get_descriptor+0xb6>
    if(serialString[0]) {
 80042a2:	4927      	ldr	r1, [pc, #156]	; (8004340 <get_descriptor+0xc4>)
 80042a4:	780a      	ldrb	r2, [r1, #0]
 80042a6:	b10a      	cbz	r2, 80042ac <get_descriptor+0x30>
                return &vcom_strings[dindex];
 80042a8:	4826      	ldr	r0, [pc, #152]	; (8004344 <get_descriptor+0xc8>)
 80042aa:	e7f1      	b.n	8004290 <get_descriptor+0x14>
    serialString[0] = USB_DESC_BYTE(sizeof(serialString));
 80042ac:	2084      	movs	r0, #132	; 0x84
    serialString[1] = USB_DESC_BYTE(USB_DESCRIPTOR_STRING);
 80042ae:	460c      	mov	r4, r1
    serialString[0] = USB_DESC_BYTE(sizeof(serialString));
 80042b0:	7008      	strb	r0, [r1, #0]
        serialString[3+i]=0;
 80042b2:	4616      	mov	r6, r2
 80042b4:	4608      	mov	r0, r1
    serialString[1] = USB_DESC_BYTE(USB_DESCRIPTOR_STRING);
 80042b6:	704b      	strb	r3, [r1, #1]
        serialString[2+i]=hexNibble((idReg[i>>2] >> (4*((i>>1)%2))) & 0xF);
 80042b8:	0893      	lsrs	r3, r2, #2
 80042ba:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80042be:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 80042c2:	f893 37e8 	ldrb.w	r3, [r3, #2024]	; 0x7e8
 80042c6:	f3c2 0540 	ubfx	r5, r2, #1, #1
 80042ca:	00ad      	lsls	r5, r5, #2
 80042cc:	412b      	asrs	r3, r5
 80042ce:	f003 030f 	and.w	r3, r3, #15
    if(a<10) {
 80042d2:	2b09      	cmp	r3, #9
 80042d4:	f102 0202 	add.w	r2, r2, #2
        return '0'+a;
 80042d8:	bf94      	ite	ls
 80042da:	3330      	addls	r3, #48	; 0x30
        return 'a'+a-10;
 80042dc:	3357      	addhi	r3, #87	; 0x57
    for(i=0; i<48; i+=2) {
 80042de:	2a30      	cmp	r2, #48	; 0x30
        serialString[2+i]=hexNibble((idReg[i>>2] >> (4*((i>>1)%2))) & 0xF);
 80042e0:	70a3      	strb	r3, [r4, #2]
        serialString[3+i]=0;
 80042e2:	70e6      	strb	r6, [r4, #3]
    for(i=0; i<48; i+=2) {
 80042e4:	f104 0402 	add.w	r4, r4, #2
 80042e8:	d1e6      	bne.n	80042b8 <get_descriptor+0x3c>
    serialString[50]='-';
 80042ea:	232d      	movs	r3, #45	; 0x2d
    serialString[51]=0;
 80042ec:	f881 6033 	strb.w	r6, [r1, #51]	; 0x33
    serialString[50]='-';
 80042f0:	f881 3032 	strb.w	r3, [r1, #50]	; 0x32
        serialString[53+i]=0;
 80042f4:	2400      	movs	r4, #0
    serialString[51]=0;
 80042f6:	2114      	movs	r1, #20
 80042f8:	4d13      	ldr	r5, [pc, #76]	; (8004348 <get_descriptor+0xcc>)
        serialString[52+i]=hexNibble(*buildId >> 4);
 80042fa:	f815 3f01 	ldrb.w	r3, [r5, #1]!
        serialString[53+i]=0;
 80042fe:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
        serialString[52+i]=hexNibble(*buildId >> 4);
 8004302:	091a      	lsrs	r2, r3, #4
    if(a<10) {
 8004304:	2b9f      	cmp	r3, #159	; 0x9f
        serialString[54+i]=hexNibble(*buildId & 0xF);
 8004306:	f003 030f 	and.w	r3, r3, #15
        return '0'+a;
 800430a:	bf94      	ite	ls
 800430c:	3230      	addls	r2, #48	; 0x30
        return 'a'+a-10;
 800430e:	3257      	addhi	r2, #87	; 0x57
    if(a<10) {
 8004310:	2b09      	cmp	r3, #9
        return '0'+a;
 8004312:	bf94      	ite	ls
 8004314:	3330      	addls	r3, #48	; 0x30
        return 'a'+a-10;
 8004316:	3357      	addhi	r3, #87	; 0x57
    for(i=0; i<80; i+=4) {
 8004318:	3901      	subs	r1, #1
        serialString[52+i]=hexNibble(*buildId >> 4);
 800431a:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
        serialString[54+i]=hexNibble(*buildId & 0xF);
 800431e:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
        serialString[55+i]=0;
 8004322:	f880 4037 	strb.w	r4, [r0, #55]	; 0x37
    for(i=0; i<80; i+=4) {
 8004326:	f100 0004 	add.w	r0, r0, #4
 800432a:	d1e6      	bne.n	80042fa <get_descriptor+0x7e>
 800432c:	e7bc      	b.n	80042a8 <get_descriptor+0x2c>
    switch (dtype) {
 800432e:	4807      	ldr	r0, [pc, #28]	; (800434c <get_descriptor+0xd0>)
 8004330:	e7ae      	b.n	8004290 <get_descriptor+0x14>
    return NULL;
 8004332:	2000      	movs	r0, #0
 8004334:	e7ac      	b.n	8004290 <get_descriptor+0x14>
 8004336:	bf00      	nop
 8004338:	0800cbf0 	.word	0x0800cbf0
 800433c:	0800cca0 	.word	0x0800cca0
 8004340:	20001231 	.word	0x20001231
 8004344:	0800ccb8 	.word	0x0800ccb8
 8004348:	0800cd2b 	.word	0x0800cd2b
 800434c:	0800cba4 	.word	0x0800cba4

08004350 <i2cSafeResultToString>:
}


const char* i2cSafeResultToString(i2c_result result)
{
    if(result == I2C_BUS_OK) return "OK";
 8004350:	4602      	mov	r2, r0
 8004352:	b188      	cbz	r0, 8004378 <i2cSafeResultToString+0x28>
    else if(result == I2C_BUS_TIMEOUT) return "Timeout";
 8004354:	1c41      	adds	r1, r0, #1
 8004356:	d011      	beq.n	800437c <i2cSafeResultToString+0x2c>
    else if(result == I2C_BUS_RESET) return "Transfer Error";
 8004358:	1c83      	adds	r3, r0, #2
 800435a:	d011      	beq.n	8004380 <i2cSafeResultToString+0x30>
    else if(result == I2C_BUS_STUCK_SCL_PULLED_LOW) return "SCL stuck low";
 800435c:	2801      	cmp	r0, #1
 800435e:	d011      	beq.n	8004384 <i2cSafeResultToString+0x34>
    else if(result == I2C_BUS_STUCK_SDA_PULLED_LOW) return "SDA stuck low";
 8004360:	2802      	cmp	r0, #2
 8004362:	d011      	beq.n	8004388 <i2cSafeResultToString+0x38>
    else if(result == I2C_BUS_STUCK_SCL_PULLED_HIGH) return "SCL stuck high";
 8004364:	2803      	cmp	r0, #3
 8004366:	d011      	beq.n	800438c <i2cSafeResultToString+0x3c>
    else if(result == I2C_BUS_STUCK_SDA_PULLED_HIGH) return "SDA stuck high";
 8004368:	2804      	cmp	r0, #4
 800436a:	d011      	beq.n	8004390 <i2cSafeResultToString+0x40>
    else if(result == I2C_BUS_STUCK_SHORTED_TOGETHER) return "SDA/SCL shorted together";
    else return "Unknown";
 800436c:	4b09      	ldr	r3, [pc, #36]	; (8004394 <i2cSafeResultToString+0x44>)
 800436e:	480a      	ldr	r0, [pc, #40]	; (8004398 <i2cSafeResultToString+0x48>)
 8004370:	2a05      	cmp	r2, #5
 8004372:	bf08      	it	eq
 8004374:	4618      	moveq	r0, r3
 8004376:	4770      	bx	lr
    if(result == I2C_BUS_OK) return "OK";
 8004378:	4808      	ldr	r0, [pc, #32]	; (800439c <i2cSafeResultToString+0x4c>)
 800437a:	4770      	bx	lr
    else if(result == I2C_BUS_TIMEOUT) return "Timeout";
 800437c:	4808      	ldr	r0, [pc, #32]	; (80043a0 <i2cSafeResultToString+0x50>)
 800437e:	4770      	bx	lr
    else if(result == I2C_BUS_RESET) return "Transfer Error";
 8004380:	4808      	ldr	r0, [pc, #32]	; (80043a4 <i2cSafeResultToString+0x54>)
 8004382:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SCL_PULLED_LOW) return "SCL stuck low";
 8004384:	4808      	ldr	r0, [pc, #32]	; (80043a8 <i2cSafeResultToString+0x58>)
 8004386:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SDA_PULLED_LOW) return "SDA stuck low";
 8004388:	4808      	ldr	r0, [pc, #32]	; (80043ac <i2cSafeResultToString+0x5c>)
 800438a:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SCL_PULLED_HIGH) return "SCL stuck high";
 800438c:	4808      	ldr	r0, [pc, #32]	; (80043b0 <i2cSafeResultToString+0x60>)
 800438e:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SDA_PULLED_HIGH) return "SDA stuck high";
 8004390:	4808      	ldr	r0, [pc, #32]	; (80043b4 <i2cSafeResultToString+0x64>)
}
 8004392:	4770      	bx	lr
 8004394:	0800ba08 	.word	0x0800ba08
 8004398:	0800ba66 	.word	0x0800ba66
 800439c:	0800ba21 	.word	0x0800ba21
 80043a0:	0800ba24 	.word	0x0800ba24
 80043a4:	0800ba2c 	.word	0x0800ba2c
 80043a8:	0800ba3b 	.word	0x0800ba3b
 80043ac:	0800ba58 	.word	0x0800ba58
 80043b0:	0800ba49 	.word	0x0800ba49
 80043b4:	0800b9f9 	.word	0x0800b9f9

080043b8 <gpioGetPortDriver>:
    return &GPIODriverData.ports[index];
}

static const GPIOPort* gpioGetPortDriver(uint8_t index)
{
    if(index >= GPIODriverData.numPorts) {
 80043b8:	4b04      	ldr	r3, [pc, #16]	; (80043cc <gpioGetPortDriver+0x14>)
 80043ba:	791a      	ldrb	r2, [r3, #4]
 80043bc:	4282      	cmp	r2, r0
        return &gpioDummyPort;
    }

    return &GPIODriverData.ports[index];
 80043be:	bf83      	ittte	hi
 80043c0:	220c      	movhi	r2, #12
 80043c2:	681b      	ldrhi	r3, [r3, #0]
 80043c4:	fb02 3000 	mlahi	r0, r2, r0, r3
        return &gpioDummyPort;
 80043c8:	4801      	ldrls	r0, [pc, #4]	; (80043d0 <gpioGetPortDriver+0x18>)
}
 80043ca:	4770      	bx	lr
 80043cc:	20000928 	.word	0x20000928
 80043d0:	0800ca10 	.word	0x0800ca10

080043d4 <gpioGetPin>:

    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
}

bool gpioGetPin(uint16_t pin)
{
 80043d4:	b513      	push	{r0, r1, r4, lr}
 80043d6:	4604      	mov	r4, r0
    uint8_t gpioPort = pin >> 8;
    uint8_t gpioPin = pin & 0xff;

    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 80043d8:	0a00      	lsrs	r0, r0, #8
 80043da:	f7ff ffed 	bl	80043b8 <gpioGetPortDriver>

    uint32_t value = 0;
 80043de:	2300      	movs	r3, #0
 80043e0:	9301      	str	r3, [sp, #4]
    port->functions->getValue(port, &value);
 80043e2:	6883      	ldr	r3, [r0, #8]
 80043e4:	a901      	add	r1, sp, #4
 80043e6:	68db      	ldr	r3, [r3, #12]
 80043e8:	4798      	blx	r3

    return (value >> gpioPin) & 1;
 80043ea:	9801      	ldr	r0, [sp, #4]
 80043ec:	b2e4      	uxtb	r4, r4
 80043ee:	40e0      	lsrs	r0, r4
}
 80043f0:	f000 0001 	and.w	r0, r0, #1
 80043f4:	b002      	add	sp, #8
 80043f6:	bd10      	pop	{r4, pc}

080043f8 <gpioPortIoDisable>:

    return value;
}

void gpioPortIoDisable(uint8_t gpioPort, bool disable)
{
 80043f8:	b510      	push	{r4, lr}
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 80043fa:	f7ff ffdd 	bl	80043b8 <gpioGetPortDriver>

    if(port->functions->busIoDisable) {
 80043fe:	6883      	ldr	r3, [r0, #8]
 8004400:	691b      	ldr	r3, [r3, #16]
 8004402:	b113      	cbz	r3, 800440a <gpioPortIoDisable+0x12>
        port->functions->busIoDisable(port, disable);
    }
}
 8004404:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        port->functions->busIoDisable(port, disable);
 8004408:	4718      	bx	r3
}
 800440a:	bd10      	pop	{r4, pc}

0800440c <gpioCPUSetPinMode>:
{
    (void)driver;
    (void)pin;
    (void)pinMode;

    palSetPadMode((ioportid_t)driver->driver, pin, pinMode);
 800440c:	2301      	movs	r3, #1
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 800440e:	2a03      	cmp	r2, #3
{
 8004410:	b5f0      	push	{r4, r5, r6, r7, lr}
    palSetPadMode((ioportid_t)driver->driver, pin, pinMode);
 8004412:	6800      	ldr	r0, [r0, #0]
 8004414:	fa03 f101 	lsl.w	r1, r3, r1
 8004418:	d129      	bne.n	800446e <gpioCPUSetPinMode+0x62>
    port->BSRR = mask;
 800441a:	6101      	str	r1, [r0, #16]
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
 800441c:	4b16      	ldr	r3, [pc, #88]	; (8004478 <gpioCPUSetPinMode+0x6c>)
 800441e:	2608      	movs	r6, #8
 8004420:	5c9f      	ldrb	r7, [r3, r2]
  mh = ml = crh = crl = 0;
 8004422:	2300      	movs	r3, #0
 8004424:	461a      	mov	r2, r3
 8004426:	461d      	mov	r5, r3
 8004428:	461c      	mov	r4, r3
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
    crl <<= 4;
    crh <<= 4;
    if ((mask & 0x0080) == 0)
 800442a:	f011 0f80 	tst.w	r1, #128	; 0x80
    ml <<= 4;
 800442e:	ea4f 1404 	mov.w	r4, r4, lsl #4
    crl <<= 4;
 8004432:	ea4f 1202 	mov.w	r2, r2, lsl #4
    mh <<= 4;
 8004436:	ea4f 1505 	mov.w	r5, r5, lsl #4
    crh <<= 4;
 800443a:	ea4f 1303 	mov.w	r3, r3, lsl #4
      ml |= 0xf;
 800443e:	bf0c      	ite	eq
 8004440:	f044 040f 	orreq.w	r4, r4, #15
    else
      crl |= cfg;
 8004444:	433a      	orrne	r2, r7
    if ((mask & 0x8000) == 0)
 8004446:	f411 4f00 	tst.w	r1, #32768	; 0x8000
      mh |= 0xf;
 800444a:	bf0c      	ite	eq
 800444c:	f045 050f 	orreq.w	r5, r5, #15
    else
      crh |= cfg;
 8004450:	433b      	orrne	r3, r7
  for (i = 0; i < 8; i++) {
 8004452:	3e01      	subs	r6, #1
    mask <<= 1;
 8004454:	ea4f 0141 	mov.w	r1, r1, lsl #1
  for (i = 0; i < 8; i++) {
 8004458:	d1e7      	bne.n	800442a <gpioCPUSetPinMode+0x1e>
  }
  port->CRH = (port->CRH & mh) | crh;
 800445a:	6841      	ldr	r1, [r0, #4]
 800445c:	4029      	ands	r1, r5
 800445e:	430b      	orrs	r3, r1
 8004460:	6043      	str	r3, [r0, #4]
  port->CRL = (port->CRL & ml) | crl;
 8004462:	6803      	ldr	r3, [r0, #0]
 8004464:	4023      	ands	r3, r4
 8004466:	4313      	orrs	r3, r2
 8004468:	6003      	str	r3, [r0, #0]

    return true;
}
 800446a:	2001      	movs	r0, #1
 800446c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
 800446e:	2a04      	cmp	r2, #4
    port->BRR = mask;
 8004470:	bf08      	it	eq
 8004472:	6141      	streq	r1, [r0, #20]
 8004474:	e7d2      	b.n	800441c <gpioCPUSetPinMode+0x10>
 8004476:	bf00      	nop
 8004478:	0800c8d0 	.word	0x0800c8d0

0800447c <gpioCPUSetValue>:
    (void)driver;
    (void)pinsToChange;
    (void)newValue;

    //syssts_t sts = osalSysGetStatusAndLockX();
    palWriteGroup((ioportid_t)driver->driver, pinsToChange, 0, newValue);
 800447c:	6803      	ldr	r3, [r0, #0]
 800447e:	ea21 0002 	bic.w	r0, r1, r2
 8004482:	400a      	ands	r2, r1
 8004484:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8004488:	611a      	str	r2, [r3, #16]
    //osalSysRestoreStatusX(sts);

    return true;
}
 800448a:	2001      	movs	r0, #1
 800448c:	4770      	bx	lr

0800448e <gpioCPUGetValue>:
static bool gpioCPUGetValue(const GPIOPort* driver, uint32_t* value)
{
    (void)driver;
    (void)value;

    *value = palReadPort((ioportid_t)driver->driver);
 800448e:	6803      	ldr	r3, [r0, #0]

    return true;
}
 8004490:	2001      	movs	r0, #1
    *value = palReadPort((ioportid_t)driver->driver);
 8004492:	689b      	ldr	r3, [r3, #8]
 8004494:	600b      	str	r3, [r1, #0]
}
 8004496:	4770      	bx	lr

08004498 <gpioCPUInit>:
    .getValue = gpioCPUGetValue,
    .status = gpioCPUStatus
};

void gpioCPUInit(uint8_t gpioPortId, ioportid_t port)
{
 8004498:	b510      	push	{r4, lr}
    if(index >= GPIODriverData.numPorts) {
 800449a:	4a0c      	ldr	r2, [pc, #48]	; (80044cc <gpioCPUInit+0x34>)
 800449c:	7913      	ldrb	r3, [r2, #4]
 800449e:	4283      	cmp	r3, r0
 80044a0:	d912      	bls.n	80044c8 <gpioCPUInit+0x30>
    if(GPIODriverData.registeredPorts & _BV(index)) {
 80044a2:	6894      	ldr	r4, [r2, #8]
 80044a4:	fa24 f300 	lsr.w	r3, r4, r0
 80044a8:	07db      	lsls	r3, r3, #31
 80044aa:	d40d      	bmi.n	80044c8 <gpioCPUInit+0x30>
    GPIODriverData.registeredPorts |= _BV(index);
 80044ac:	2301      	movs	r3, #1
 80044ae:	4083      	lsls	r3, r0
 80044b0:	4323      	orrs	r3, r4
 80044b2:	6093      	str	r3, [r2, #8]
    return &GPIODriverData.ports[index];
 80044b4:	230c      	movs	r3, #12
 80044b6:	4358      	muls	r0, r3
 80044b8:	6813      	ldr	r3, [r2, #0]
    GPIOPort* portDriver = gpioRegisterPortDriver(gpioPortId);
    if(!portDriver) {
 80044ba:	181a      	adds	r2, r3, r0
 80044bc:	d004      	beq.n	80044c8 <gpioCPUInit+0x30>
        return;
    }

    portDriver->driver = port;
 80044be:	5019      	str	r1, [r3, r0]
    portDriver->functions = &gpioCPUFunctions;
 80044c0:	4b03      	ldr	r3, [pc, #12]	; (80044d0 <gpioCPUInit+0x38>)
 80044c2:	6093      	str	r3, [r2, #8]
    portDriver->numPins = 16;
 80044c4:	2310      	movs	r3, #16
 80044c6:	6053      	str	r3, [r2, #4]
}
 80044c8:	bd10      	pop	{r4, pc}
 80044ca:	bf00      	nop
 80044cc:	20000928 	.word	0x20000928
 80044d0:	0800c9e0 	.word	0x0800c9e0

080044d4 <converterTune>:
#include "converter.h"
#include "shell.h"
#include "chprintf.h"

bool converterTune(ConverterManager* converter, ConverterTuneRequest* tuneRequest)
{
 80044d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* Iterate over all bands */
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 80044d8:	f04f 0c14 	mov.w	ip, #20
{
 80044dc:	4604      	mov	r4, r0
 80044de:	460d      	mov	r5, r1
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 80044e0:	6941      	ldr	r1, [r0, #20]
 80044e2:	2000      	movs	r0, #0
 80044e4:	b2c6      	uxtb	r6, r0
 80044e6:	fb0c f806 	mul.w	r8, ip, r6
 80044ea:	eb01 0208 	add.w	r2, r1, r8
 80044ee:	6913      	ldr	r3, [r2, #16]
 80044f0:	b1b3      	cbz	r3, 8004520 <converterTune+0x4c>
        if(_BV(i) & converter-> disabledBands) {
 80044f2:	69e7      	ldr	r7, [r4, #28]
 80044f4:	40f7      	lsrs	r7, r6
 80044f6:	07fb      	lsls	r3, r7, #31
 80044f8:	d41d      	bmi.n	8004536 <converterTune+0x62>
            continue;
        }

        uint32_t tmpFreq = tuneRequest->inputFrequencyKHz;

        if((tuneRequest->forceBand && tuneRequest->bandId == i) ||
 80044fa:	7a2b      	ldrb	r3, [r5, #8]
 80044fc:	b1a3      	cbz	r3, 8004528 <converterTune+0x54>
 80044fe:	7a6b      	ldrb	r3, [r5, #9]
 8004500:	42b3      	cmp	r3, r6
 8004502:	d118      	bne.n	8004536 <converterTune+0x62>
                (!tuneRequest->forceBand &&
                 tmpFreq >= converter->bands[i].minFrequencyKHz &&
                 tmpFreq <= converter->bands[i].maxFrequencyKHz)) {


            if(converter->activeBand != 0xff && converter->activeBand != i) {
 8004504:	7e23      	ldrb	r3, [r4, #24]
 8004506:	2bff      	cmp	r3, #255	; 0xff
 8004508:	d117      	bne.n	800453a <converterTune+0x66>
                    converter->bands[converter->activeBand].functions->converterLeaveBand(converter,
                            &converter->bands[converter->activeBand]);
                }
            }

            converter->activeBand = i;
 800450a:	7626      	strb	r6, [r4, #24]
            tuneRequest->bandId = i;
 800450c:	726e      	strb	r6, [r5, #9]

            bool retVal = converter->bands[i].functions->converterTuneBand(converter, &converter->bands[i], tuneRequest);
 800450e:	6961      	ldr	r1, [r4, #20]
 8004510:	462a      	mov	r2, r5
 8004512:	4441      	add	r1, r8
 8004514:	690b      	ldr	r3, [r1, #16]
 8004516:	4620      	mov	r0, r4
 8004518:	681b      	ldr	r3, [r3, #0]
 800451a:	4798      	blx	r3
            if(retVal) {
 800451c:	4606      	mov	r6, r0
 800451e:	b9c0      	cbnz	r0, 8004552 <converterTune+0x7e>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8004520:	2600      	movs	r6, #0
        }
    }


    return false;
}
 8004522:	4630      	mov	r0, r6
 8004524:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        uint32_t tmpFreq = tuneRequest->inputFrequencyKHz;
 8004528:	682f      	ldr	r7, [r5, #0]
                (!tuneRequest->forceBand &&
 800452a:	6853      	ldr	r3, [r2, #4]
 800452c:	42bb      	cmp	r3, r7
 800452e:	d802      	bhi.n	8004536 <converterTune+0x62>
                 tmpFreq >= converter->bands[i].minFrequencyKHz &&
 8004530:	6893      	ldr	r3, [r2, #8]
 8004532:	42bb      	cmp	r3, r7
 8004534:	d2e6      	bcs.n	8004504 <converterTune+0x30>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8004536:	3001      	adds	r0, #1
 8004538:	e7d4      	b.n	80044e4 <converterTune+0x10>
            if(converter->activeBand != 0xff && converter->activeBand != i) {
 800453a:	42b3      	cmp	r3, r6
 800453c:	d0e5      	beq.n	800450a <converterTune+0x36>
                if(converter->bands[converter->activeBand].functions->converterLeaveBand) {
 800453e:	2214      	movs	r2, #20
 8004540:	fb02 1103 	mla	r1, r2, r3, r1
 8004544:	690b      	ldr	r3, [r1, #16]
 8004546:	685b      	ldr	r3, [r3, #4]
 8004548:	2b00      	cmp	r3, #0
 800454a:	d0de      	beq.n	800450a <converterTune+0x36>
                    converter->bands[converter->activeBand].functions->converterLeaveBand(converter,
 800454c:	4620      	mov	r0, r4
 800454e:	4798      	blx	r3
 8004550:	e7db      	b.n	800450a <converterTune+0x36>
                converter->currentTune = *tuneRequest;
 8004552:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004554:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004556:	682b      	ldr	r3, [r5, #0]
 8004558:	6023      	str	r3, [r4, #0]
 800455a:	e7e2      	b.n	8004522 <converterTune+0x4e>

0800455c <converterTuneBypass>:


#include "converter.h"

static bool converterTuneBypass(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 800455c:	b510      	push	{r4, lr}
 800455e:	4614      	mov	r4, r2
    (void) band;

    converter->setConverterGpio(converter, 0);
 8004560:	6a03      	ldr	r3, [r0, #32]
 8004562:	2100      	movs	r1, #0
 8004564:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = tuneRequest->inputFrequencyKHz;
 8004566:	6823      	ldr	r3, [r4, #0]
    tuneRequest->spectrumInversion = false;

    return true;
}
 8004568:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = tuneRequest->inputFrequencyKHz;
 800456a:	60e3      	str	r3, [r4, #12]
    tuneRequest->spectrumInversion = false;
 800456c:	2300      	movs	r3, #0
 800456e:	7423      	strb	r3, [r4, #16]
}
 8004570:	bd10      	pop	{r4, pc}

08004572 <converterTuneSW>:

#include "converter.h"


static bool converterTuneSW(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 8004572:	b510      	push	{r4, lr}
 8004574:	4614      	mov	r4, r2
    (void) band;

    /* Switch on LO and Mixer */
    converter->setConverterGpio(converter, _BV(CONVERTER_IO_PIN_MIX_SW_EN) | _BV(CONVERTER_IO_PIN_MIX_SW_LO));
 8004576:	6a03      	ldr	r3, [r0, #32]
 8004578:	f44f 7140 	mov.w	r1, #768	; 0x300
 800457c:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = configCPU_CLOCK_HZ/1000 +tuneRequest->inputFrequencyKHz;
 800457e:	6823      	ldr	r3, [r4, #0]
    tuneRequest->spectrumInversion = false;

    return true;
}
 8004580:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = configCPU_CLOCK_HZ/1000 +tuneRequest->inputFrequencyKHz;
 8004582:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 8004586:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800458a:	60e3      	str	r3, [r4, #12]
    tuneRequest->spectrumInversion = false;
 800458c:	2300      	movs	r3, #0
 800458e:	7423      	strb	r3, [r4, #16]
}
 8004590:	bd10      	pop	{r4, pc}

08004592 <converterLeaveSW>:

static bool converterLeaveSW(const ConverterManager* converter, const ConverterBand* band)
{
 8004592:	b508      	push	{r3, lr}
    (void) converter;
    (void) band;

    /* Turn everything off */
    converter->setConverterGpio(converter, 0);
 8004594:	2100      	movs	r1, #0
 8004596:	6a03      	ldr	r3, [r0, #32]
 8004598:	4798      	blx	r3

    return true;
}
 800459a:	2001      	movs	r0, #1
 800459c:	bd08      	pop	{r3, pc}

0800459e <converterTuneSHF>:
 */

#include "converter.h"

static bool converterTuneSHF(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 800459e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t loFreq = 0;

    if(tuneRequest->antennaInput) {
        ioOut |= _BV(CONVERTER_IO_PIN_ANT_MID);
    } else {
        ioOut |= _BV(CONVERTER_IO_PIN_ANT_HIGH);
 80045a2:	f248 0308 	movw	r3, #32776	; 0x8008
 80045a6:	f248 0702 	movw	r7, #32770	; 0x8002
{
 80045aa:	4615      	mov	r5, r2
    ConverterSHFConfig* config = (ConverterSHFConfig*)band->userData;
 80045ac:	68ce      	ldr	r6, [r1, #12]
    if(tuneRequest->antennaInput) {
 80045ae:	6852      	ldr	r2, [r2, #4]
{
 80045b0:	4680      	mov	r8, r0
        ioOut |= _BV(CONVERTER_IO_PIN_ANT_HIGH);
 80045b2:	2a00      	cmp	r2, #0
 80045b4:	bf08      	it	eq
 80045b6:	461f      	moveq	r7, r3
    }

    if(config->useHighSideMixing) {
 80045b8:	7832      	ldrb	r2, [r6, #0]
        loFreq = tuneRequest->inputFrequencyKHz + config->ifFrequencyKHz;
 80045ba:	682c      	ldr	r4, [r5, #0]
 80045bc:	6873      	ldr	r3, [r6, #4]
    if(config->useHighSideMixing) {
 80045be:	b1ba      	cbz	r2, 80045f0 <converterTuneSHF+0x52>
        loFreq = tuneRequest->inputFrequencyKHz + config->ifFrequencyKHz;
 80045c0:	441c      	add	r4, r3
        }
        loFreq = tuneRequest->inputFrequencyKHz - config->ifFrequencyKHz;
    }

    /* If tuning failed, try to use LO/2 and enable doubler */
    if(!config->loTune(loFreq, 2)) {
 80045c2:	2102      	movs	r1, #2
 80045c4:	4620      	mov	r0, r4
 80045c6:	68b3      	ldr	r3, [r6, #8]
 80045c8:	4798      	blx	r3
 80045ca:	b930      	cbnz	r0, 80045da <converterTuneSHF+0x3c>
        loFreq /= 2;
        ioOut |= _BV(CONVERTER_IO_PIN_MIX_X2);

        /* Try again, if it fails now it is fatal */
        if(!config->loTune(loFreq, 2)) {
 80045cc:	2102      	movs	r1, #2
 80045ce:	68b3      	ldr	r3, [r6, #8]
 80045d0:	0860      	lsrs	r0, r4, #1
 80045d2:	4798      	blx	r3
 80045d4:	b170      	cbz	r0, 80045f4 <converterTuneSHF+0x56>
        ioOut |= _BV(CONVERTER_IO_PIN_MIX_X2);
 80045d6:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
            return false;
        }
    }

    converter->setConverterGpio(converter, ioOut);
 80045da:	4640      	mov	r0, r8
 80045dc:	f8d8 3020 	ldr.w	r3, [r8, #32]
 80045e0:	4639      	mov	r1, r7
 80045e2:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = config->ifFrequencyKHz;
 80045e4:	6873      	ldr	r3, [r6, #4]
    tuneRequest->spectrumInversion = config->useHighSideMixing;

    return true;
 80045e6:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = config->ifFrequencyKHz;
 80045e8:	60eb      	str	r3, [r5, #12]
    tuneRequest->spectrumInversion = config->useHighSideMixing;
 80045ea:	7833      	ldrb	r3, [r6, #0]
 80045ec:	742b      	strb	r3, [r5, #16]
    return true;
 80045ee:	e002      	b.n	80045f6 <converterTuneSHF+0x58>
        if(tuneRequest->inputFrequencyKHz < config->ifFrequencyKHz) {
 80045f0:	42a3      	cmp	r3, r4
 80045f2:	d902      	bls.n	80045fa <converterTuneSHF+0x5c>
            return false;
 80045f4:	2000      	movs	r0, #0
}
 80045f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        loFreq = tuneRequest->inputFrequencyKHz - config->ifFrequencyKHz;
 80045fa:	1ae4      	subs	r4, r4, r3
 80045fc:	e7e1      	b.n	80045c2 <converterTuneSHF+0x24>

080045fe <converterLeaveSHF>:

static bool converterLeaveSHF(const ConverterManager* converter, const ConverterBand* band)
{
 80045fe:	b510      	push	{r4, lr}
 8004600:	4604      	mov	r4, r0
    ConverterSHFConfig* config = (ConverterSHFConfig*)band->userData;

    /* Turn everything off */
    config->loTune(0, -127);
 8004602:	68cb      	ldr	r3, [r1, #12]
 8004604:	2000      	movs	r0, #0
 8004606:	f06f 017e 	mvn.w	r1, #126	; 0x7e
 800460a:	689b      	ldr	r3, [r3, #8]
 800460c:	4798      	blx	r3
    converter->setConverterGpio(converter, 0);
 800460e:	4620      	mov	r0, r4
 8004610:	2100      	movs	r1, #0
 8004612:	6a23      	ldr	r3, [r4, #32]
 8004614:	4798      	blx	r3

    return true;
}
 8004616:	2001      	movs	r0, #1
 8004618:	bd10      	pop	{r4, pc}
	...

0800461c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800461c:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800461e:	4b0f      	ldr	r3, [pc, #60]	; (800465c <prvInsertBlockIntoFreeList+0x40>)
 8004620:	461a      	mov	r2, r3
 8004622:	681b      	ldr	r3, [r3, #0]
 8004624:	4283      	cmp	r3, r0
 8004626:	d3fb      	bcc.n	8004620 <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8004628:	6854      	ldr	r4, [r2, #4]
 800462a:	1911      	adds	r1, r2, r4
 800462c:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800462e:	bf01      	itttt	eq
 8004630:	6841      	ldreq	r1, [r0, #4]
 8004632:	4610      	moveq	r0, r2
 8004634:	1909      	addeq	r1, r1, r4
 8004636:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004638:	6844      	ldr	r4, [r0, #4]
 800463a:	1901      	adds	r1, r0, r4
 800463c:	428b      	cmp	r3, r1
 800463e:	d107      	bne.n	8004650 <prvInsertBlockIntoFreeList+0x34>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004640:	4907      	ldr	r1, [pc, #28]	; (8004660 <prvInsertBlockIntoFreeList+0x44>)
 8004642:	6809      	ldr	r1, [r1, #0]
 8004644:	428b      	cmp	r3, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004646:	bf1f      	itttt	ne
 8004648:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800464a:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800464c:	1909      	addne	r1, r1, r4
 800464e:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8004650:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8004652:	6003      	str	r3, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004654:	bf18      	it	ne
 8004656:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8004658:	bd10      	pop	{r4, pc}
 800465a:	bf00      	nop
 800465c:	20001618 	.word	0x20001618
 8004660:	200011b0 	.word	0x200011b0

08004664 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8004664:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8004666:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8004668:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800466a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800466c:	689a      	ldr	r2, [r3, #8]
 800466e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8004670:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004672:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004674:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8004676:	3301      	adds	r3, #1
 8004678:	6003      	str	r3, [r0, #0]
}
 800467a:	4770      	bx	lr

0800467c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800467c:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800467e:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004680:	1c63      	adds	r3, r4, #1
 8004682:	d10a      	bne.n	800469a <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004684:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004686:	685a      	ldr	r2, [r3, #4]
 8004688:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800468a:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800468c:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800468e:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004690:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004692:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8004694:	3301      	adds	r3, #1
 8004696:	6003      	str	r3, [r0, #0]
}
 8004698:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800469a:	f100 0208 	add.w	r2, r0, #8
 800469e:	4613      	mov	r3, r2
 80046a0:	6852      	ldr	r2, [r2, #4]
 80046a2:	6815      	ldr	r5, [r2, #0]
 80046a4:	42a5      	cmp	r5, r4
 80046a6:	d9fa      	bls.n	800469e <vListInsert+0x22>
 80046a8:	e7ed      	b.n	8004686 <vListInsert+0xa>

080046aa <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80046aa:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80046ac:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
 80046b0:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80046b2:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80046b4:	6859      	ldr	r1, [r3, #4]
 80046b6:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80046b8:	bf08      	it	eq
 80046ba:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80046bc:	2200      	movs	r2, #0
 80046be:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80046c0:	681a      	ldr	r2, [r3, #0]
 80046c2:	3a01      	subs	r2, #1
 80046c4:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80046c6:	6818      	ldr	r0, [r3, #0]
}
 80046c8:	4770      	bx	lr
	...

080046cc <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80046cc:	4a02      	ldr	r2, [pc, #8]	; (80046d8 <vTaskSuspendAll+0xc>)
 80046ce:	6813      	ldr	r3, [r2, #0]
 80046d0:	3301      	adds	r3, #1
 80046d2:	6013      	str	r3, [r2, #0]
}
 80046d4:	4770      	bx	lr
 80046d6:	bf00      	nop
 80046d8:	2000136c 	.word	0x2000136c

080046dc <prvGetExpectedIdleTime>:
			/* When port optimised task selection is used the uxTopReadyPriority
			variable is used as a bit map.  If bits other than the least
			significant bit are set then there are tasks that have a priority
			above the idle priority that are in the Ready state.  This takes
			care of the case where the co-operative scheduler is in use. */
			if( uxTopReadyPriority > uxLeastSignificantBit )
 80046dc:	4b09      	ldr	r3, [pc, #36]	; (8004704 <prvGetExpectedIdleTime+0x28>)
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 80046de:	4a0a      	ldr	r2, [pc, #40]	; (8004708 <prvGetExpectedIdleTime+0x2c>)
			if( uxTopReadyPriority > uxLeastSignificantBit )
 80046e0:	681b      	ldr	r3, [r3, #0]
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 80046e2:	6812      	ldr	r2, [r2, #0]
 80046e4:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80046e6:	b958      	cbnz	r0, 8004700 <prvGetExpectedIdleTime+0x24>
		{
			xReturn = 0;
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 80046e8:	4a08      	ldr	r2, [pc, #32]	; (800470c <prvGetExpectedIdleTime+0x30>)
 80046ea:	6812      	ldr	r2, [r2, #0]
 80046ec:	2a01      	cmp	r2, #1
 80046ee:	d808      	bhi.n	8004702 <prvGetExpectedIdleTime+0x26>
			/* There are other idle priority tasks in the ready state.  If
			time slicing is used then the very next tick interrupt must be
			processed. */
			xReturn = 0;
		}
		else if( uxHigherPriorityReadyTasks != pdFALSE )
 80046f0:	2b01      	cmp	r3, #1
 80046f2:	d806      	bhi.n	8004702 <prvGetExpectedIdleTime+0x26>
			configUSE_PREEMPTION is 0. */
			xReturn = 0;
		}
		else
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
 80046f4:	4b06      	ldr	r3, [pc, #24]	; (8004710 <prvGetExpectedIdleTime+0x34>)
 80046f6:	6818      	ldr	r0, [r3, #0]
 80046f8:	4b06      	ldr	r3, [pc, #24]	; (8004714 <prvGetExpectedIdleTime+0x38>)
 80046fa:	681b      	ldr	r3, [r3, #0]
 80046fc:	1ac0      	subs	r0, r0, r3
 80046fe:	4770      	bx	lr
			xReturn = 0;
 8004700:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 8004702:	4770      	bx	lr
 8004704:	20001374 	.word	0x20001374
 8004708:	200011a8 	.word	0x200011a8
 800470c:	200011b8 	.word	0x200011b8
 8004710:	200015f8 	.word	0x200015f8
 8004714:	20001648 	.word	0x20001648

08004718 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004718:	4a06      	ldr	r2, [pc, #24]	; (8004734 <prvResetNextTaskUnblockTime+0x1c>)
 800471a:	6813      	ldr	r3, [r2, #0]
 800471c:	6819      	ldr	r1, [r3, #0]
 800471e:	4b06      	ldr	r3, [pc, #24]	; (8004738 <prvResetNextTaskUnblockTime+0x20>)
 8004720:	b919      	cbnz	r1, 800472a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8004722:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004726:	601a      	str	r2, [r3, #0]
	}
}
 8004728:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800472a:	6812      	ldr	r2, [r2, #0]
 800472c:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800472e:	68d2      	ldr	r2, [r2, #12]
 8004730:	6852      	ldr	r2, [r2, #4]
 8004732:	e7f8      	b.n	8004726 <prvResetNextTaskUnblockTime+0xe>
 8004734:	200011ac 	.word	0x200011ac
 8004738:	200015f8 	.word	0x200015f8

0800473c <xTaskIncrementTick>:
{
 800473c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004740:	4b38      	ldr	r3, [pc, #224]	; (8004824 <xTaskIncrementTick+0xe8>)
 8004742:	681b      	ldr	r3, [r3, #0]
 8004744:	2b00      	cmp	r3, #0
 8004746:	d166      	bne.n	8004816 <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004748:	4b37      	ldr	r3, [pc, #220]	; (8004828 <xTaskIncrementTick+0xec>)
 800474a:	681d      	ldr	r5, [r3, #0]
 800474c:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 800474e:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8004750:	b97d      	cbnz	r5, 8004772 <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 8004752:	4b36      	ldr	r3, [pc, #216]	; (800482c <xTaskIncrementTick+0xf0>)
 8004754:	681a      	ldr	r2, [r3, #0]
 8004756:	6812      	ldr	r2, [r2, #0]
 8004758:	b102      	cbz	r2, 800475c <xTaskIncrementTick+0x20>
 800475a:	e7fe      	b.n	800475a <xTaskIncrementTick+0x1e>
 800475c:	4a34      	ldr	r2, [pc, #208]	; (8004830 <xTaskIncrementTick+0xf4>)
 800475e:	6819      	ldr	r1, [r3, #0]
 8004760:	6810      	ldr	r0, [r2, #0]
 8004762:	6018      	str	r0, [r3, #0]
 8004764:	6011      	str	r1, [r2, #0]
 8004766:	4a33      	ldr	r2, [pc, #204]	; (8004834 <xTaskIncrementTick+0xf8>)
 8004768:	6813      	ldr	r3, [r2, #0]
 800476a:	3301      	adds	r3, #1
 800476c:	6013      	str	r3, [r2, #0]
 800476e:	f7ff ffd3 	bl	8004718 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004772:	4e31      	ldr	r6, [pc, #196]	; (8004838 <xTaskIncrementTick+0xfc>)
BaseType_t xSwitchRequired = pdFALSE;
 8004774:	2400      	movs	r4, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004776:	6833      	ldr	r3, [r6, #0]
 8004778:	4f30      	ldr	r7, [pc, #192]	; (800483c <xTaskIncrementTick+0x100>)
 800477a:	42ab      	cmp	r3, r5
 800477c:	d910      	bls.n	80047a0 <xTaskIncrementTick+0x64>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800477e:	2214      	movs	r2, #20
 8004780:	4b2f      	ldr	r3, [pc, #188]	; (8004840 <xTaskIncrementTick+0x104>)
 8004782:	681b      	ldr	r3, [r3, #0]
 8004784:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004786:	4353      	muls	r3, r2
 8004788:	58fb      	ldr	r3, [r7, r3]
				xSwitchRequired = pdTRUE;
 800478a:	2b02      	cmp	r3, #2
 800478c:	bf28      	it	cs
 800478e:	2401      	movcs	r4, #1
		if( xYieldPending != pdFALSE )
 8004790:	4b2c      	ldr	r3, [pc, #176]	; (8004844 <xTaskIncrementTick+0x108>)
 8004792:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 8004794:	2b00      	cmp	r3, #0
}
 8004796:	bf0c      	ite	eq
 8004798:	4620      	moveq	r0, r4
 800479a:	2001      	movne	r0, #1
 800479c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80047a0:	f8df a088 	ldr.w	sl, [pc, #136]	; 800482c <xTaskIncrementTick+0xf0>
					prvAddTaskToReadyList( pxTCB );
 80047a4:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8004848 <xTaskIncrementTick+0x10c>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80047a8:	f8da 3000 	ldr.w	r3, [sl]
 80047ac:	681b      	ldr	r3, [r3, #0]
 80047ae:	b91b      	cbnz	r3, 80047b8 <xTaskIncrementTick+0x7c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80047b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80047b4:	6033      	str	r3, [r6, #0]
					break;
 80047b6:	e7e2      	b.n	800477e <xTaskIncrementTick+0x42>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80047b8:	f8da 3000 	ldr.w	r3, [sl]
 80047bc:	68db      	ldr	r3, [r3, #12]
 80047be:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80047c2:	f8db 2004 	ldr.w	r2, [fp, #4]
					if( xConstTickCount < xItemValue )
 80047c6:	4295      	cmp	r5, r2
 80047c8:	d201      	bcs.n	80047ce <xTaskIncrementTick+0x92>
						xNextTaskUnblockTime = xItemValue;
 80047ca:	6032      	str	r2, [r6, #0]
						break;
 80047cc:	e7d7      	b.n	800477e <xTaskIncrementTick+0x42>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80047ce:	f10b 0804 	add.w	r8, fp, #4
 80047d2:	4640      	mov	r0, r8
 80047d4:	f7ff ff69 	bl	80046aa <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80047d8:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
 80047dc:	b11a      	cbz	r2, 80047e6 <xTaskIncrementTick+0xaa>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80047de:	f10b 0018 	add.w	r0, fp, #24
 80047e2:	f7ff ff62 	bl	80046aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80047e6:	2201      	movs	r2, #1
 80047e8:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
 80047ec:	f8d9 3000 	ldr.w	r3, [r9]
 80047f0:	4082      	lsls	r2, r0
 80047f2:	431a      	orrs	r2, r3
 80047f4:	f8c9 2000 	str.w	r2, [r9]
 80047f8:	2214      	movs	r2, #20
 80047fa:	4641      	mov	r1, r8
 80047fc:	fb02 7000 	mla	r0, r2, r0, r7
 8004800:	f7ff ff30 	bl	8004664 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004804:	4b0e      	ldr	r3, [pc, #56]	; (8004840 <xTaskIncrementTick+0x104>)
 8004806:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
 800480a:	6819      	ldr	r1, [r3, #0]
 800480c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800480e:	429a      	cmp	r2, r3
 8004810:	bf28      	it	cs
 8004812:	2401      	movcs	r4, #1
 8004814:	e7c8      	b.n	80047a8 <xTaskIncrementTick+0x6c>
		++uxPendedTicks;
 8004816:	4a0d      	ldr	r2, [pc, #52]	; (800484c <xTaskIncrementTick+0x110>)
BaseType_t xSwitchRequired = pdFALSE;
 8004818:	2400      	movs	r4, #0
		++uxPendedTicks;
 800481a:	6813      	ldr	r3, [r2, #0]
 800481c:	3301      	adds	r3, #1
 800481e:	6013      	str	r3, [r2, #0]
 8004820:	e7b6      	b.n	8004790 <xTaskIncrementTick+0x54>
 8004822:	bf00      	nop
 8004824:	2000136c 	.word	0x2000136c
 8004828:	20001648 	.word	0x20001648
 800482c:	200011ac 	.word	0x200011ac
 8004830:	200011b4 	.word	0x200011b4
 8004834:	200015fc 	.word	0x200015fc
 8004838:	200015f8 	.word	0x200015f8
 800483c:	200011b8 	.word	0x200011b8
 8004840:	200011a8 	.word	0x200011a8
 8004844:	2000164c 	.word	0x2000164c
 8004848:	20001374 	.word	0x20001374
 800484c:	20001364 	.word	0x20001364

08004850 <xTaskRemoveFromEventList>:
{
 8004850:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8004852:	68c3      	ldr	r3, [r0, #12]
 8004854:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8004856:	b904      	cbnz	r4, 800485a <xTaskRemoveFromEventList+0xa>
 8004858:	e7fe      	b.n	8004858 <xTaskRemoveFromEventList+0x8>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800485a:	f104 0518 	add.w	r5, r4, #24
 800485e:	4628      	mov	r0, r5
 8004860:	f7ff ff23 	bl	80046aa <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004864:	4b12      	ldr	r3, [pc, #72]	; (80048b0 <xTaskRemoveFromEventList+0x60>)
 8004866:	681b      	ldr	r3, [r3, #0]
 8004868:	b9f3      	cbnz	r3, 80048a8 <xTaskRemoveFromEventList+0x58>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800486a:	1d25      	adds	r5, r4, #4
 800486c:	4628      	mov	r0, r5
 800486e:	f7ff ff1c 	bl	80046aa <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8004872:	2301      	movs	r3, #1
 8004874:	490f      	ldr	r1, [pc, #60]	; (80048b4 <xTaskRemoveFromEventList+0x64>)
 8004876:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004878:	6808      	ldr	r0, [r1, #0]
 800487a:	4093      	lsls	r3, r2
 800487c:	4303      	orrs	r3, r0
 800487e:	2014      	movs	r0, #20
 8004880:	600b      	str	r3, [r1, #0]
 8004882:	4629      	mov	r1, r5
 8004884:	4b0c      	ldr	r3, [pc, #48]	; (80048b8 <xTaskRemoveFromEventList+0x68>)
 8004886:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800488a:	f7ff feeb 	bl	8004664 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800488e:	4b0b      	ldr	r3, [pc, #44]	; (80048bc <xTaskRemoveFromEventList+0x6c>)
 8004890:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004892:	681b      	ldr	r3, [r3, #0]
 8004894:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004896:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8004898:	bf85      	ittet	hi
 800489a:	2001      	movhi	r0, #1
 800489c:	4b08      	ldrhi	r3, [pc, #32]	; (80048c0 <xTaskRemoveFromEventList+0x70>)
		xReturn = pdFALSE;
 800489e:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
 80048a0:	6018      	strhi	r0, [r3, #0]
		prvResetNextTaskUnblockTime();
 80048a2:	f7ff ff39 	bl	8004718 <prvResetNextTaskUnblockTime>
}
 80048a6:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80048a8:	4629      	mov	r1, r5
 80048aa:	4806      	ldr	r0, [pc, #24]	; (80048c4 <xTaskRemoveFromEventList+0x74>)
 80048ac:	e7ed      	b.n	800488a <xTaskRemoveFromEventList+0x3a>
 80048ae:	bf00      	nop
 80048b0:	2000136c 	.word	0x2000136c
 80048b4:	20001374 	.word	0x20001374
 80048b8:	200011b8 	.word	0x200011b8
 80048bc:	200011a8 	.word	0x200011a8
 80048c0:	2000164c 	.word	0x2000164c
 80048c4:	20001600 	.word	0x20001600

080048c8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80048c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80048ca:	4b1a      	ldr	r3, [pc, #104]	; (8004934 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048cc:	4d1a      	ldr	r5, [pc, #104]	; (8004938 <prvAddCurrentTaskToDelayedList+0x70>)
{
 80048ce:	4606      	mov	r6, r0
const TickType_t xConstTickCount = xTickCount;
 80048d0:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048d2:	6828      	ldr	r0, [r5, #0]
{
 80048d4:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048d6:	3004      	adds	r0, #4
 80048d8:	f7ff fee7 	bl	80046aa <uxListRemove>
 80048dc:	b940      	cbnz	r0, 80048f0 <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80048de:	682a      	ldr	r2, [r5, #0]
 80048e0:	4916      	ldr	r1, [pc, #88]	; (800493c <prvAddCurrentTaskToDelayedList+0x74>)
 80048e2:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80048e4:	2201      	movs	r2, #1
 80048e6:	680b      	ldr	r3, [r1, #0]
 80048e8:	4082      	lsls	r2, r0
 80048ea:	ea23 0302 	bic.w	r3, r3, r2
 80048ee:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80048f0:	1c73      	adds	r3, r6, #1
 80048f2:	d107      	bne.n	8004904 <prvAddCurrentTaskToDelayedList+0x3c>
 80048f4:	b137      	cbz	r7, 8004904 <prvAddCurrentTaskToDelayedList+0x3c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80048f6:	6829      	ldr	r1, [r5, #0]
 80048f8:	4811      	ldr	r0, [pc, #68]	; (8004940 <prvAddCurrentTaskToDelayedList+0x78>)
 80048fa:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80048fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004900:	f7ff beb0 	b.w	8004664 <vListInsertEnd>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004904:	682b      	ldr	r3, [r5, #0]
 8004906:	19a4      	adds	r4, r4, r6
 8004908:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800490a:	d307      	bcc.n	800491c <prvAddCurrentTaskToDelayedList+0x54>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800490c:	4b0d      	ldr	r3, [pc, #52]	; (8004944 <prvAddCurrentTaskToDelayedList+0x7c>)
 800490e:	6818      	ldr	r0, [r3, #0]
 8004910:	6829      	ldr	r1, [r5, #0]
}
 8004912:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004916:	3104      	adds	r1, #4
 8004918:	f7ff beb0 	b.w	800467c <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800491c:	4b0a      	ldr	r3, [pc, #40]	; (8004948 <prvAddCurrentTaskToDelayedList+0x80>)
 800491e:	6818      	ldr	r0, [r3, #0]
 8004920:	6829      	ldr	r1, [r5, #0]
 8004922:	3104      	adds	r1, #4
 8004924:	f7ff feaa 	bl	800467c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8004928:	4b08      	ldr	r3, [pc, #32]	; (800494c <prvAddCurrentTaskToDelayedList+0x84>)
 800492a:	681a      	ldr	r2, [r3, #0]
 800492c:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 800492e:	bf88      	it	hi
 8004930:	601c      	strhi	r4, [r3, #0]
}
 8004932:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004934:	20001648 	.word	0x20001648
 8004938:	200011a8 	.word	0x200011a8
 800493c:	20001374 	.word	0x20001374
 8004940:	20001620 	.word	0x20001620
 8004944:	200011b4 	.word	0x200011b4
 8004948:	200011ac 	.word	0x200011ac
 800494c:	200015f8 	.word	0x200015f8

08004950 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004950:	4b0b      	ldr	r3, [pc, #44]	; (8004980 <pxCurrentTCBConst2>)
 8004952:	6819      	ldr	r1, [r3, #0]
 8004954:	6808      	ldr	r0, [r1, #0]
 8004956:	c830      	ldmia	r0!, {r4, r5}
 8004958:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800495c:	f380 8809 	msr	PSP, r0
 8004960:	f3bf 8f6f 	isb	sy
 8004964:	f04f 0000 	mov.w	r0, #0
 8004968:	f380 8811 	msr	BASEPRI, r0
 800496c:	f04e 0e0d 	orr.w	lr, lr, #13
 8004970:	4770      	bx	lr
 8004972:	bf00      	nop
 8004974:	f3af 8000 	nop.w
 8004978:	f3af 8000 	nop.w
 800497c:	f3af 8000 	nop.w

08004980 <pxCurrentTCBConst2>:
 8004980:	200011a8 	.word	0x200011a8

08004984 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004984:	4806      	ldr	r0, [pc, #24]	; (80049a0 <prvPortStartFirstTask+0x1c>)
 8004986:	6800      	ldr	r0, [r0, #0]
 8004988:	6800      	ldr	r0, [r0, #0]
 800498a:	f380 8808 	msr	MSP, r0
 800498e:	b662      	cpsie	i
 8004990:	b661      	cpsie	f
 8004992:	f3bf 8f4f 	dsb	sy
 8004996:	f3bf 8f6f 	isb	sy
 800499a:	df00      	svc	0
 800499c:	bf00      	nop
					"       dsb                       \n"
					"       isb                       \n"
					"       svc 0                     \n" /* System call to start first task. */
					"       nop                       \n"
				);
}
 800499e:	0000      	.short	0x0000
 80049a0:	e000ed08 	.word	0xe000ed08

080049a4 <vPortEnterCritical>:
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	if(!uxCriticalNesting) {
 80049a4:	4a06      	ldr	r2, [pc, #24]	; (80049c0 <vPortEnterCritical+0x1c>)
 80049a6:	6813      	ldr	r3, [r2, #0]
 80049a8:	b93b      	cbnz	r3, 80049ba <vPortEnterCritical+0x16>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80049aa:	f04f 01bf 	mov.w	r1, #191	; 0xbf
 80049ae:	f381 8811 	msr	BASEPRI, r1
 80049b2:	f3bf 8f6f 	isb	sy
 80049b6:	f3bf 8f4f 	dsb	sy
		vPortRaiseBASEPRI();
	}

	uxCriticalNesting++;
 80049ba:	3301      	adds	r3, #1
 80049bc:	6013      	str	r3, [r2, #0]
}
 80049be:	4770      	bx	lr
 80049c0:	20001358 	.word	0x20001358

080049c4 <vTaskEndScheduler>:
{
 80049c4:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 80049c6:	f7ff ffed 	bl	80049a4 <vPortEnterCritical>
	xSchedulerRunning = pdFALSE;
 80049ca:	2200      	movs	r2, #0
 80049cc:	4b02      	ldr	r3, [pc, #8]	; (80049d8 <vTaskEndScheduler+0x14>)
 80049ce:	601a      	str	r2, [r3, #0]
	asm volatile ("cpsid i");
 80049d0:	b672      	cpsid	i
	asm volatile ("cpsid f");
 80049d2:	b671      	cpsid	f
}
 80049d4:	bd08      	pop	{r3, pc}
 80049d6:	bf00      	nop
 80049d8:	20001614 	.word	0x20001614

080049dc <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 80049dc:	b510      	push	{r4, lr}
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static BaseType_t xPortIsCriticalSection( void ){
uint32_t ulBasePri;
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80049de:	f3ef 8311 	mrs	r3, BASEPRI
	
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80049e2:	b12b      	cbz	r3, 80049f0 <ibqReleaseEmptyBufferS+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80049e4:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80049e8:	b12b      	cbz	r3, 80049f6 <ibqReleaseEmptyBufferS+0x1a>

  osalDbgCheckClassS();
 80049ea:	f7ff ffeb 	bl	80049c4 <vTaskEndScheduler>
 80049ee:	e7fe      	b.n	80049ee <ibqReleaseEmptyBufferS+0x12>
 80049f0:	f7ff ffe8 	bl	80049c4 <vTaskEndScheduler>
 80049f4:	e7fe      	b.n	80049f4 <ibqReleaseEmptyBufferS+0x18>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80049f6:	68c3      	ldr	r3, [r0, #12]
 80049f8:	b913      	cbnz	r3, 8004a00 <ibqReleaseEmptyBufferS+0x24>
 80049fa:	f7ff ffe3 	bl	80049c4 <vTaskEndScheduler>
 80049fe:	e7fe      	b.n	80049fe <ibqReleaseEmptyBufferS+0x22>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8004a00:	68c3      	ldr	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 8004a02:	69c2      	ldr	r2, [r0, #28]
  ibqp->bcounter--;
 8004a04:	3b01      	subs	r3, #1
 8004a06:	60c3      	str	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 8004a08:	6943      	ldr	r3, [r0, #20]
 8004a0a:	4413      	add	r3, r2
  if (ibqp->brdptr >= ibqp->btop) {
 8004a0c:	6982      	ldr	r2, [r0, #24]
  ibqp->brdptr += ibqp->bsize;
 8004a0e:	6143      	str	r3, [r0, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8004a10:	4293      	cmp	r3, r2
    ibqp->brdptr = ibqp->buffers;
 8004a12:	bf24      	itt	cs
 8004a14:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8004a16:	6143      	strcs	r3, [r0, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004a18:	2300      	movs	r3, #0
 8004a1a:	6283      	str	r3, [r0, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004a1c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004a1e:	b113      	cbz	r3, 8004a26 <ibqReleaseEmptyBufferS+0x4a>
    ibqp->notify(ibqp);
  }
}
 8004a20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
 8004a24:	4718      	bx	r3
}
 8004a26:	bd10      	pop	{r4, pc}

08004a28 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004a28:	b508      	push	{r3, lr}
 8004a2a:	4603      	mov	r3, r0
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004a2c:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004a30:	b15a      	cbz	r2, 8004a4a <obqGetFullBufferI+0x22>

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004a32:	e9d0 2004 	ldrd	r2, r0, [r0, #16]
 8004a36:	4282      	cmp	r2, r0
 8004a38:	d101      	bne.n	8004a3e <obqGetFullBufferI+0x16>
 8004a3a:	68db      	ldr	r3, [r3, #12]
 8004a3c:	b91b      	cbnz	r3, 8004a46 <obqGetFullBufferI+0x1e>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8004a3e:	f850 3b04 	ldr.w	r3, [r0], #4
 8004a42:	600b      	str	r3, [r1, #0]

  return obqp->brdptr + sizeof (size_t);
}
 8004a44:	bd08      	pop	{r3, pc}
    return NULL;
 8004a46:	2000      	movs	r0, #0
 8004a48:	e7fc      	b.n	8004a44 <obqGetFullBufferI+0x1c>
  osalDbgCheckClassI();
 8004a4a:	f7ff ffbb 	bl	80049c4 <vTaskEndScheduler>
 8004a4e:	e7fe      	b.n	8004a4e <obqGetFullBufferI+0x26>

08004a50 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8004a50:	b510      	push	{r4, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004a52:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004a56:	b12b      	cbz	r3, 8004a64 <obqPostFullBufferS+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004a58:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 8004a5c:	b12b      	cbz	r3, 8004a6a <obqPostFullBufferS+0x1a>

  osalDbgCheckClassS();
 8004a5e:	f7ff ffb1 	bl	80049c4 <vTaskEndScheduler>
 8004a62:	e7fe      	b.n	8004a62 <obqPostFullBufferS+0x12>
 8004a64:	f7ff ffae 	bl	80049c4 <vTaskEndScheduler>
 8004a68:	e7fe      	b.n	8004a68 <obqPostFullBufferS+0x18>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8004a6a:	b119      	cbz	r1, 8004a74 <obqPostFullBufferS+0x24>
 8004a6c:	69c3      	ldr	r3, [r0, #28]
 8004a6e:	3b04      	subs	r3, #4
 8004a70:	4299      	cmp	r1, r3
 8004a72:	d902      	bls.n	8004a7a <obqPostFullBufferS+0x2a>
 8004a74:	f7ff ffa6 	bl	80049c4 <vTaskEndScheduler>
 8004a78:	e7fe      	b.n	8004a78 <obqPostFullBufferS+0x28>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8004a7a:	68c3      	ldr	r3, [r0, #12]
 8004a7c:	b913      	cbnz	r3, 8004a84 <obqPostFullBufferS+0x34>
 8004a7e:	f7ff ffa1 	bl	80049c4 <vTaskEndScheduler>
 8004a82:	e7fe      	b.n	8004a82 <obqPostFullBufferS+0x32>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8004a84:	6903      	ldr	r3, [r0, #16]
 8004a86:	6019      	str	r1, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8004a88:	68c2      	ldr	r2, [r0, #12]
 8004a8a:	3a01      	subs	r2, #1
 8004a8c:	60c2      	str	r2, [r0, #12]
  obqp->bwrptr += obqp->bsize;
 8004a8e:	69c2      	ldr	r2, [r0, #28]
 8004a90:	4413      	add	r3, r2
  if (obqp->bwrptr >= obqp->btop) {
 8004a92:	6982      	ldr	r2, [r0, #24]
  obqp->bwrptr += obqp->bsize;
 8004a94:	6103      	str	r3, [r0, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8004a96:	4293      	cmp	r3, r2
    obqp->bwrptr = obqp->buffers;
 8004a98:	bf24      	itt	cs
 8004a9a:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8004a9c:	6103      	strcs	r3, [r0, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8004a9e:	2300      	movs	r3, #0
 8004aa0:	6283      	str	r3, [r0, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8004aa2:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004aa4:	b113      	cbz	r3, 8004aac <obqPostFullBufferS+0x5c>
    obqp->notify(obqp);
  }
}
 8004aa6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    obqp->notify(obqp);
 8004aaa:	4718      	bx	r3
}
 8004aac:	bd10      	pop	{r4, pc}
	...

08004ab0 <osalOsRescheduleS.lto_priv.1>:
{
 8004ab0:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004ab2:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004ab6:	b12b      	cbz	r3, 8004ac4 <osalOsRescheduleS.lto_priv.1+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004ab8:	f3ef 8205 	mrs	r2, IPSR
	if( ulCurrentInterrupt == 0 )
 8004abc:	b12a      	cbz	r2, 8004aca <osalOsRescheduleS.lto_priv.1+0x1a>
    osalDbgCheckClassS();
 8004abe:	f7ff ff81 	bl	80049c4 <vTaskEndScheduler>
 8004ac2:	e7fe      	b.n	8004ac2 <osalOsRescheduleS.lto_priv.1+0x12>
 8004ac4:	f7ff ff7e 	bl	80049c4 <vTaskEndScheduler>
 8004ac8:	e7fe      	b.n	8004ac8 <osalOsRescheduleS.lto_priv.1+0x18>
    UBaseType_t isIt = xYieldPending;
 8004aca:	4b04      	ldr	r3, [pc, #16]	; (8004adc <osalOsRescheduleS.lto_priv.1+0x2c>)
 8004acc:	6819      	ldr	r1, [r3, #0]
    xYieldPending = pdFALSE;
 8004ace:	601a      	str	r2, [r3, #0]
    if(uxYieldPending()) taskYIELD();
 8004ad0:	b119      	cbz	r1, 8004ada <osalOsRescheduleS.lto_priv.1+0x2a>
}
 8004ad2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004ad6:	f7ff b951 	b.w	8003d7c <Vector6C.part.0>
 8004ada:	bd08      	pop	{r3, pc}
 8004adc:	2000164c 	.word	0x2000164c

08004ae0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8004ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004ae2:	f3ef 8411 	mrs	r4, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004ae6:	b11c      	cbz	r4, 8004af0 <usbStartReceiveI+0x10>
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004ae8:	b928      	cbnz	r0, 8004af6 <usbStartReceiveI+0x16>
 8004aea:	f7ff ff6b 	bl	80049c4 <vTaskEndScheduler>
 8004aee:	e7fe      	b.n	8004aee <usbStartReceiveI+0xe>
  osalDbgCheckClassI();
 8004af0:	f7ff ff68 	bl	80049c4 <vTaskEndScheduler>
 8004af4:	e7fe      	b.n	8004af4 <usbStartReceiveI+0x14>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004af6:	2907      	cmp	r1, #7
 8004af8:	d8f7      	bhi.n	8004aea <usbStartReceiveI+0xa>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8004afa:	2401      	movs	r4, #1
 8004afc:	8946      	ldrh	r6, [r0, #10]
 8004afe:	fa04 f501 	lsl.w	r5, r4, r1
 8004b02:	b2af      	uxth	r7, r5
 8004b04:	4035      	ands	r5, r6
 8004b06:	d002      	beq.n	8004b0e <usbStartReceiveI+0x2e>
 8004b08:	f7ff ff5c 	bl	80049c4 <vTaskEndScheduler>
 8004b0c:	e7fe      	b.n	8004b0c <usbStartReceiveI+0x2c>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004b0e:	433e      	orrs	r6, r7
 8004b10:	8146      	strh	r6, [r0, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8004b12:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8004b16:	68c6      	ldr	r6, [r0, #12]
 8004b18:	69b0      	ldr	r0, [r6, #24]
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8004b1a:	e9c0 3500 	strd	r3, r5, [r0]
  osp->rxbuf  = buf;
 8004b1e:	6082      	str	r2, [r0, #8]
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8004b20:	b1b3      	cbz	r3, 8004b50 <usbStartReceiveI+0x70>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8004b22:	8a72      	ldrh	r2, [r6, #18]
 8004b24:	3b01      	subs	r3, #1
 8004b26:	4413      	add	r3, r2
 8004b28:	fbb3 f3f2 	udiv	r3, r3, r2
 8004b2c:	b29b      	uxth	r3, r3
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8004b2e:	4a09      	ldr	r2, [pc, #36]	; (8004b54 <usbStartReceiveI+0x74>)
 8004b30:	8183      	strh	r3, [r0, #12]
 8004b32:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8004b36:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8004b3a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004b3e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8004b42:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004b46:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004b4a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8004b4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    osp->rxpkts = 1;
 8004b50:	4623      	mov	r3, r4
 8004b52:	e7ec      	b.n	8004b2e <usbStartReceiveI+0x4e>
 8004b54:	40005c00 	.word	0x40005c00

08004b58 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8004b58:	b570      	push	{r4, r5, r6, lr}
 8004b5a:	460c      	mov	r4, r1
 8004b5c:	4611      	mov	r1, r2
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004b5e:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004b62:	b11a      	cbz	r2, 8004b6c <usbStartTransmitI+0x14>
  USBInEndpointState *isp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004b64:	b928      	cbnz	r0, 8004b72 <usbStartTransmitI+0x1a>
 8004b66:	f7ff ff2d 	bl	80049c4 <vTaskEndScheduler>
 8004b6a:	e7fe      	b.n	8004b6a <usbStartTransmitI+0x12>
  osalDbgCheckClassI();
 8004b6c:	f7ff ff2a 	bl	80049c4 <vTaskEndScheduler>
 8004b70:	e7fe      	b.n	8004b70 <usbStartTransmitI+0x18>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004b72:	2c07      	cmp	r4, #7
 8004b74:	d8f7      	bhi.n	8004b66 <usbStartTransmitI+0xe>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8004b76:	2501      	movs	r5, #1
 8004b78:	8906      	ldrh	r6, [r0, #8]
 8004b7a:	40a5      	lsls	r5, r4
 8004b7c:	b2aa      	uxth	r2, r5
 8004b7e:	4035      	ands	r5, r6
 8004b80:	d002      	beq.n	8004b88 <usbStartTransmitI+0x30>
 8004b82:	f7ff ff1f 	bl	80049c4 <vTaskEndScheduler>
 8004b86:	e7fe      	b.n	8004b86 <usbStartTransmitI+0x2e>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004b88:	4316      	orrs	r6, r2
 8004b8a:	8106      	strh	r6, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8004b8c:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 8004b90:	68c2      	ldr	r2, [r0, #12]
 8004b92:	6950      	ldr	r0, [r2, #20]
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8004b94:	8a12      	ldrh	r2, [r2, #16]
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8004b96:	e9c0 3500 	strd	r3, r5, [r0]
 8004b9a:	429a      	cmp	r2, r3
 8004b9c:	bf28      	it	cs
 8004b9e:	461a      	movcs	r2, r3
  isp->txbuf  = buf;
 8004ba0:	6081      	str	r1, [r0, #8]
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 8004ba2:	60c2      	str	r2, [r0, #12]
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8004ba4:	4620      	mov	r0, r4
 8004ba6:	f7ff fadb 	bl	8004160 <usb_packet_write_from_buffer>

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8004baa:	4a08      	ldr	r2, [pc, #32]	; (8004bcc <usbStartTransmitI+0x74>)
 8004bac:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 8004bb0:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8004bb4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004bb8:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8004bbc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004bc0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004bc4:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8004bc8:	bd70      	pop	{r4, r5, r6, pc}
 8004bca:	bf00      	nop
 8004bcc:	40005c00 	.word	0x40005c00

08004bd0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 8004bd0:	b513      	push	{r0, r1, r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004bd2:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004bd4:	f8d4 3498 	ldr.w	r3, [r4, #1176]	; 0x498
 8004bd8:	681a      	ldr	r2, [r3, #0]
 8004bda:	7811      	ldrb	r1, [r2, #0]
 8004bdc:	2904      	cmp	r1, #4
 8004bde:	d116      	bne.n	8004c0e <obnotify+0x3e>
 8004be0:	7d21      	ldrb	r1, [r4, #20]
 8004be2:	2902      	cmp	r1, #2
 8004be4:	d113      	bne.n	8004c0e <obnotify+0x3e>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004be6:	7919      	ldrb	r1, [r3, #4]
 8004be8:	2301      	movs	r3, #1
 8004bea:	8912      	ldrh	r2, [r2, #8]
 8004bec:	408b      	lsls	r3, r1
 8004bee:	4213      	tst	r3, r2
 8004bf0:	d10d      	bne.n	8004c0e <obnotify+0x3e>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8004bf2:	a901      	add	r1, sp, #4
 8004bf4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8004bf8:	f7ff ff16 	bl	8004a28 <obqGetFullBufferI>
    if (buf != NULL) {
 8004bfc:	4602      	mov	r2, r0
 8004bfe:	b130      	cbz	r0, 8004c0e <obnotify+0x3e>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8004c00:	f8d4 0498 	ldr.w	r0, [r4, #1176]	; 0x498
 8004c04:	9b01      	ldr	r3, [sp, #4]
 8004c06:	7901      	ldrb	r1, [r0, #4]
 8004c08:	6800      	ldr	r0, [r0, #0]
 8004c0a:	f7ff ffa5 	bl	8004b58 <usbStartTransmitI>
}
 8004c0e:	b002      	add	sp, #8
 8004c10:	bd10      	pop	{r4, pc}
	...

08004c14 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8004c14:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheck(dmastp != NULL);
 8004c16:	b910      	cbnz	r0, 8004c1e <dmaStreamRelease+0xa>
 8004c18:	f7ff fed4 	bl	80049c4 <vTaskEndScheduler>
 8004c1c:	e7fe      	b.n	8004c1c <dmaStreamRelease+0x8>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
 8004c1e:	2501      	movs	r5, #1
 8004c20:	4a15      	ldr	r2, [pc, #84]	; (8004c78 <dmaStreamRelease+0x64>)
 8004c22:	7c46      	ldrb	r6, [r0, #17]
 8004c24:	6813      	ldr	r3, [r2, #0]
 8004c26:	fa05 f106 	lsl.w	r1, r5, r6
 8004c2a:	4219      	tst	r1, r3
 8004c2c:	d102      	bne.n	8004c34 <dmaStreamRelease+0x20>
 8004c2e:	f7ff fec9 	bl	80049c4 <vTaskEndScheduler>
 8004c32:	e7fe      	b.n	8004c32 <dmaStreamRelease+0x1e>
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004c34:	ea23 0301 	bic.w	r3, r3, r1

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004c38:	6881      	ldr	r1, [r0, #8]
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004c3a:	6013      	str	r3, [r2, #0]
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004c3c:	ea13 0401 	ands.w	r4, r3, r1
 8004c40:	d10b      	bne.n	8004c5a <dmaStreamRelease+0x46>
    nvicDisableVector(dmastp->vector);
 8004c42:	7c82      	ldrb	r2, [r0, #18]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8004c44:	f002 011f 	and.w	r1, r2, #31
 8004c48:	408d      	lsls	r5, r1
 8004c4a:	0950      	lsrs	r0, r2, #5
 8004c4c:	490b      	ldr	r1, [pc, #44]	; (8004c7c <dmaStreamRelease+0x68>)
 8004c4e:	3020      	adds	r0, #32
 8004c50:	f841 5020 	str.w	r5, [r1, r0, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8004c54:	4411      	add	r1, r2
 8004c56:	f881 4300 	strb.w	r4, [r1, #768]	; 0x300
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004c5a:	2100      	movs	r1, #0
 8004c5c:	4a08      	ldr	r2, [pc, #32]	; (8004c80 <dmaStreamRelease+0x6c>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8004c5e:	065b      	lsls	r3, r3, #25
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004c60:	f842 1036 	str.w	r1, [r2, r6, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8004c64:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8004c68:	6051      	str	r1, [r2, #4]
    rccDisableDMA1(false);
 8004c6a:	bf01      	itttt	eq
 8004c6c:	4a05      	ldreq	r2, [pc, #20]	; (8004c84 <dmaStreamRelease+0x70>)
 8004c6e:	6953      	ldreq	r3, [r2, #20]
 8004c70:	f023 0301 	biceq.w	r3, r3, #1
 8004c74:	6153      	streq	r3, [r2, #20]
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
    rccDisableDMA2(false);
  }
#endif
}
 8004c76:	bd70      	pop	{r4, r5, r6, pc}
 8004c78:	20001044 	.word	0x20001044
 8004c7c:	e000e100 	.word	0xe000e100
 8004c80:	20000fe8 	.word	0x20000fe8
 8004c84:	40021000 	.word	0x40021000

08004c88 <i2c_lld_serve_tx_end_irq>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004c88:	b508      	push	{r3, lr}
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004c8a:	070b      	lsls	r3, r1, #28
 8004c8c:	d502      	bpl.n	8004c94 <i2c_lld_serve_tx_end_irq+0xc>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8004c8e:	f7ff fe99 	bl	80049c4 <vTaskEndScheduler>
 8004c92:	e7fe      	b.n	8004c92 <i2c_lld_serve_tx_end_irq+0xa>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8004c94:	e9d0 311d 	ldrd	r3, r1, [r0, #116]	; 0x74
 8004c98:	6858      	ldr	r0, [r3, #4]
 8004c9a:	6802      	ldr	r2, [r0, #0]
 8004c9c:	f022 020f 	bic.w	r2, r2, #15
 8004ca0:	6002      	str	r2, [r0, #0]
 8004ca2:	7c18      	ldrb	r0, [r3, #16]
 8004ca4:	681a      	ldr	r2, [r3, #0]
 8004ca6:	230e      	movs	r3, #14
 8004ca8:	4083      	lsls	r3, r0
 8004caa:	6053      	str	r3, [r2, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8004cac:	684b      	ldr	r3, [r1, #4]
 8004cae:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8004cb2:	604b      	str	r3, [r1, #4]
}
 8004cb4:	bd08      	pop	{r3, pc}

08004cb6 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004cb6:	b508      	push	{r3, lr}

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004cb8:	070b      	lsls	r3, r1, #28
 8004cba:	d502      	bpl.n	8004cc2 <spi_lld_serve_tx_interrupt+0xc>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8004cbc:	f7ff fe82 	bl	80049c4 <vTaskEndScheduler>
 8004cc0:	e7fe      	b.n	8004cc0 <spi_lld_serve_tx_interrupt+0xa>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 8004cc2:	bd08      	pop	{r3, pc}

08004cc4 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8004cc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8004cc6:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8004cca:	68de      	ldr	r6, [r3, #12]
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8004ccc:	6833      	ldr	r3, [r6, #0]
 8004cce:	f003 0303 	and.w	r3, r3, #3
 8004cd2:	2b02      	cmp	r3, #2
 8004cd4:	d006      	beq.n	8004ce4 <usb_lld_init_endpoint+0x20>
 8004cd6:	2b03      	cmp	r3, #3
 8004cd8:	d022      	beq.n	8004d20 <usb_lld_init_endpoint+0x5c>
 8004cda:	2b01      	cmp	r3, #1
 8004cdc:	d123      	bne.n	8004d26 <usb_lld_init_endpoint+0x62>
    osalDbgAssert(false, "isochronous support disabled");
 8004cde:	f7ff fe71 	bl	80049c4 <vTaskEndScheduler>
 8004ce2:	e7fe      	b.n	8004ce2 <usb_lld_init_endpoint+0x1e>
    epr = EPR_EP_TYPE_BULK;
 8004ce4:	2200      	movs	r2, #0
  dp = USB_GET_DESCRIPTOR(ep);
 8004ce6:	4b33      	ldr	r3, [pc, #204]	; (8004db4 <usb_lld_init_endpoint+0xf0>)
 8004ce8:	ea4f 1c01 	mov.w	ip, r1, lsl #4
 8004cec:	6d1c      	ldr	r4, [r3, #80]	; 0x50
  if (epcp->in_state != NULL) {
 8004cee:	6973      	ldr	r3, [r6, #20]
  dp = USB_GET_DESCRIPTOR(ep);
 8004cf0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8004cf4:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
 8004cf8:	eb04 1501 	add.w	r5, r4, r1, lsl #4
  if (epcp->in_state != NULL) {
 8004cfc:	b1d3      	cbz	r3, 8004d34 <usb_lld_init_endpoint+0x70>
    dp->TXCOUNT0 = 0;
 8004cfe:	2300      	movs	r3, #0
 8004d00:	606b      	str	r3, [r5, #4]
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8004d02:	8a33      	ldrh	r3, [r6, #16]
  next = usbp->pmnext;
 8004d04:	f8d0 7084 	ldr.w	r7, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8004d08:	3301      	adds	r3, #1
 8004d0a:	f023 0301 	bic.w	r3, r3, #1
 8004d0e:	443b      	add	r3, r7
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d10:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  usbp->pmnext += (size + 1) & ~1;
 8004d14:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d18:	d908      	bls.n	8004d2c <usb_lld_init_endpoint+0x68>
 8004d1a:	f7ff fe53 	bl	80049c4 <vTaskEndScheduler>
 8004d1e:	e7fe      	b.n	8004d1e <usb_lld_init_endpoint+0x5a>
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8004d20:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8004d24:	e7df      	b.n	8004ce6 <usb_lld_init_endpoint+0x22>
    epr = EPR_EP_TYPE_CONTROL;
 8004d26:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004d2a:	e7dc      	b.n	8004ce6 <usb_lld_init_endpoint+0x22>
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8004d2c:	f84c 7004 	str.w	r7, [ip, r4]
    epr |= EPR_STAT_TX_NAK;
 8004d30:	f042 0220 	orr.w	r2, r2, #32
  if (epcp->out_state != NULL) {
 8004d34:	69b3      	ldr	r3, [r6, #24]
 8004d36:	b32b      	cbz	r3, 8004d84 <usb_lld_init_endpoint+0xc0>
    if (epcp->out_maxsize > 62)
 8004d38:	8a74      	ldrh	r4, [r6, #18]
 8004d3a:	2c3e      	cmp	r4, #62	; 0x3e
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8004d3c:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
    if (epcp->out_maxsize > 62)
 8004d40:	d916      	bls.n	8004d70 <usb_lld_init_endpoint+0xac>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8004d42:	f043 031f 	orr.w	r3, r3, #31
 8004d46:	4e1c      	ldr	r6, [pc, #112]	; (8004db8 <usb_lld_init_endpoint+0xf4>)
 8004d48:	3301      	adds	r3, #1
 8004d4a:	115b      	asrs	r3, r3, #5
 8004d4c:	ea46 2383 	orr.w	r3, r6, r3, lsl #10
 8004d50:	b29b      	uxth	r3, r3
    dp->RXCOUNT0 = nblocks;
 8004d52:	60eb      	str	r3, [r5, #12]
  usbp->pmnext += (size + 1) & ~1;
 8004d54:	3401      	adds	r4, #1
  next = usbp->pmnext;
 8004d56:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8004d5a:	f024 0401 	bic.w	r4, r4, #1
 8004d5e:	441c      	add	r4, r3
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d60:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  usbp->pmnext += (size + 1) & ~1;
 8004d64:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d68:	d909      	bls.n	8004d7e <usb_lld_init_endpoint+0xba>
 8004d6a:	f7ff fe2b 	bl	80049c4 <vTaskEndScheduler>
 8004d6e:	e7fe      	b.n	8004d6e <usb_lld_init_endpoint+0xaa>
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 8004d70:	f043 0301 	orr.w	r3, r3, #1
 8004d74:	3301      	adds	r3, #1
 8004d76:	025b      	lsls	r3, r3, #9
 8004d78:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8004d7c:	e7e9      	b.n	8004d52 <usb_lld_init_endpoint+0x8e>
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8004d7e:	60ab      	str	r3, [r5, #8]
    epr |= EPR_STAT_RX_NAK;
 8004d80:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  EPR_SET(ep, epr | ep);
 8004d84:	f248 0480 	movw	r4, #32896	; 0x8080
  EPR_TOGGLE(ep, epr);
 8004d88:	f647 0370 	movw	r3, #30832	; 0x7870
  EPR_SET(ep, epr | ep);
 8004d8c:	ea42 0001 	orr.w	r0, r2, r1
 8004d90:	f420 4078 	bic.w	r0, r0, #63488	; 0xf800
 8004d94:	0089      	lsls	r1, r1, #2
 8004d96:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8004d9a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8004d9e:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 8004da2:	4320      	orrs	r0, r4
 8004da4:	6008      	str	r0, [r1, #0]
  EPR_TOGGLE(ep, epr);
 8004da6:	6808      	ldr	r0, [r1, #0]
 8004da8:	4013      	ands	r3, r2
 8004daa:	4043      	eors	r3, r0
 8004dac:	4323      	orrs	r3, r4
 8004dae:	600b      	str	r3, [r1, #0]
}
 8004db0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004db2:	bf00      	nop
 8004db4:	40005c00 	.word	0x40005c00
 8004db8:	ffff8000 	.word	0xffff8000

08004dbc <prvTaskExitError>:
{
 8004dbc:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting == ~0UL );
 8004dbe:	4b04      	ldr	r3, [pc, #16]	; (8004dd0 <prvTaskExitError+0x14>)
 8004dc0:	681b      	ldr	r3, [r3, #0]
 8004dc2:	3301      	adds	r3, #1
 8004dc4:	d000      	beq.n	8004dc8 <prvTaskExitError+0xc>
 8004dc6:	e7fe      	b.n	8004dc6 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 8004dc8:	f7ff fdec 	bl	80049a4 <vPortEnterCritical>
 8004dcc:	e7fe      	b.n	8004dcc <prvTaskExitError+0x10>
 8004dce:	bf00      	nop
 8004dd0:	20001358 	.word	0x20001358

08004dd4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8004dd4:	4a04      	ldr	r2, [pc, #16]	; (8004de8 <vPortExitCritical+0x14>)
 8004dd6:	6813      	ldr	r3, [r2, #0]
 8004dd8:	b903      	cbnz	r3, 8004ddc <vPortExitCritical+0x8>
 8004dda:	e7fe      	b.n	8004dda <vPortExitCritical+0x6>
	uxCriticalNesting--;
 8004ddc:	3b01      	subs	r3, #1
 8004dde:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004de0:	b90b      	cbnz	r3, 8004de6 <vPortExitCritical+0x12>
	__asm volatile( "msr basepri, %0" :: "r" ( ulNewMaskValue ));
 8004de2:	f383 8811 	msr	BASEPRI, r3
	{
		vPortSetBASEPRI(0);
	}
}
 8004de6:	4770      	bx	lr
 8004de8:	20001358 	.word	0x20001358

08004dec <osalSysUnlock.lto_priv.0>:
static inline void osalSysUnlockFromISR(void)
{
    taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
}

static inline void osalSysUnlock(void){
 8004dec:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004dee:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004df2:	b12b      	cbz	r3, 8004e00 <osalSysUnlock.lto_priv.0+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004df4:	f3ef 8205 	mrs	r2, IPSR
	if( ulCurrentInterrupt == 0 )
 8004df8:	b12a      	cbz	r2, 8004e06 <osalSysUnlock.lto_priv.0+0x1a>
    osalDbgCheckClassS();
 8004dfa:	f7ff fde3 	bl	80049c4 <vTaskEndScheduler>
 8004dfe:	e7fe      	b.n	8004dfe <osalSysUnlock.lto_priv.0+0x12>
 8004e00:	f7ff fde0 	bl	80049c4 <vTaskEndScheduler>
 8004e04:	e7fe      	b.n	8004e04 <osalSysUnlock.lto_priv.0+0x18>
    UBaseType_t isIt = xYieldPending;
 8004e06:	4b12      	ldr	r3, [pc, #72]	; (8004e50 <osalSysUnlock.lto_priv.0+0x64>)
 8004e08:	6819      	ldr	r1, [r3, #0]
    xYieldPending = pdFALSE;
 8004e0a:	601a      	str	r2, [r3, #0]
    if(uxYieldPending()) taskYIELD();
 8004e0c:	b1e1      	cbz	r1, 8004e48 <osalSysUnlock.lto_priv.0+0x5c>
 8004e0e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004e12:	4a10      	ldr	r2, [pc, #64]	; (8004e54 <osalSysUnlock.lto_priv.0+0x68>)
 8004e14:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004e18:	6011      	str	r1, [r2, #0]
 8004e1a:	4a0f      	ldr	r2, [pc, #60]	; (8004e58 <osalSysUnlock.lto_priv.0+0x6c>)
 8004e1c:	6812      	ldr	r2, [r2, #0]
 8004e1e:	b14a      	cbz	r2, 8004e34 <osalSysUnlock.lto_priv.0+0x48>
 8004e20:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004e24:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004e28:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004e2c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004e30:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004e34:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004e38:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004e3c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004e40:	f3bf 8f4f 	dsb	sy
 8004e44:	f3bf 8f6f 	isb	sy
    osalOsRescheduleS();
    taskEXIT_CRITICAL();
}
 8004e48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    taskEXIT_CRITICAL();
 8004e4c:	f7ff bfc2 	b.w	8004dd4 <vPortExitCritical>
 8004e50:	2000164c 	.word	0x2000164c
 8004e54:	2000134c 	.word	0x2000134c
 8004e58:	20001358 	.word	0x20001358

08004e5c <monitorKick>:
    xTaskCreate(taskPeriodicMon, "Monitor", stackSize, NULL, 1, &monThreadHandle );
}

void monitorKick(MonitorEntry* entry, bool active)
{
    if(entry->active == active) {
 8004e5c:	7c03      	ldrb	r3, [r0, #16]
{
 8004e5e:	b570      	push	{r4, r5, r6, lr}
    if(entry->active == active) {
 8004e60:	428b      	cmp	r3, r1
 8004e62:	d04f      	beq.n	8004f04 <monitorKick+0xa8>
        return;
    }

    entry->active = active;

    if(monThreadHandle && active) {
 8004e64:	4b28      	ldr	r3, [pc, #160]	; (8004f08 <monitorKick+0xac>)
    entry->active = active;
 8004e66:	7401      	strb	r1, [r0, #16]
    if(monThreadHandle && active) {
 8004e68:	681c      	ldr	r4, [r3, #0]
 8004e6a:	2c00      	cmp	r4, #0
 8004e6c:	d04a      	beq.n	8004f04 <monitorKick+0xa8>
 8004e6e:	2900      	cmp	r1, #0
 8004e70:	d048      	beq.n	8004f04 <monitorKick+0xa8>
		taskENTER_CRITICAL();
 8004e72:	f7ff fd97 	bl	80049a4 <vPortEnterCritical>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8004e76:	2202      	movs	r2, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8004e78:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8004e7c:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
					pxTCB->ulNotifiedValue = ulValue;
 8004e80:	2201      	movs	r2, #1
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8004e82:	4293      	cmp	r3, r2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8004e84:	b2dd      	uxtb	r5, r3
					pxTCB->ulNotifiedValue = ulValue;
 8004e86:	6622      	str	r2, [r4, #96]	; 0x60
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8004e88:	d138      	bne.n	8004efc <monitorKick+0xa0>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e8a:	1d26      	adds	r6, r4, #4
 8004e8c:	4630      	mov	r0, r6
 8004e8e:	f7ff fc0c 	bl	80046aa <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8004e92:	2014      	movs	r0, #20
 8004e94:	4a1d      	ldr	r2, [pc, #116]	; (8004f0c <monitorKick+0xb0>)
 8004e96:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004e98:	6811      	ldr	r1, [r2, #0]
 8004e9a:	409d      	lsls	r5, r3
 8004e9c:	430d      	orrs	r5, r1
 8004e9e:	6015      	str	r5, [r2, #0]
 8004ea0:	4a1b      	ldr	r2, [pc, #108]	; (8004f10 <monitorKick+0xb4>)
 8004ea2:	4631      	mov	r1, r6
 8004ea4:	fb00 2003 	mla	r0, r0, r3, r2
 8004ea8:	f7ff fbdc 	bl	8004664 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8004eac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004eae:	b103      	cbz	r3, 8004eb2 <monitorKick+0x56>
 8004eb0:	e7fe      	b.n	8004eb0 <monitorKick+0x54>
					prvResetNextTaskUnblockTime();
 8004eb2:	f7ff fc31 	bl	8004718 <prvResetNextTaskUnblockTime>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004eb6:	4b17      	ldr	r3, [pc, #92]	; (8004f14 <monitorKick+0xb8>)
 8004eb8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004eba:	681b      	ldr	r3, [r3, #0]
 8004ebc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004ebe:	429a      	cmp	r2, r3
 8004ec0:	d91c      	bls.n	8004efc <monitorKick+0xa0>
					taskYIELD_IF_USING_PREEMPTION();
 8004ec2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004ec6:	4a14      	ldr	r2, [pc, #80]	; (8004f18 <monitorKick+0xbc>)
 8004ec8:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004ecc:	6011      	str	r1, [r2, #0]
 8004ece:	4a13      	ldr	r2, [pc, #76]	; (8004f1c <monitorKick+0xc0>)
 8004ed0:	6812      	ldr	r2, [r2, #0]
 8004ed2:	b14a      	cbz	r2, 8004ee8 <monitorKick+0x8c>
 8004ed4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004ed8:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004edc:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004ee0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004ee4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004ee8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004eec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004ef0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004ef4:	f3bf 8f4f 	dsb	sy
 8004ef8:	f3bf 8f6f 	isb	sy
        xTaskNotify(monThreadHandle, 1, eSetValueWithOverwrite);
    }
}
 8004efc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		taskEXIT_CRITICAL();
 8004f00:	f7ff bf68 	b.w	8004dd4 <vPortExitCritical>
 8004f04:	bd70      	pop	{r4, r5, r6, pc}
 8004f06:	bf00      	nop
 8004f08:	200011a4 	.word	0x200011a4
 8004f0c:	20001374 	.word	0x20001374
 8004f10:	200011b8 	.word	0x200011b8
 8004f14:	200011a8 	.word	0x200011a8
 8004f18:	2000134c 	.word	0x2000134c
 8004f1c:	20001358 	.word	0x20001358

08004f20 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8004f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f24:	4604      	mov	r4, r0
	xYieldPending = pdTRUE;
 8004f26:	f04f 0801 	mov.w	r8, #1

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8004f2a:	f7ff fd3b 	bl	80049a4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8004f2e:	f890 5045 	ldrb.w	r5, [r0, #69]	; 0x45
 8004f32:	4f1b      	ldr	r7, [pc, #108]	; (8004fa0 <prvUnlockQueue+0x80>)
 8004f34:	b26d      	sxtb	r5, r5
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004f36:	f100 0624 	add.w	r6, r0, #36	; 0x24
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004f3a:	2d00      	cmp	r5, #0
 8004f3c:	dc17      	bgt.n	8004f6e <prvUnlockQueue+0x4e>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8004f3e:	23ff      	movs	r3, #255	; 0xff
 8004f40:	f04f 0801 	mov.w	r8, #1
 8004f44:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004f48:	f7ff ff44 	bl	8004dd4 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004f4c:	f7ff fd2a 	bl	80049a4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004f50:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8004f54:	4f12      	ldr	r7, [pc, #72]	; (8004fa0 <prvUnlockQueue+0x80>)
 8004f56:	b26d      	sxtb	r5, r5

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004f58:	f104 0610 	add.w	r6, r4, #16
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004f5c:	2d00      	cmp	r5, #0
 8004f5e:	dc12      	bgt.n	8004f86 <prvUnlockQueue+0x66>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004f60:	23ff      	movs	r3, #255	; 0xff
 8004f62:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8004f66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
 8004f6a:	f7ff bf33 	b.w	8004dd4 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004f6e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004f70:	2b00      	cmp	r3, #0
 8004f72:	d0e4      	beq.n	8004f3e <prvUnlockQueue+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004f74:	4630      	mov	r0, r6
 8004f76:	f7ff fc6b 	bl	8004850 <xTaskRemoveFromEventList>
 8004f7a:	b108      	cbz	r0, 8004f80 <prvUnlockQueue+0x60>
 8004f7c:	f8c7 8000 	str.w	r8, [r7]
 8004f80:	3d01      	subs	r5, #1
 8004f82:	b26d      	sxtb	r5, r5
 8004f84:	e7d9      	b.n	8004f3a <prvUnlockQueue+0x1a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004f86:	6923      	ldr	r3, [r4, #16]
 8004f88:	2b00      	cmp	r3, #0
 8004f8a:	d0e9      	beq.n	8004f60 <prvUnlockQueue+0x40>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004f8c:	4630      	mov	r0, r6
 8004f8e:	f7ff fc5f 	bl	8004850 <xTaskRemoveFromEventList>
 8004f92:	b108      	cbz	r0, 8004f98 <prvUnlockQueue+0x78>
 8004f94:	f8c7 8000 	str.w	r8, [r7]
 8004f98:	3d01      	subs	r5, #1
 8004f9a:	b26d      	sxtb	r5, r5
 8004f9c:	e7de      	b.n	8004f5c <prvUnlockQueue+0x3c>
 8004f9e:	bf00      	nop
 8004fa0:	2000164c 	.word	0x2000164c

08004fa4 <prvAddNewTaskToReadyList>:
{
 8004fa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	taskENTER_CRITICAL();
 8004fa6:	f7ff fcfd 	bl	80049a4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004faa:	4a49      	ldr	r2, [pc, #292]	; (80050d0 <prvAddNewTaskToReadyList+0x12c>)
		if( pxCurrentTCB == NULL )
 8004fac:	4f49      	ldr	r7, [pc, #292]	; (80050d4 <prvAddNewTaskToReadyList+0x130>)
		uxCurrentNumberOfTasks++;
 8004fae:	6813      	ldr	r3, [r2, #0]
{
 8004fb0:	4604      	mov	r4, r0
		uxCurrentNumberOfTasks++;
 8004fb2:	3301      	adds	r3, #1
 8004fb4:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8004fb6:	683b      	ldr	r3, [r7, #0]
 8004fb8:	4847      	ldr	r0, [pc, #284]	; (80050d8 <prvAddNewTaskToReadyList+0x134>)
 8004fba:	2b00      	cmp	r3, #0
 8004fbc:	d17d      	bne.n	80050ba <prvAddNewTaskToReadyList+0x116>
			pxCurrentTCB = pxNewTCB;
 8004fbe:	603c      	str	r4, [r7, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004fc0:	6812      	ldr	r2, [r2, #0]
 8004fc2:	2a01      	cmp	r2, #1
 8004fc4:	d13f      	bne.n	8005046 <prvAddNewTaskToReadyList+0xa2>
 8004fc6:	4602      	mov	r2, r0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004fc8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004fcc:	f04f 0c14 	mov.w	ip, #20
 8004fd0:	461d      	mov	r5, r3
 8004fd2:	f102 0108 	add.w	r1, r2, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004fd6:	e9c2 1601 	strd	r1, r6, [r2, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fda:	e9c2 1103 	strd	r1, r1, [r2, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004fde:	fb0c f103 	mul.w	r1, ip, r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004fe2:	3301      	adds	r3, #1
 8004fe4:	2b05      	cmp	r3, #5
 8004fe6:	5045      	str	r5, [r0, r1]
 8004fe8:	f102 0214 	add.w	r2, r2, #20
 8004fec:	d1f1      	bne.n	8004fd2 <prvAddNewTaskToReadyList+0x2e>
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fee:	4a3b      	ldr	r2, [pc, #236]	; (80050dc <prvAddNewTaskToReadyList+0x138>)
 8004ff0:	f102 0308 	add.w	r3, r2, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004ff4:	e9c2 3601 	strd	r3, r6, [r2, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004ff8:	e9c2 3303 	strd	r3, r3, [r2, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004ffc:	4b38      	ldr	r3, [pc, #224]	; (80050e0 <prvAddNewTaskToReadyList+0x13c>)
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004ffe:	6015      	str	r5, [r2, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005000:	f103 0108 	add.w	r1, r3, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005004:	e9c3 1601 	strd	r1, r6, [r3, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005008:	e9c3 1103 	strd	r1, r1, [r3, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800500c:	4935      	ldr	r1, [pc, #212]	; (80050e4 <prvAddNewTaskToReadyList+0x140>)
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800500e:	601d      	str	r5, [r3, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005010:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005014:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005016:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800501a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800501e:	4932      	ldr	r1, [pc, #200]	; (80050e8 <prvAddNewTaskToReadyList+0x144>)
 8005020:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005024:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005026:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800502a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800502e:	492f      	ldr	r1, [pc, #188]	; (80050ec <prvAddNewTaskToReadyList+0x148>)
 8005030:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005034:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005036:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800503a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxDelayedTaskList = &xDelayedTaskList1;
 800503e:	492c      	ldr	r1, [pc, #176]	; (80050f0 <prvAddNewTaskToReadyList+0x14c>)
 8005040:	600a      	str	r2, [r1, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8005042:	4a2c      	ldr	r2, [pc, #176]	; (80050f4 <prvAddNewTaskToReadyList+0x150>)
 8005044:	6013      	str	r3, [r2, #0]
		uxTaskNumber++;
 8005046:	4a2c      	ldr	r2, [pc, #176]	; (80050f8 <prvAddNewTaskToReadyList+0x154>)
		prvAddTaskToReadyList( pxNewTCB );
 8005048:	492c      	ldr	r1, [pc, #176]	; (80050fc <prvAddNewTaskToReadyList+0x158>)
		uxTaskNumber++;
 800504a:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800504c:	680d      	ldr	r5, [r1, #0]
		uxTaskNumber++;
 800504e:	3301      	adds	r3, #1
 8005050:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8005052:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8005054:	2301      	movs	r3, #1
 8005056:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005058:	4093      	lsls	r3, r2
 800505a:	432b      	orrs	r3, r5
 800505c:	600b      	str	r3, [r1, #0]
 800505e:	2314      	movs	r3, #20
 8005060:	1d21      	adds	r1, r4, #4
 8005062:	fb03 0002 	mla	r0, r3, r2, r0
 8005066:	f7ff fafd 	bl	8004664 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800506a:	f7ff feb3 	bl	8004dd4 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800506e:	4b24      	ldr	r3, [pc, #144]	; (8005100 <prvAddNewTaskToReadyList+0x15c>)
 8005070:	681b      	ldr	r3, [r3, #0]
 8005072:	b30b      	cbz	r3, 80050b8 <prvAddNewTaskToReadyList+0x114>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8005074:	683b      	ldr	r3, [r7, #0]
 8005076:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005078:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800507a:	429a      	cmp	r2, r3
 800507c:	d21c      	bcs.n	80050b8 <prvAddNewTaskToReadyList+0x114>
			taskYIELD_IF_USING_PREEMPTION();
 800507e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005082:	4a20      	ldr	r2, [pc, #128]	; (8005104 <prvAddNewTaskToReadyList+0x160>)
 8005084:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005088:	6011      	str	r1, [r2, #0]
 800508a:	4a1f      	ldr	r2, [pc, #124]	; (8005108 <prvAddNewTaskToReadyList+0x164>)
 800508c:	6812      	ldr	r2, [r2, #0]
 800508e:	b14a      	cbz	r2, 80050a4 <prvAddNewTaskToReadyList+0x100>
 8005090:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005094:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8005098:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800509c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80050a0:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80050a4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80050a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80050ac:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80050b0:	f3bf 8f4f 	dsb	sy
 80050b4:	f3bf 8f6f 	isb	sy
}
 80050b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xSchedulerRunning == pdFALSE )
 80050ba:	4b11      	ldr	r3, [pc, #68]	; (8005100 <prvAddNewTaskToReadyList+0x15c>)
 80050bc:	681b      	ldr	r3, [r3, #0]
 80050be:	2b00      	cmp	r3, #0
 80050c0:	d1c1      	bne.n	8005046 <prvAddNewTaskToReadyList+0xa2>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80050c2:	683b      	ldr	r3, [r7, #0]
 80050c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80050c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80050c8:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 80050ca:	bf98      	it	ls
 80050cc:	603c      	strls	r4, [r7, #0]
 80050ce:	e7ba      	b.n	8005046 <prvAddNewTaskToReadyList+0xa2>
 80050d0:	2000135c 	.word	0x2000135c
 80050d4:	200011a8 	.word	0x200011a8
 80050d8:	200011b8 	.word	0x200011b8
 80050dc:	2000137c 	.word	0x2000137c
 80050e0:	20001390 	.word	0x20001390
 80050e4:	20001600 	.word	0x20001600
 80050e8:	20001634 	.word	0x20001634
 80050ec:	20001620 	.word	0x20001620
 80050f0:	200011ac 	.word	0x200011ac
 80050f4:	200011b4 	.word	0x200011b4
 80050f8:	20001370 	.word	0x20001370
 80050fc:	20001374 	.word	0x20001374
 8005100:	20001614 	.word	0x20001614
 8005104:	2000134c 	.word	0x2000134c
 8005108:	20001358 	.word	0x20001358

0800510c <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 800510c:	4837      	ldr	r0, [pc, #220]	; (80051ec <xTaskResumeAll+0xe0>)
{
 800510e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8005112:	6803      	ldr	r3, [r0, #0]
 8005114:	b903      	cbnz	r3, 8005118 <xTaskResumeAll+0xc>
 8005116:	e7fe      	b.n	8005116 <xTaskResumeAll+0xa>
	taskENTER_CRITICAL();
 8005118:	f7ff fc44 	bl	80049a4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800511c:	6803      	ldr	r3, [r0, #0]
 800511e:	3b01      	subs	r3, #1
 8005120:	6003      	str	r3, [r0, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005122:	6804      	ldr	r4, [r0, #0]
 8005124:	b124      	cbz	r4, 8005130 <xTaskResumeAll+0x24>
BaseType_t xAlreadyYielded = pdFALSE;
 8005126:	2000      	movs	r0, #0
	taskEXIT_CRITICAL();
 8005128:	f7ff fe54 	bl	8004dd4 <vPortExitCritical>
}
 800512c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8005130:	4b2f      	ldr	r3, [pc, #188]	; (80051f0 <xTaskResumeAll+0xe4>)
 8005132:	681b      	ldr	r3, [r3, #0]
 8005134:	2b00      	cmp	r3, #0
 8005136:	d0f6      	beq.n	8005126 <xTaskResumeAll+0x1a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8005138:	4d2e      	ldr	r5, [pc, #184]	; (80051f4 <xTaskResumeAll+0xe8>)
					prvAddTaskToReadyList( pxTCB );
 800513a:	4e2f      	ldr	r6, [pc, #188]	; (80051f8 <xTaskResumeAll+0xec>)
 800513c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80051fc <xTaskResumeAll+0xf0>
 8005140:	e01f      	b.n	8005182 <xTaskResumeAll+0x76>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005142:	68eb      	ldr	r3, [r5, #12]
					prvAddTaskToReadyList( pxTCB );
 8005144:	2701      	movs	r7, #1
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005146:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005148:	f104 0904 	add.w	r9, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800514c:	f104 0018 	add.w	r0, r4, #24
 8005150:	f7ff faab 	bl	80046aa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005154:	4648      	mov	r0, r9
 8005156:	f7ff faa8 	bl	80046aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800515a:	2014      	movs	r0, #20
 800515c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800515e:	6831      	ldr	r1, [r6, #0]
 8005160:	fa07 f302 	lsl.w	r3, r7, r2
 8005164:	430b      	orrs	r3, r1
 8005166:	fb00 8002 	mla	r0, r0, r2, r8
 800516a:	4649      	mov	r1, r9
 800516c:	6033      	str	r3, [r6, #0]
 800516e:	f7ff fa79 	bl	8004664 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005172:	4b23      	ldr	r3, [pc, #140]	; (8005200 <xTaskResumeAll+0xf4>)
 8005174:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005176:	681b      	ldr	r3, [r3, #0]
 8005178:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800517a:	429a      	cmp	r2, r3
 800517c:	d301      	bcc.n	8005182 <xTaskResumeAll+0x76>
						xYieldPending = pdTRUE;
 800517e:	4b21      	ldr	r3, [pc, #132]	; (8005204 <xTaskResumeAll+0xf8>)
 8005180:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8005182:	682b      	ldr	r3, [r5, #0]
 8005184:	2b00      	cmp	r3, #0
 8005186:	d1dc      	bne.n	8005142 <xTaskResumeAll+0x36>
				if( pxTCB != NULL )
 8005188:	b10c      	cbz	r4, 800518e <xTaskResumeAll+0x82>
					prvResetNextTaskUnblockTime();
 800518a:	f7ff fac5 	bl	8004718 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800518e:	4d1e      	ldr	r5, [pc, #120]	; (8005208 <xTaskResumeAll+0xfc>)
 8005190:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8005192:	b144      	cbz	r4, 80051a6 <xTaskResumeAll+0x9a>
								xYieldPending = pdTRUE;
 8005194:	2701      	movs	r7, #1
 8005196:	4e1b      	ldr	r6, [pc, #108]	; (8005204 <xTaskResumeAll+0xf8>)
							if( xTaskIncrementTick() != pdFALSE )
 8005198:	f7ff fad0 	bl	800473c <xTaskIncrementTick>
 800519c:	b100      	cbz	r0, 80051a0 <xTaskResumeAll+0x94>
								xYieldPending = pdTRUE;
 800519e:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80051a0:	3c01      	subs	r4, #1
 80051a2:	d1f9      	bne.n	8005198 <xTaskResumeAll+0x8c>
						uxPendedTicks = 0;
 80051a4:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 80051a6:	4b17      	ldr	r3, [pc, #92]	; (8005204 <xTaskResumeAll+0xf8>)
 80051a8:	681b      	ldr	r3, [r3, #0]
 80051aa:	2b00      	cmp	r3, #0
 80051ac:	d0bb      	beq.n	8005126 <xTaskResumeAll+0x1a>
					taskYIELD_IF_USING_PREEMPTION();
 80051ae:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80051b2:	4a16      	ldr	r2, [pc, #88]	; (800520c <xTaskResumeAll+0x100>)
 80051b4:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80051b8:	6011      	str	r1, [r2, #0]
 80051ba:	4a15      	ldr	r2, [pc, #84]	; (8005210 <xTaskResumeAll+0x104>)
 80051bc:	6812      	ldr	r2, [r2, #0]
 80051be:	b14a      	cbz	r2, 80051d4 <xTaskResumeAll+0xc8>
 80051c0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80051c4:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80051c8:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80051cc:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80051d0:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80051d4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80051d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80051dc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80051e0:	f3bf 8f4f 	dsb	sy
 80051e4:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 80051e8:	2001      	movs	r0, #1
 80051ea:	e79d      	b.n	8005128 <xTaskResumeAll+0x1c>
 80051ec:	2000136c 	.word	0x2000136c
 80051f0:	2000135c 	.word	0x2000135c
 80051f4:	20001600 	.word	0x20001600
 80051f8:	20001374 	.word	0x20001374
 80051fc:	200011b8 	.word	0x200011b8
 8005200:	200011a8 	.word	0x200011a8
 8005204:	2000164c 	.word	0x2000164c
 8005208:	20001364 	.word	0x20001364
 800520c:	2000134c 	.word	0x2000134c
 8005210:	20001358 	.word	0x20001358

08005214 <pvPortMalloc>:
		if( pxEnd == NULL )
 8005214:	4938      	ldr	r1, [pc, #224]	; (80052f8 <pvPortMalloc+0xe4>)
{
 8005216:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	vTaskSuspendAll();
 800521a:	f7ff fa57 	bl	80046cc <vTaskSuspendAll>
		if( pxEnd == NULL )
 800521e:	680b      	ldr	r3, [r1, #0]
{
 8005220:	4604      	mov	r4, r0
 8005222:	4d36      	ldr	r5, [pc, #216]	; (80052fc <pvPortMalloc+0xe8>)
		if( pxEnd == NULL )
 8005224:	b9f3      	cbnz	r3, 8005264 <pvPortMalloc+0x50>
	xStart.xBlockSize = ( size_t ) 0;
 8005226:	2000      	movs	r0, #0
size_t xTotalHeapSize = __heap_end__ - __heap_base__;
 8005228:	4b35      	ldr	r3, [pc, #212]	; (8005300 <pvPortMalloc+0xec>)
 800522a:	4a36      	ldr	r2, [pc, #216]	; (8005304 <pvPortMalloc+0xf0>)
 800522c:	f1a3 0708 	sub.w	r7, r3, #8
 8005230:	1ad2      	subs	r2, r2, r3
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005232:	075e      	lsls	r6, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005234:	bf18      	it	ne
 8005236:	3307      	addne	r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005238:	4e33      	ldr	r6, [pc, #204]	; (8005308 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
 800523a:	443a      	add	r2, r7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800523c:	bf18      	it	ne
 800523e:	f023 0307 	bicne.w	r3, r3, #7
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005242:	f022 0207 	bic.w	r2, r2, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005246:	6033      	str	r3, [r6, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8005248:	6070      	str	r0, [r6, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800524a:	e9c2 0000 	strd	r0, r0, [r2]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800524e:	1ad0      	subs	r0, r2, r3
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005250:	e9c3 2000 	strd	r2, r0, [r3]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005254:	4b2d      	ldr	r3, [pc, #180]	; (800530c <pvPortMalloc+0xf8>)
	pxEnd = ( void * ) uxAddress;
 8005256:	600a      	str	r2, [r1, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005258:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800525a:	4b2d      	ldr	r3, [pc, #180]	; (8005310 <pvPortMalloc+0xfc>)
 800525c:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800525e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8005262:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005264:	682f      	ldr	r7, [r5, #0]
 8005266:	4227      	tst	r7, r4
 8005268:	d140      	bne.n	80052ec <pvPortMalloc+0xd8>
			if( xWantedSize > 0 )
 800526a:	2c00      	cmp	r4, #0
 800526c:	d039      	beq.n	80052e2 <pvPortMalloc+0xce>
				xWantedSize += xHeapStructSize;
 800526e:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8005272:	0760      	lsls	r0, r4, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005274:	bf1c      	itt	ne
 8005276:	f023 0307 	bicne.w	r3, r3, #7
 800527a:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800527c:	2b00      	cmp	r3, #0
 800527e:	d035      	beq.n	80052ec <pvPortMalloc+0xd8>
 8005280:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8005310 <pvPortMalloc+0xfc>
 8005284:	f8d8 6000 	ldr.w	r6, [r8]
 8005288:	429e      	cmp	r6, r3
 800528a:	d32f      	bcc.n	80052ec <pvPortMalloc+0xd8>
				pxBlock = xStart.pxNextFreeBlock;
 800528c:	4a1e      	ldr	r2, [pc, #120]	; (8005308 <pvPortMalloc+0xf4>)
 800528e:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005290:	6868      	ldr	r0, [r5, #4]
 8005292:	4298      	cmp	r0, r3
 8005294:	d201      	bcs.n	800529a <pvPortMalloc+0x86>
 8005296:	682c      	ldr	r4, [r5, #0]
 8005298:	b974      	cbnz	r4, 80052b8 <pvPortMalloc+0xa4>
				if( pxBlock != pxEnd )
 800529a:	6809      	ldr	r1, [r1, #0]
 800529c:	42a9      	cmp	r1, r5
 800529e:	d025      	beq.n	80052ec <pvPortMalloc+0xd8>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80052a0:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80052a2:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80052a4:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80052a6:	1ac2      	subs	r2, r0, r3
 80052a8:	2a10      	cmp	r2, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80052aa:	f104 0408 	add.w	r4, r4, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80052ae:	d90a      	bls.n	80052c6 <pvPortMalloc+0xb2>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80052b0:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80052b2:	0741      	lsls	r1, r0, #29
 80052b4:	d003      	beq.n	80052be <pvPortMalloc+0xaa>
 80052b6:	e7fe      	b.n	80052b6 <pvPortMalloc+0xa2>
 80052b8:	462a      	mov	r2, r5
 80052ba:	4625      	mov	r5, r4
 80052bc:	e7e8      	b.n	8005290 <pvPortMalloc+0x7c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80052be:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80052c0:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80052c2:	f7ff f9ab 	bl	800461c <prvInsertBlockIntoFreeList>
					pxBlock->pxNextFreeBlock = NULL;
 80052c6:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052c8:	4910      	ldr	r1, [pc, #64]	; (800530c <pvPortMalloc+0xf8>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052ca:	686a      	ldr	r2, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052cc:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052ce:	1ab6      	subs	r6, r6, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052d0:	4286      	cmp	r6, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80052d2:	ea47 0702 	orr.w	r7, r7, r2
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052d6:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80052da:	bf38      	it	cc
 80052dc:	600e      	strcc	r6, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80052de:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80052e0:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80052e2:	f7ff ff13 	bl	800510c <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80052e6:	0763      	lsls	r3, r4, #29
 80052e8:	d002      	beq.n	80052f0 <pvPortMalloc+0xdc>
 80052ea:	e7fe      	b.n	80052ea <pvPortMalloc+0xd6>
void *pvReturn = NULL;
 80052ec:	2400      	movs	r4, #0
 80052ee:	e7f8      	b.n	80052e2 <pvPortMalloc+0xce>
}
 80052f0:	4620      	mov	r0, r4
 80052f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80052f6:	bf00      	nop
 80052f8:	200011b0 	.word	0x200011b0
 80052fc:	20001378 	.word	0x20001378
 8005300:	20001650 	.word	0x20001650
 8005304:	20005000 	.word	0x20005000
 8005308:	20001618 	.word	0x20001618
 800530c:	200015f4 	.word	0x200015f4
 8005310:	200013a4 	.word	0x200013a4

08005314 <vPortFree>:
{
 8005314:	b508      	push	{r3, lr}
	if( pv != NULL )
 8005316:	b1e8      	cbz	r0, 8005354 <vPortFree+0x40>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005318:	4a0f      	ldr	r2, [pc, #60]	; (8005358 <vPortFree+0x44>)
 800531a:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800531e:	6812      	ldr	r2, [r2, #0]
 8005320:	4213      	tst	r3, r2
 8005322:	d100      	bne.n	8005326 <vPortFree+0x12>
 8005324:	e7fe      	b.n	8005324 <vPortFree+0x10>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8005326:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800532a:	b101      	cbz	r1, 800532e <vPortFree+0x1a>
 800532c:	e7fe      	b.n	800532c <vPortFree+0x18>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800532e:	ea23 0302 	bic.w	r3, r3, r2
 8005332:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8005336:	f7ff f9c9 	bl	80046cc <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800533a:	4a08      	ldr	r2, [pc, #32]	; (800535c <vPortFree+0x48>)
 800533c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8005340:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005342:	3808      	subs	r0, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005344:	440b      	add	r3, r1
 8005346:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005348:	f7ff f968 	bl	800461c <prvInsertBlockIntoFreeList>
}
 800534c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
				( void ) xTaskResumeAll();
 8005350:	f7ff bedc 	b.w	800510c <xTaskResumeAll>
}
 8005354:	bd08      	pop	{r3, pc}
 8005356:	bf00      	nop
 8005358:	20001378 	.word	0x20001378
 800535c:	200013a4 	.word	0x200013a4

08005360 <prvDeleteTCB>:
	{
 8005360:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8005362:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
	{
 8005366:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8005368:	b93b      	cbnz	r3, 800537a <prvDeleteTCB+0x1a>
				vPortFree( pxTCB->pxStack );
 800536a:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800536c:	f7ff ffd2 	bl	8005314 <vPortFree>
				vPortFree( pxTCB );
 8005370:	4620      	mov	r0, r4
	}
 8005372:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
 8005376:	f7ff bfcd 	b.w	8005314 <vPortFree>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800537a:	2b01      	cmp	r3, #1
 800537c:	d0f9      	beq.n	8005372 <prvDeleteTCB+0x12>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800537e:	2b02      	cmp	r3, #2
 8005380:	d000      	beq.n	8005384 <prvDeleteTCB+0x24>
 8005382:	e7fe      	b.n	8005382 <prvDeleteTCB+0x22>
	}
 8005384:	bd10      	pop	{r4, pc}
	...

08005388 <vTaskDelay>:
	{
 8005388:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800538a:	b998      	cbnz	r0, 80053b4 <vTaskDelay+0x2c>
			portYIELD_WITHIN_API();
 800538c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005390:	4a14      	ldr	r2, [pc, #80]	; (80053e4 <vTaskDelay+0x5c>)
 8005392:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005396:	6011      	str	r1, [r2, #0]
 8005398:	4a13      	ldr	r2, [pc, #76]	; (80053e8 <vTaskDelay+0x60>)
 800539a:	6812      	ldr	r2, [r2, #0]
 800539c:	b9ba      	cbnz	r2, 80053ce <vTaskDelay+0x46>
 800539e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80053a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80053a6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80053aa:	f3bf 8f4f 	dsb	sy
 80053ae:	f3bf 8f6f 	isb	sy
	}
 80053b2:	e00b      	b.n	80053cc <vTaskDelay+0x44>
			configASSERT( uxSchedulerSuspended == 0 );
 80053b4:	4b0d      	ldr	r3, [pc, #52]	; (80053ec <vTaskDelay+0x64>)
 80053b6:	6819      	ldr	r1, [r3, #0]
 80053b8:	b101      	cbz	r1, 80053bc <vTaskDelay+0x34>
 80053ba:	e7fe      	b.n	80053ba <vTaskDelay+0x32>
			vTaskSuspendAll();
 80053bc:	f7ff f986 	bl	80046cc <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80053c0:	f7ff fa82 	bl	80048c8 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80053c4:	f7ff fea2 	bl	800510c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80053c8:	2800      	cmp	r0, #0
 80053ca:	d0df      	beq.n	800538c <vTaskDelay+0x4>
	}
 80053cc:	bd08      	pop	{r3, pc}
			portYIELD_WITHIN_API();
 80053ce:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80053d2:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80053d6:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80053da:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80053de:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80053e2:	e7dc      	b.n	800539e <vTaskDelay+0x16>
 80053e4:	2000134c 	.word	0x2000134c
 80053e8:	20001358 	.word	0x20001358
 80053ec:	2000136c 	.word	0x2000136c

080053f0 <xTaskCheckForTimeOut>:
{
 80053f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80053f2:	460c      	mov	r4, r1
	taskENTER_CRITICAL();
 80053f4:	f7ff fad6 	bl	80049a4 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 80053f8:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
 80053fa:	4d0f      	ldr	r5, [pc, #60]	; (8005438 <xTaskCheckForTimeOut+0x48>)
			if( *pxTicksToWait == portMAX_DELAY )
 80053fc:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 80053fe:	6829      	ldr	r1, [r5, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8005400:	d012      	beq.n	8005428 <xTaskCheckForTimeOut+0x38>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005402:	4e0e      	ldr	r6, [pc, #56]	; (800543c <xTaskCheckForTimeOut+0x4c>)
 8005404:	f8d0 c000 	ldr.w	ip, [r0]
 8005408:	6837      	ldr	r7, [r6, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800540a:	6842      	ldr	r2, [r0, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800540c:	45bc      	cmp	ip, r7
 800540e:	d001      	beq.n	8005414 <xTaskCheckForTimeOut+0x24>
 8005410:	428a      	cmp	r2, r1
 8005412:	d90f      	bls.n	8005434 <xTaskCheckForTimeOut+0x44>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8005414:	1a8f      	subs	r7, r1, r2
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005416:	42bb      	cmp	r3, r7
 8005418:	d90a      	bls.n	8005430 <xTaskCheckForTimeOut+0x40>
			*pxTicksToWait -= xElapsedTime;
 800541a:	1a5b      	subs	r3, r3, r1
 800541c:	4413      	add	r3, r2
 800541e:	6023      	str	r3, [r4, #0]
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005420:	6833      	ldr	r3, [r6, #0]
 8005422:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8005424:	682b      	ldr	r3, [r5, #0]
 8005426:	6043      	str	r3, [r0, #4]
				xReturn = pdFALSE;
 8005428:	2000      	movs	r0, #0
	taskEXIT_CRITICAL();
 800542a:	f7ff fcd3 	bl	8004dd4 <vPortExitCritical>
}
 800542e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			*pxTicksToWait = 0;
 8005430:	2300      	movs	r3, #0
 8005432:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 8005434:	2001      	movs	r0, #1
 8005436:	e7f8      	b.n	800542a <xTaskCheckForTimeOut+0x3a>
 8005438:	20001648 	.word	0x20001648
 800543c:	200015fc 	.word	0x200015fc

08005440 <xQueueSemaphoreTake>:
{
 8005440:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( ( pxQueue ) );
 8005444:	4604      	mov	r4, r0
{
 8005446:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8005448:	b900      	cbnz	r0, 800544c <xQueueSemaphoreTake+0xc>
 800544a:	e7fe      	b.n	800544a <xQueueSemaphoreTake+0xa>
	configASSERT( pxQueue->uxItemSize == 0 );
 800544c:	6c05      	ldr	r5, [r0, #64]	; 0x40
 800544e:	b105      	cbz	r5, 8005452 <xQueueSemaphoreTake+0x12>
 8005450:	e7fe      	b.n	8005450 <xQueueSemaphoreTake+0x10>
 8005452:	4628      	mov	r0, r5
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005454:	4f98      	ldr	r7, [pc, #608]	; (80056b8 <xQueueSemaphoreTake+0x278>)
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8005456:	4e99      	ldr	r6, [pc, #612]	; (80056bc <xQueueSemaphoreTake+0x27c>)
 8005458:	e073      	b.n	8005542 <xQueueSemaphoreTake+0x102>
				if( xTicksToWait == ( TickType_t ) 0 )
 800545a:	9b01      	ldr	r3, [sp, #4]
 800545c:	b91b      	cbnz	r3, 8005466 <xQueueSemaphoreTake+0x26>
						configASSERT( xInheritanceOccurred == pdFALSE );
 800545e:	2d00      	cmp	r5, #0
 8005460:	f000 8162 	beq.w	8005728 <xQueueSemaphoreTake+0x2e8>
 8005464:	e7fe      	b.n	8005464 <xQueueSemaphoreTake+0x24>
				else if( xEntryTimeSet == pdFALSE )
 8005466:	b920      	cbnz	r0, 8005472 <xQueueSemaphoreTake+0x32>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005468:	683b      	ldr	r3, [r7, #0]
 800546a:	9302      	str	r3, [sp, #8]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800546c:	4b94      	ldr	r3, [pc, #592]	; (80056c0 <xQueueSemaphoreTake+0x280>)
 800546e:	681b      	ldr	r3, [r3, #0]
 8005470:	9303      	str	r3, [sp, #12]
		taskEXIT_CRITICAL();
 8005472:	f7ff fcaf 	bl	8004dd4 <vPortExitCritical>
		vTaskSuspendAll();
 8005476:	f7ff f929 	bl	80046cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800547a:	f7ff fa93 	bl	80049a4 <vPortEnterCritical>
 800547e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005482:	a901      	add	r1, sp, #4
		prvLockQueue( pxQueue );
 8005484:	2bff      	cmp	r3, #255	; 0xff
 8005486:	bf04      	itt	eq
 8005488:	2300      	moveq	r3, #0
 800548a:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 800548e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005492:	a802      	add	r0, sp, #8
		prvLockQueue( pxQueue );
 8005494:	2bff      	cmp	r3, #255	; 0xff
 8005496:	bf04      	itt	eq
 8005498:	2300      	moveq	r3, #0
 800549a:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 800549e:	f7ff fc99 	bl	8004dd4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80054a2:	f7ff ffa5 	bl	80053f0 <xTaskCheckForTimeOut>
 80054a6:	2800      	cmp	r0, #0
 80054a8:	f040 80da 	bne.w	8005660 <xQueueSemaphoreTake+0x220>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80054ac:	f7ff fa7a 	bl	80049a4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80054b0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80054b2:	2b00      	cmp	r3, #0
 80054b4:	d13d      	bne.n	8005532 <xQueueSemaphoreTake+0xf2>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80054b6:	f7ff fc8d 	bl	8004dd4 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80054ba:	6823      	ldr	r3, [r4, #0]
 80054bc:	f8df 8204 	ldr.w	r8, [pc, #516]	; 80056c4 <xQueueSemaphoreTake+0x284>
 80054c0:	2b00      	cmp	r3, #0
 80054c2:	f040 8083 	bne.w	80055cc <xQueueSemaphoreTake+0x18c>
						taskENTER_CRITICAL();
 80054c6:	f7ff fa6d 	bl	80049a4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80054ca:	6865      	ldr	r5, [r4, #4]
		if( pxMutexHolder != NULL )
 80054cc:	2d00      	cmp	r5, #0
 80054ce:	d07a      	beq.n	80055c6 <xQueueSemaphoreTake+0x186>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80054d0:	f8d8 2000 	ldr.w	r2, [r8]
 80054d4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80054d6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80054d8:	4293      	cmp	r3, r2
 80054da:	f080 80b8 	bcs.w	800564e <xQueueSemaphoreTake+0x20e>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054de:	f04f 0914 	mov.w	r9, #20
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80054e2:	69aa      	ldr	r2, [r5, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054e4:	fb09 6303 	mla	r3, r9, r3, r6
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80054e8:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80054ea:	bfa1      	itttt	ge
 80054ec:	f8d8 2000 	ldrge.w	r2, [r8]
 80054f0:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 80054f2:	f1c2 0205 	rsbge	r2, r2, #5
 80054f6:	61aa      	strge	r2, [r5, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054f8:	696a      	ldr	r2, [r5, #20]
 80054fa:	429a      	cmp	r2, r3
 80054fc:	d15e      	bne.n	80055bc <xQueueSemaphoreTake+0x17c>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80054fe:	f105 0a04 	add.w	sl, r5, #4
 8005502:	4650      	mov	r0, sl
 8005504:	f7ff f8d1 	bl	80046aa <uxListRemove>
 8005508:	4b6f      	ldr	r3, [pc, #444]	; (80056c8 <xQueueSemaphoreTake+0x288>)
 800550a:	2800      	cmp	r0, #0
 800550c:	f000 8090 	beq.w	8005630 <xQueueSemaphoreTake+0x1f0>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005510:	f8d8 2000 	ldr.w	r2, [r8]
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8005514:	6818      	ldr	r0, [r3, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005516:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005518:	62ea      	str	r2, [r5, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800551a:	2501      	movs	r5, #1
 800551c:	fa05 f102 	lsl.w	r1, r5, r2
 8005520:	4301      	orrs	r1, r0
 8005522:	2014      	movs	r0, #20
 8005524:	6019      	str	r1, [r3, #0]
 8005526:	fb00 6002 	mla	r0, r0, r2, r6
 800552a:	4651      	mov	r1, sl
 800552c:	f7ff f89a 	bl	8004664 <vListInsertEnd>
 8005530:	e048      	b.n	80055c4 <xQueueSemaphoreTake+0x184>
				prvUnlockQueue( pxQueue );
 8005532:	4620      	mov	r0, r4
	taskEXIT_CRITICAL();
 8005534:	f7ff fc4e 	bl	8004dd4 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8005538:	f7ff fcf2 	bl	8004f20 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800553c:	f7ff fde6 	bl	800510c <xTaskResumeAll>
{
 8005540:	2001      	movs	r0, #1
		taskENTER_CRITICAL();
 8005542:	f7ff fa2f 	bl	80049a4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8005546:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8005548:	2b00      	cmp	r3, #0
 800554a:	d086      	beq.n	800545a <xQueueSemaphoreTake+0x1a>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800554c:	3b01      	subs	r3, #1
 800554e:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005550:	6823      	ldr	r3, [r4, #0]
 8005552:	b943      	cbnz	r3, 8005566 <xQueueSemaphoreTake+0x126>
		if( pxCurrentTCB != NULL )
 8005554:	4b5b      	ldr	r3, [pc, #364]	; (80056c4 <xQueueSemaphoreTake+0x284>)
 8005556:	681a      	ldr	r2, [r3, #0]
 8005558:	b11a      	cbz	r2, 8005562 <xQueueSemaphoreTake+0x122>
			( pxCurrentTCB->uxMutexesHeld )++;
 800555a:	6819      	ldr	r1, [r3, #0]
 800555c:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800555e:	3201      	adds	r2, #1
 8005560:	650a      	str	r2, [r1, #80]	; 0x50
		return pxCurrentTCB;
 8005562:	681b      	ldr	r3, [r3, #0]
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8005564:	6063      	str	r3, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005566:	6923      	ldr	r3, [r4, #16]
 8005568:	b30b      	cbz	r3, 80055ae <xQueueSemaphoreTake+0x16e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800556a:	f104 0010 	add.w	r0, r4, #16
 800556e:	f7ff f96f 	bl	8004850 <xTaskRemoveFromEventList>
 8005572:	b1e0      	cbz	r0, 80055ae <xQueueSemaphoreTake+0x16e>
						queueYIELD_IF_USING_PREEMPTION();
 8005574:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005578:	4a54      	ldr	r2, [pc, #336]	; (80056cc <xQueueSemaphoreTake+0x28c>)
 800557a:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800557e:	6011      	str	r1, [r2, #0]
 8005580:	4a53      	ldr	r2, [pc, #332]	; (80056d0 <xQueueSemaphoreTake+0x290>)
 8005582:	6812      	ldr	r2, [r2, #0]
 8005584:	b14a      	cbz	r2, 800559a <xQueueSemaphoreTake+0x15a>
 8005586:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800558a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800558e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8005592:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005596:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800559a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800559e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80055a2:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80055a6:	f3bf 8f4f 	dsb	sy
 80055aa:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80055ae:	f7ff fc11 	bl	8004dd4 <vPortExitCritical>
				return pdPASS;
 80055b2:	2501      	movs	r5, #1
}
 80055b4:	4628      	mov	r0, r5
 80055b6:	b004      	add	sp, #16
 80055b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80055bc:	f8d8 3000 	ldr.w	r3, [r8]
 80055c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80055c2:	62eb      	str	r3, [r5, #44]	; 0x2c
				xReturn = pdTRUE;
 80055c4:	2001      	movs	r0, #1
						taskEXIT_CRITICAL();
 80055c6:	f7ff fc05 	bl	8004dd4 <vPortExitCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80055ca:	4605      	mov	r5, r0
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80055cc:	f8d8 1000 	ldr.w	r1, [r8]
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80055d0:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80055d4:	3118      	adds	r1, #24
 80055d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80055da:	f7ff f84f 	bl	800467c <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80055de:	2101      	movs	r1, #1
 80055e0:	4648      	mov	r0, r9
 80055e2:	f7ff f971 	bl	80048c8 <prvAddCurrentTaskToDelayedList>
				prvUnlockQueue( pxQueue );
 80055e6:	4620      	mov	r0, r4
 80055e8:	f7ff fc9a 	bl	8004f20 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80055ec:	f7ff fd8e 	bl	800510c <xTaskResumeAll>
 80055f0:	2800      	cmp	r0, #0
 80055f2:	d1a5      	bne.n	8005540 <xQueueSemaphoreTake+0x100>
					portYIELD_WITHIN_API();
 80055f4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80055f8:	4a34      	ldr	r2, [pc, #208]	; (80056cc <xQueueSemaphoreTake+0x28c>)
 80055fa:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80055fe:	6011      	str	r1, [r2, #0]
 8005600:	4a33      	ldr	r2, [pc, #204]	; (80056d0 <xQueueSemaphoreTake+0x290>)
 8005602:	6812      	ldr	r2, [r2, #0]
 8005604:	b14a      	cbz	r2, 800561a <xQueueSemaphoreTake+0x1da>
 8005606:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800560a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800560e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8005612:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005616:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800561a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800561e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005622:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8005626:	f3bf 8f4f 	dsb	sy
 800562a:	f3bf 8f6f 	isb	sy
 800562e:	e787      	b.n	8005540 <xQueueSemaphoreTake+0x100>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 8005630:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8005632:	fb09 f900 	mul.w	r9, r9, r0
 8005636:	f856 2009 	ldr.w	r2, [r6, r9]
 800563a:	2a00      	cmp	r2, #0
 800563c:	f47f af68 	bne.w	8005510 <xQueueSemaphoreTake+0xd0>
 8005640:	2101      	movs	r1, #1
 8005642:	681a      	ldr	r2, [r3, #0]
 8005644:	4081      	lsls	r1, r0
 8005646:	ea22 0201 	bic.w	r2, r2, r1
 800564a:	601a      	str	r2, [r3, #0]
 800564c:	e760      	b.n	8005510 <xQueueSemaphoreTake+0xd0>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 800564e:	f8d8 3000 	ldr.w	r3, [r8]
 8005652:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 8005654:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005656:	4298      	cmp	r0, r3
 8005658:	bf2c      	ite	cs
 800565a:	2000      	movcs	r0, #0
 800565c:	2001      	movcc	r0, #1
 800565e:	e7b2      	b.n	80055c6 <xQueueSemaphoreTake+0x186>
			prvUnlockQueue( pxQueue );
 8005660:	4620      	mov	r0, r4
 8005662:	f7ff fc5d 	bl	8004f20 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005666:	f7ff fd51 	bl	800510c <xTaskResumeAll>
	taskENTER_CRITICAL();
 800566a:	f7ff f99b 	bl	80049a4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800566e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005670:	b113      	cbz	r3, 8005678 <xQueueSemaphoreTake+0x238>
	taskEXIT_CRITICAL();
 8005672:	f7ff fbaf 	bl	8004dd4 <vPortExitCritical>
 8005676:	e763      	b.n	8005540 <xQueueSemaphoreTake+0x100>
 8005678:	f7ff fbac 	bl	8004dd4 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 800567c:	2d00      	cmp	r5, #0
 800567e:	d099      	beq.n	80055b4 <xQueueSemaphoreTake+0x174>
						taskENTER_CRITICAL();
 8005680:	f7ff f990 	bl	80049a4 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 8005684:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005686:	b11b      	cbz	r3, 8005690 <xQueueSemaphoreTake+0x250>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8005688:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800568a:	681b      	ldr	r3, [r3, #0]
 800568c:	f1c3 0305 	rsb	r3, r3, #5
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 8005690:	6864      	ldr	r4, [r4, #4]
		if( pxMutexHolder != NULL )
 8005692:	2c00      	cmp	r4, #0
 8005694:	d048      	beq.n	8005728 <xQueueSemaphoreTake+0x2e8>
			configASSERT( pxTCB->uxMutexesHeld );
 8005696:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005698:	b901      	cbnz	r1, 800569c <xQueueSemaphoreTake+0x25c>
 800569a:	e7fe      	b.n	800569a <xQueueSemaphoreTake+0x25a>
 800569c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800569e:	4293      	cmp	r3, r2
 80056a0:	bf38      	it	cc
 80056a2:	4613      	movcc	r3, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
 80056a4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80056a6:	4293      	cmp	r3, r2
 80056a8:	d03e      	beq.n	8005728 <xQueueSemaphoreTake+0x2e8>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80056aa:	2901      	cmp	r1, #1
 80056ac:	d13c      	bne.n	8005728 <xQueueSemaphoreTake+0x2e8>
					configASSERT( pxTCB != pxCurrentTCB );
 80056ae:	4905      	ldr	r1, [pc, #20]	; (80056c4 <xQueueSemaphoreTake+0x284>)
 80056b0:	6809      	ldr	r1, [r1, #0]
 80056b2:	428c      	cmp	r4, r1
 80056b4:	d10e      	bne.n	80056d4 <xQueueSemaphoreTake+0x294>
 80056b6:	e7fe      	b.n	80056b6 <xQueueSemaphoreTake+0x276>
 80056b8:	200015fc 	.word	0x200015fc
 80056bc:	200011b8 	.word	0x200011b8
 80056c0:	20001648 	.word	0x20001648
 80056c4:	200011a8 	.word	0x200011a8
 80056c8:	20001374 	.word	0x20001374
 80056cc:	2000134c 	.word	0x2000134c
 80056d0:	20001358 	.word	0x20001358
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056d4:	2614      	movs	r6, #20
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80056d6:	69a1      	ldr	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056d8:	4f15      	ldr	r7, [pc, #84]	; (8005730 <xQueueSemaphoreTake+0x2f0>)
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80056da:	2900      	cmp	r1, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056dc:	fb06 7202 	mla	r2, r6, r2, r7
					pxTCB->uxPriority = uxPriorityToUse;
 80056e0:	62e3      	str	r3, [r4, #44]	; 0x2c
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80056e2:	bfa4      	itt	ge
 80056e4:	f1c3 0305 	rsbge	r3, r3, #5
 80056e8:	61a3      	strge	r3, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056ea:	6963      	ldr	r3, [r4, #20]
 80056ec:	4293      	cmp	r3, r2
 80056ee:	d11b      	bne.n	8005728 <xQueueSemaphoreTake+0x2e8>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80056f0:	f104 0804 	add.w	r8, r4, #4
 80056f4:	4640      	mov	r0, r8
 80056f6:	f7fe ffd8 	bl	80046aa <uxListRemove>
 80056fa:	4d0e      	ldr	r5, [pc, #56]	; (8005734 <xQueueSemaphoreTake+0x2f4>)
 80056fc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80056fe:	b940      	cbnz	r0, 8005712 <xQueueSemaphoreTake+0x2d2>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005700:	4356      	muls	r6, r2
 8005702:	59bb      	ldr	r3, [r7, r6]
 8005704:	b92b      	cbnz	r3, 8005712 <xQueueSemaphoreTake+0x2d2>
 8005706:	2101      	movs	r1, #1
 8005708:	682b      	ldr	r3, [r5, #0]
 800570a:	4091      	lsls	r1, r2
 800570c:	ea23 0301 	bic.w	r3, r3, r1
 8005710:	602b      	str	r3, [r5, #0]
						prvAddTaskToReadyList( pxTCB );
 8005712:	2301      	movs	r3, #1
 8005714:	2014      	movs	r0, #20
 8005716:	6829      	ldr	r1, [r5, #0]
 8005718:	4093      	lsls	r3, r2
 800571a:	430b      	orrs	r3, r1
 800571c:	fb00 7002 	mla	r0, r0, r2, r7
 8005720:	4641      	mov	r1, r8
 8005722:	602b      	str	r3, [r5, #0]
 8005724:	f7fe ff9e 	bl	8004664 <vListInsertEnd>
					taskEXIT_CRITICAL();
 8005728:	f7ff fb54 	bl	8004dd4 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800572c:	2500      	movs	r5, #0
 800572e:	e741      	b.n	80055b4 <xQueueSemaphoreTake+0x174>
 8005730:	200011b8 	.word	0x200011b8
 8005734:	20001374 	.word	0x20001374

08005738 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
 8005738:	b508      	push	{r3, lr}

  osalDbgCheck(i2cp != NULL);
 800573a:	b910      	cbnz	r0, 8005742 <i2cAcquireBus+0xa>
 800573c:	f7ff f942 	bl	80049c4 <vTaskEndScheduler>
 8005740:	e7fe      	b.n	8005740 <i2cAcquireBus+0x8>
}

static inline void osalMutexLock(mutex_t* mutex)
{
    osalDbgCheck(mutex != NULL);
    xSemaphoreTake(mutex->handle, portMAX_DELAY);
 8005742:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

  osalMutexLock(&i2cp->mutex);
}
 8005746:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800574a:	68c0      	ldr	r0, [r0, #12]
 800574c:	f7ff be78 	b.w	8005440 <xQueueSemaphoreTake>

08005750 <prvListTasksWithinSingleList>:
	{
 8005750:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 8005754:	f8d1 a000 	ldr.w	sl, [r1]
	{
 8005758:	4604      	mov	r4, r0
 800575a:	460d      	mov	r5, r1
 800575c:	4617      	mov	r7, r2
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800575e:	f1ba 0f00 	cmp.w	sl, #0
 8005762:	d040      	beq.n	80057e6 <prvListTasksWithinSingleList+0x96>
	UBaseType_t uxTask = 0;
 8005764:	f04f 0a00 	mov.w	sl, #0
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8005768:	684b      	ldr	r3, [r1, #4]
 800576a:	f101 0808 	add.w	r8, r1, #8
 800576e:	685b      	ldr	r3, [r3, #4]
 8005770:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8005810 <prvListTasksWithinSingleList+0xc0>
 8005774:	4543      	cmp	r3, r8
 8005776:	604b      	str	r3, [r1, #4]
 8005778:	bf04      	itt	eq
 800577a:	68cb      	ldreq	r3, [r1, #12]
 800577c:	604b      	streq	r3, [r1, #4]
 800577e:	684b      	ldr	r3, [r1, #4]
 8005780:	68db      	ldr	r3, [r3, #12]
 8005782:	9301      	str	r3, [sp, #4]
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8005784:	686a      	ldr	r2, [r5, #4]
 8005786:	6852      	ldr	r2, [r2, #4]
 8005788:	4590      	cmp	r8, r2
 800578a:	606a      	str	r2, [r5, #4]
 800578c:	bf04      	itt	eq
 800578e:	f8d8 2004 	ldreq.w	r2, [r8, #4]
 8005792:	606a      	streq	r2, [r5, #4]
 8005794:	686a      	ldr	r2, [r5, #4]
 8005796:	f8d2 b00c 	ldr.w	fp, [r2, #12]
		pxTCB = prvGetTCBFromHandle( xTask );
 800579a:	f1bb 0f00 	cmp.w	fp, #0
 800579e:	d126      	bne.n	80057ee <prvListTasksWithinSingleList+0x9e>
 80057a0:	f8d9 6000 	ldr.w	r6, [r9]
			pxTaskStatus->ulRunTimeCounter = 0;
 80057a4:	2300      	movs	r3, #0
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 80057a6:	f106 0034 	add.w	r0, r6, #52	; 0x34
 80057aa:	6060      	str	r0, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80057ac:	6af0      	ldr	r0, [r6, #44]	; 0x2c
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 80057ae:	6026      	str	r6, [r4, #0]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80057b0:	6120      	str	r0, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 80057b2:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80057b4:	61e0      	str	r0, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 80057b6:	6c70      	ldr	r0, [r6, #68]	; 0x44
 80057b8:	60a0      	str	r0, [r4, #8]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 80057ba:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
			pxTaskStatus->ulRunTimeCounter = 0;
 80057bc:	61a3      	str	r3, [r4, #24]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 80057be:	6160      	str	r0, [r4, #20]
			if( pxTCB == pxCurrentTCB )
 80057c0:	f8d9 0000 	ldr.w	r0, [r9]
 80057c4:	4286      	cmp	r6, r0
 80057c6:	d114      	bne.n	80057f2 <prvListTasksWithinSingleList+0xa2>
				pxTaskStatus->eCurrentState = eRunning;
 80057c8:	7323      	strb	r3, [r4, #12]
	uint32_t ulCount = 0U;
 80057ca:	2000      	movs	r0, #0
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 80057cc:	6b33      	ldr	r3, [r6, #48]	; 0x30
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80057ce:	5c1e      	ldrb	r6, [r3, r0]
 80057d0:	2ea5      	cmp	r6, #165	; 0xa5
 80057d2:	d01b      	beq.n	800580c <prvListTasksWithinSingleList+0xbc>
			} while( pxNextTCB != pxFirstTCB );
 80057d4:	9b01      	ldr	r3, [sp, #4]
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 80057d6:	0880      	lsrs	r0, r0, #2
			} while( pxNextTCB != pxFirstTCB );
 80057d8:	455b      	cmp	r3, fp
		return ( uint16_t ) ulCount;
 80057da:	8420      	strh	r0, [r4, #32]
				uxTask++;
 80057dc:	f10a 0a01 	add.w	sl, sl, #1
			} while( pxNextTCB != pxFirstTCB );
 80057e0:	f104 0424 	add.w	r4, r4, #36	; 0x24
 80057e4:	d1ce      	bne.n	8005784 <prvListTasksWithinSingleList+0x34>
	}
 80057e6:	4650      	mov	r0, sl
 80057e8:	b003      	add	sp, #12
 80057ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80057ee:	465e      	mov	r6, fp
 80057f0:	e7d8      	b.n	80057a4 <prvListTasksWithinSingleList+0x54>
					if( eState == eSuspended )
 80057f2:	2f03      	cmp	r7, #3
				pxTaskStatus->eCurrentState = eState;
 80057f4:	7327      	strb	r7, [r4, #12]
					if( eState == eSuspended )
 80057f6:	d1e8      	bne.n	80057ca <prvListTasksWithinSingleList+0x7a>
						vTaskSuspendAll();
 80057f8:	f7fe ff68 	bl	80046cc <vTaskSuspendAll>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80057fc:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 80057fe:	b110      	cbz	r0, 8005806 <prvListTasksWithinSingleList+0xb6>
								pxTaskStatus->eCurrentState = eBlocked;
 8005800:	f04f 0302 	mov.w	r3, #2
 8005804:	7323      	strb	r3, [r4, #12]
						( void ) xTaskResumeAll();
 8005806:	f7ff fc81 	bl	800510c <xTaskResumeAll>
 800580a:	e7de      	b.n	80057ca <prvListTasksWithinSingleList+0x7a>
			ulCount++;
 800580c:	3001      	adds	r0, #1
 800580e:	e7de      	b.n	80057ce <prvListTasksWithinSingleList+0x7e>
 8005810:	200011a8 	.word	0x200011a8

08005814 <ulPortEnterCriticalFromISR>:
	__asm volatile
 8005814:	f3ef 8011 	mrs	r0, BASEPRI
 8005818:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 800581c:	f383 8811 	msr	BASEPRI, r3
 8005820:	f3bf 8f6f 	isb	sy
 8005824:	f3bf 8f4f 	dsb	sy

uint32_t ulPortEnterCriticalFromISR( void )
{
	uint32_t ulBasePri = ulPortRaiseBASEPRI();
	
	uxCriticalNesting++;
 8005828:	4a02      	ldr	r2, [pc, #8]	; (8005834 <ulPortEnterCriticalFromISR+0x20>)
 800582a:	6813      	ldr	r3, [r2, #0]
 800582c:	3301      	adds	r3, #1
 800582e:	6013      	str	r3, [r2, #0]
	
	return ulBasePri;
}
 8005830:	4770      	bx	lr
 8005832:	bf00      	nop
 8005834:	20001358 	.word	0x20001358

08005838 <osalSysLockFromISR.lto_priv.0>:
{
 8005838:	b508      	push	{r3, lr}
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 800583a:	f7ff ffeb 	bl	8005814 <ulPortEnterCriticalFromISR>
 800583e:	4b01      	ldr	r3, [pc, #4]	; (8005844 <osalSysLockFromISR.lto_priv.0+0xc>)
 8005840:	6018      	str	r0, [r3, #0]
}
 8005842:	bd08      	pop	{r3, pc}
 8005844:	20001368 	.word	0x20001368

08005848 <vPortExitCriticalFromISR>:

/*-----------------------------------------------------------*/
void vPortExitCriticalFromISR( uint32_t ulBasePri )
{
	configASSERT( uxCriticalNesting );
 8005848:	4a04      	ldr	r2, [pc, #16]	; (800585c <vPortExitCriticalFromISR+0x14>)
 800584a:	6813      	ldr	r3, [r2, #0]
 800584c:	b903      	cbnz	r3, 8005850 <vPortExitCriticalFromISR+0x8>
 800584e:	e7fe      	b.n	800584e <vPortExitCriticalFromISR+0x6>
	uxCriticalNesting--;
 8005850:	3b01      	subs	r3, #1
 8005852:	6013      	str	r3, [r2, #0]
	__asm volatile( "msr basepri, %0" :: "r" ( ulNewMaskValue ));
 8005854:	f380 8811 	msr	BASEPRI, r0
	
	vPortSetBASEPRI(ulBasePri);
}
 8005858:	4770      	bx	lr
 800585a:	bf00      	nop
 800585c:	20001358 	.word	0x20001358

08005860 <osalSysUnlockFromISR.lto_priv.0>:
    taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
 8005860:	4b01      	ldr	r3, [pc, #4]	; (8005868 <osalSysUnlockFromISR.lto_priv.0+0x8>)
 8005862:	6818      	ldr	r0, [r3, #0]
 8005864:	f7ff bff0 	b.w	8005848 <vPortExitCriticalFromISR>
 8005868:	20001368 	.word	0x20001368

0800586c <sof_handler>:
/*
 * Handles the USB driver global events.
 */
uint32_t sofCounter;
static void sof_handler(USBDriver *usbp)
{
 800586c:	b513      	push	{r0, r1, r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800586e:	4c29      	ldr	r4, [pc, #164]	; (8005914 <sof_handler+0xa8>)

    (void)usbp;

    osalSysLockFromISR();
 8005870:	f7ff ffe2 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 8005874:	f8d4 1498 	ldr.w	r1, [r4, #1176]	; 0x498
 8005878:	6808      	ldr	r0, [r1, #0]
 800587a:	7803      	ldrb	r3, [r0, #0]
 800587c:	2b04      	cmp	r3, #4
 800587e:	d139      	bne.n	80058f4 <sof_handler+0x88>
 8005880:	7d23      	ldrb	r3, [r4, #20]
 8005882:	2b02      	cmp	r3, #2
 8005884:	d136      	bne.n	80058f4 <sof_handler+0x88>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8005886:	2301      	movs	r3, #1
 8005888:	790a      	ldrb	r2, [r1, #4]
 800588a:	4093      	lsls	r3, r2
 800588c:	8902      	ldrh	r2, [r0, #8]
 800588e:	4213      	tst	r3, r2
 8005890:	d130      	bne.n	80058f4 <sof_handler+0x88>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8005892:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8005896:	b31b      	cbz	r3, 80058e0 <sof_handler+0x74>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8005898:	e9d4 3218 	ldrd	r3, r2, [r4, #96]	; 0x60
 800589c:	4293      	cmp	r3, r2
 800589e:	d132      	bne.n	8005906 <sof_handler+0x9a>
 80058a0:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80058a2:	2a00      	cmp	r2, #0
 80058a4:	d02f      	beq.n	8005906 <sof_handler+0x9a>
 80058a6:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80058a8:	2a00      	cmp	r2, #0
 80058aa:	d02c      	beq.n	8005906 <sof_handler+0x9a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80058ac:	3a04      	subs	r2, #4

    if (size > 0U) {
 80058ae:	1ad2      	subs	r2, r2, r3
 80058b0:	d029      	beq.n	8005906 <sof_handler+0x9a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80058b2:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80058b4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80058b6:	4818      	ldr	r0, [pc, #96]	; (8005918 <sof_handler+0xac>)
 80058b8:	3a01      	subs	r2, #1
 80058ba:	65e2      	str	r2, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 80058bc:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80058be:	a901      	add	r1, sp, #4
 80058c0:	4413      	add	r3, r2
      if (obqp->bwrptr >= obqp->btop) {
 80058c2:	6ea2      	ldr	r2, [r4, #104]	; 0x68
      obqp->bwrptr += obqp->bsize;
 80058c4:	6623      	str	r3, [r4, #96]	; 0x60
      if (obqp->bwrptr >= obqp->btop) {
 80058c6:	4293      	cmp	r3, r2
        obqp->bwrptr = obqp->buffers;
 80058c8:	bf24      	itt	cs
 80058ca:	6f63      	ldrcs	r3, [r4, #116]	; 0x74
 80058cc:	6623      	strcs	r3, [r4, #96]	; 0x60
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80058ce:	2300      	movs	r3, #0
 80058d0:	67a3      	str	r3, [r4, #120]	; 0x78
 80058d2:	f7ff f8a9 	bl	8004a28 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
 80058d6:	4602      	mov	r2, r0
 80058d8:	b928      	cbnz	r0, 80058e6 <sof_handler+0x7a>
 80058da:	f7ff f873 	bl	80049c4 <vTaskEndScheduler>
 80058de:	e7fe      	b.n	80058de <sof_handler+0x72>
  osalDbgCheckClassI();
 80058e0:	f7ff f870 	bl	80049c4 <vTaskEndScheduler>
 80058e4:	e7fe      	b.n	80058e4 <sof_handler+0x78>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80058e6:	f8d4 0498 	ldr.w	r0, [r4, #1176]	; 0x498
 80058ea:	9b01      	ldr	r3, [sp, #4]
 80058ec:	7901      	ldrb	r1, [r0, #4]
 80058ee:	6800      	ldr	r0, [r0, #0]
 80058f0:	f7ff f932 	bl	8004b58 <usbStartTransmitI>
    sduSOFHookI(&SDU1);
    sofCounter++;
 80058f4:	4a09      	ldr	r2, [pc, #36]	; (800591c <sof_handler+0xb0>)
 80058f6:	6813      	ldr	r3, [r2, #0]
 80058f8:	3301      	adds	r3, #1
 80058fa:	6013      	str	r3, [r2, #0]
    osalSysUnlockFromISR();
}
 80058fc:	b002      	add	sp, #8
 80058fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 8005902:	f7ff bfad 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
    if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, false);
 8005906:	688b      	ldr	r3, [r1, #8]
 8005908:	2b00      	cmp	r3, #0
 800590a:	d0f3      	beq.n	80058f4 <sof_handler+0x88>
 800590c:	2100      	movs	r1, #0
 800590e:	4798      	blx	r3
 8005910:	e7f0      	b.n	80058f4 <sof_handler+0x88>
 8005912:	bf00      	nop
 8005914:	20000a44 	.word	0x20000a44
 8005918:	20000a94 	.word	0x20000a94
 800591c:	200012c8 	.word	0x200012c8

08005920 <_usb_ep0setup>:
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005920:	2300      	movs	r3, #0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8005922:	b570      	push	{r4, r5, r6, lr}
 8005924:	4604      	mov	r4, r0
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005926:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  udp = USB_GET_DESCRIPTOR(ep);
 800592a:	4bb1      	ldr	r3, [pc, #708]	; (8005bf0 <_usb_ep0setup+0x2d0>)
  usbReadSetup(usbp, ep, usbp->setup);
 800592c:	f100 0274 	add.w	r2, r0, #116	; 0x74
 8005930:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005932:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005936:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800593a:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 800593e:	689b      	ldr	r3, [r3, #8]
 8005940:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8005944:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8005948:	005b      	lsls	r3, r3, #1
 800594a:	f103 0110 	add.w	r1, r3, #16
 800594e:	4618      	mov	r0, r3
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8005950:	3304      	adds	r3, #4
 8005952:	6800      	ldr	r0, [r0, #0]
  for (n = 0; n < 4; n++) {
 8005954:	428b      	cmp	r3, r1
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8005956:	f822 0b02 	strh.w	r0, [r2], #2
  for (n = 0; n < 4; n++) {
 800595a:	d1f8      	bne.n	800594e <_usb_ep0setup+0x2e>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 800595c:	6863      	ldr	r3, [r4, #4]
 800595e:	689b      	ldr	r3, [r3, #8]
 8005960:	bb1b      	cbnz	r3, 80059aa <_usb_ep0setup+0x8a>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8005962:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8005966:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 800596a:	d040      	beq.n	80059ee <_usb_ep0setup+0xce>
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 800596c:	f248 0080 	movw	r0, #32896	; 0x8080
 8005970:	499f      	ldr	r1, [pc, #636]	; (8005bf0 <_usb_ep0setup+0x2d0>)
 8005972:	680b      	ldr	r3, [r1, #0]
 8005974:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005978:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800597c:	f083 0210 	eor.w	r2, r3, #16
 8005980:	4302      	orrs	r2, r0
 8005982:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005984:	680b      	ldr	r3, [r1, #0]
 8005986:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800598a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800598e:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8005992:	4303      	orrs	r3, r0
 8005994:	600b      	str	r3, [r1, #0]
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005996:	6863      	ldr	r3, [r4, #4]
 8005998:	681b      	ldr	r3, [r3, #0]
 800599a:	b113      	cbz	r3, 80059a2 <_usb_ep0setup+0x82>
 800599c:	2106      	movs	r1, #6
 800599e:	4620      	mov	r0, r4
 80059a0:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 80059a2:	2306      	movs	r3, #6
 80059a4:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 80059a8:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
 80059aa:	4620      	mov	r0, r4
 80059ac:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 80059ae:	2800      	cmp	r0, #0
 80059b0:	d0d7      	beq.n	8005962 <_usb_ep0setup+0x42>
  max = (size_t)get_hword(&usbp->setup[6]);
 80059b2:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
  if (usbp->ep0n > max) {
 80059b6:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80059b8:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 80059ba:	bf88      	it	hi
 80059bc:	66e3      	strhi	r3, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80059be:	f994 3074 	ldrsb.w	r3, [r4, #116]	; 0x74
    if (usbp->ep0n != 0U) {
 80059c2:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80059c4:	2b00      	cmp	r3, #0
 80059c6:	f280 815a 	bge.w	8005c7e <_usb_ep0setup+0x35e>
    if (usbp->ep0n != 0U) {
 80059ca:	2900      	cmp	r1, #0
 80059cc:	f000 814b 	beq.w	8005c66 <_usb_ep0setup+0x346>
      usbp->ep0state = USB_EP0_TX;
 80059d0:	2301      	movs	r3, #1
 80059d2:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 80059d6:	f7ff ff2f 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80059da:	e9d4 231a 	ldrd	r2, r3, [r4, #104]	; 0x68
 80059de:	2100      	movs	r1, #0
 80059e0:	4620      	mov	r0, r4
 80059e2:	f7ff f8b9 	bl	8004b58 <usbStartTransmitI>
}
 80059e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      osalSysUnlockFromISR();
 80059ea:	f7ff bf39 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
           ((uint32_t)usbp->setup[1] << 8U))) {
 80059ee:	f894 2075 	ldrb.w	r2, [r4, #117]	; 0x75
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80059f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 80059f6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80059fa:	f240 3202 	movw	r2, #770	; 0x302
 80059fe:	4293      	cmp	r3, r2
 8005a00:	f000 810d 	beq.w	8005c1e <_usb_ep0setup+0x2fe>
 8005a04:	d821      	bhi.n	8005a4a <_usb_ep0setup+0x12a>
 8005a06:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005a0a:	d048      	beq.n	8005a9e <_usb_ep0setup+0x17e>
 8005a0c:	d80d      	bhi.n	8005a2a <_usb_ep0setup+0x10a>
 8005a0e:	2b01      	cmp	r3, #1
 8005a10:	d03f      	beq.n	8005a92 <_usb_ep0setup+0x172>
 8005a12:	2b02      	cmp	r3, #2
 8005a14:	f000 80ad 	beq.w	8005b72 <_usb_ep0setup+0x252>
 8005a18:	2b00      	cmp	r3, #0
 8005a1a:	d1a7      	bne.n	800596c <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8005a1c:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8005a20:	66a2      	str	r2, [r4, #104]	; 0x68
 8005a22:	2202      	movs	r2, #2
 8005a24:	66e2      	str	r2, [r4, #108]	; 0x6c
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8005a26:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8005a28:	e7c3      	b.n	80059b2 <_usb_ep0setup+0x92>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a2a:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8005a2e:	f000 80ba 	beq.w	8005ba6 <_usb_ep0setup+0x286>
 8005a32:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005a36:	d199      	bne.n	800596c <_usb_ep0setup+0x4c>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005a38:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005a3c:	2b01      	cmp	r3, #1
 8005a3e:	d195      	bne.n	800596c <_usb_ep0setup+0x4c>
      usbp->status |= 2U;
 8005a40:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 8005a44:	f043 0302 	orr.w	r3, r3, #2
 8005a48:	e032      	b.n	8005ab0 <_usb_ep0setup+0x190>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a4a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005a4e:	d039      	beq.n	8005ac4 <_usb_ep0setup+0x1a4>
 8005a50:	d817      	bhi.n	8005a82 <_usb_ep0setup+0x162>
 8005a52:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8005a56:	d031      	beq.n	8005abc <_usb_ep0setup+0x19c>
 8005a58:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8005a5c:	d186      	bne.n	800596c <_usb_ep0setup+0x4c>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8005a5e:	6863      	ldr	r3, [r4, #4]
 8005a60:	4620      	mov	r0, r4
 8005a62:	685e      	ldr	r6, [r3, #4]
 8005a64:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8005a68:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
 8005a6c:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 8005a70:	47b0      	blx	r6
    if (dp == NULL) {
 8005a72:	2800      	cmp	r0, #0
 8005a74:	f43f af7a 	beq.w	800596c <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8005a78:	6843      	ldr	r3, [r0, #4]
 8005a7a:	66a3      	str	r3, [r4, #104]	; 0x68
 8005a7c:	6803      	ldr	r3, [r0, #0]
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005a7e:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005a80:	e01a      	b.n	8005ab8 <_usb_ep0setup+0x198>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a82:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8005a86:	d022      	beq.n	8005ace <_usb_ep0setup+0x1ae>
 8005a88:	f640 4202 	movw	r2, #3074	; 0xc02
 8005a8c:	4293      	cmp	r3, r2
 8005a8e:	f47f af6d 	bne.w	800596c <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8005a92:	4b58      	ldr	r3, [pc, #352]	; (8005bf4 <_usb_ep0setup+0x2d4>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8005a94:	66a3      	str	r3, [r4, #104]	; 0x68
 8005a96:	2302      	movs	r3, #2
 8005a98:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005a9a:	2300      	movs	r3, #0
 8005a9c:	e7c3      	b.n	8005a26 <_usb_ep0setup+0x106>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005a9e:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005aa2:	2b01      	cmp	r3, #1
 8005aa4:	f47f af62 	bne.w	800596c <_usb_ep0setup+0x4c>
      usbp->status &= ~2U;
 8005aa8:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 8005aac:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8005ab0:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
      usbp->status |= 2U;
 8005ab4:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005ab8:	6725      	str	r5, [r4, #112]	; 0x70
    return true;
 8005aba:	e77a      	b.n	80059b2 <_usb_ep0setup+0x92>
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8005abc:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
 8005ac0:	4b4d      	ldr	r3, [pc, #308]	; (8005bf8 <_usb_ep0setup+0x2d8>)
 8005ac2:	e7b0      	b.n	8005a26 <_usb_ep0setup+0x106>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005ac4:	f104 037f 	add.w	r3, r4, #127	; 0x7f
 8005ac8:	66a3      	str	r3, [r4, #104]	; 0x68
 8005aca:	2301      	movs	r3, #1
 8005acc:	e7d7      	b.n	8005a7e <_usb_ep0setup+0x15e>
    if (usbp->configuration != usbp->setup[2]) {
 8005ace:	f894 207f 	ldrb.w	r2, [r4, #127]	; 0x7f
 8005ad2:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005ad6:	429a      	cmp	r2, r3
 8005ad8:	d047      	beq.n	8005b6a <_usb_ep0setup+0x24a>
      if (usbp->state == USB_ACTIVE) {
 8005ada:	7823      	ldrb	r3, [r4, #0]
 8005adc:	2b04      	cmp	r3, #4
 8005ade:	d137      	bne.n	8005b50 <_usb_ep0setup+0x230>
        osalSysLockFromISR ();
 8005ae0:	f7ff feaa 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8005ae4:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8005ae8:	b913      	cbnz	r3, 8005af0 <_usb_ep0setup+0x1d0>
  osalDbgCheckClassI();
 8005aea:	f7fe ff6b 	bl	80049c4 <vTaskEndScheduler>
 8005aee:	e7fe      	b.n	8005aee <_usb_ep0setup+0x1ce>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8005af0:	7823      	ldrb	r3, [r4, #0]
 8005af2:	2b04      	cmp	r3, #4
 8005af4:	d002      	beq.n	8005afc <_usb_ep0setup+0x1dc>
 8005af6:	f7fe ff65 	bl	80049c4 <vTaskEndScheduler>
 8005afa:	e7fe      	b.n	8005afa <_usb_ep0setup+0x1da>
  usbp->transmitting &= 1U;
 8005afc:	68a3      	ldr	r3, [r4, #8]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005afe:	2201      	movs	r2, #1
 8005b00:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
 8005b04:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8005b06:	2300      	movs	r3, #0
 8005b08:	e9c4 3304 	strd	r3, r3, [r4, #16]
 8005b0c:	e9c4 3306 	strd	r3, r3, [r4, #24]
 8005b10:	e9c4 3308 	strd	r3, r3, [r4, #32]
 8005b14:	62a3      	str	r3, [r4, #40]	; 0x28
  usbp->pmnext = 64;
 8005b16:	2340      	movs	r3, #64	; 0x40
    EPR_TOGGLE(i, 0);
 8005b18:	f248 0080 	movw	r0, #32896	; 0x8080
  usbp->pmnext = 64;
 8005b1c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    EPR_TOGGLE(i, 0);
 8005b20:	0093      	lsls	r3, r2, #2
 8005b22:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005b26:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8005b2a:	6819      	ldr	r1, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b2c:	3201      	adds	r2, #1
    EPR_TOGGLE(i, 0);
 8005b2e:	4301      	orrs	r1, r0
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b30:	2a08      	cmp	r2, #8
    EPR_TOGGLE(i, 0);
 8005b32:	6019      	str	r1, [r3, #0]
    EPR_SET(i, 0);
 8005b34:	6018      	str	r0, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b36:	d1f3      	bne.n	8005b20 <_usb_ep0setup+0x200>
        osalSysUnlockFromISR ();
 8005b38:	f7ff fe92 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
        usbp->configuration = 0U;
 8005b3c:	2300      	movs	r3, #0
        usbp->state = USB_SELECTED;
 8005b3e:	2103      	movs	r1, #3
        usbp->configuration = 0U;
 8005b40:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8005b44:	6863      	ldr	r3, [r4, #4]
        usbp->state = USB_SELECTED;
 8005b46:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8005b48:	681b      	ldr	r3, [r3, #0]
 8005b4a:	b10b      	cbz	r3, 8005b50 <_usb_ep0setup+0x230>
 8005b4c:	4620      	mov	r0, r4
 8005b4e:	4798      	blx	r3
      if (usbp->setup[2] != 0U) {
 8005b50:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005b54:	b14b      	cbz	r3, 8005b6a <_usb_ep0setup+0x24a>
        usbp->configuration = usbp->setup[2];
 8005b56:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
 8005b5a:	2304      	movs	r3, #4
 8005b5c:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8005b5e:	6863      	ldr	r3, [r4, #4]
 8005b60:	681b      	ldr	r3, [r3, #0]
 8005b62:	b113      	cbz	r3, 8005b6a <_usb_ep0setup+0x24a>
 8005b64:	2102      	movs	r1, #2
 8005b66:	4620      	mov	r0, r4
 8005b68:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8005b6a:	2300      	movs	r3, #0
 8005b6c:	e9c4 331a 	strd	r3, r3, [r4, #104]	; 0x68
 8005b70:	e759      	b.n	8005a26 <_usb_ep0setup+0x106>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8005b72:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8005b76:	f003 020f 	and.w	r2, r3, #15
 8005b7a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005b7e:	4b1c      	ldr	r3, [pc, #112]	; (8005bf0 <_usb_ep0setup+0x2d0>)
 8005b80:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005b84:	d008      	beq.n	8005b98 <_usb_ep0setup+0x278>
 8005b86:	f013 0330 	ands.w	r3, r3, #48	; 0x30
 8005b8a:	f43f aeef 	beq.w	800596c <_usb_ep0setup+0x4c>
 8005b8e:	2b10      	cmp	r3, #16
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005b90:	bf14      	ite	ne
 8005b92:	4b1a      	ldrne	r3, [pc, #104]	; (8005bfc <_usb_ep0setup+0x2dc>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8005b94:	4b1a      	ldreq	r3, [pc, #104]	; (8005c00 <_usb_ep0setup+0x2e0>)
 8005b96:	e77d      	b.n	8005a94 <_usb_ep0setup+0x174>
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8005b98:	f413 5340 	ands.w	r3, r3, #12288	; 0x3000
 8005b9c:	f43f aee6 	beq.w	800596c <_usb_ep0setup+0x4c>
 8005ba0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005ba4:	e7f4      	b.n	8005b90 <_usb_ep0setup+0x270>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8005ba6:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005baa:	2b00      	cmp	r3, #0
 8005bac:	f47f aede 	bne.w	800596c <_usb_ep0setup+0x4c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005bb0:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8005bb4:	f012 030f 	ands.w	r3, r2, #15
 8005bb8:	d0d7      	beq.n	8005b6a <_usb_ep0setup+0x24a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005bba:	009b      	lsls	r3, r3, #2
 8005bbc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005bc0:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005bc4:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8005bc8:	681a      	ldr	r2, [r3, #0]
 8005bca:	d01b      	beq.n	8005c04 <_usb_ep0setup+0x2e4>
 8005bcc:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8005bd0:	2a30      	cmp	r2, #48	; 0x30
 8005bd2:	d0ca      	beq.n	8005b6a <_usb_ep0setup+0x24a>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8005bd4:	681a      	ldr	r2, [r3, #0]
 8005bd6:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8005bda:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005bde:	f082 0220 	eor.w	r2, r2, #32
 8005be2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8005be6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005bea:	601a      	str	r2, [r3, #0]
 8005bec:	e7bd      	b.n	8005b6a <_usb_ep0setup+0x24a>
 8005bee:	bf00      	nop
 8005bf0:	40005c00 	.word	0x40005c00
 8005bf4:	0800cd18 	.word	0x0800cd18
 8005bf8:	08003e05 	.word	0x08003e05
 8005bfc:	0800c8a4 	.word	0x0800c8a4
 8005c00:	0800ca1c 	.word	0x0800ca1c
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8005c04:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8005c08:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8005c0c:	d0ad      	beq.n	8005b6a <_usb_ep0setup+0x24a>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8005c0e:	681a      	ldr	r2, [r3, #0]
 8005c10:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8005c14:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005c18:	f442 4220 	orr.w	r2, r2, #40960	; 0xa000
 8005c1c:	e7e3      	b.n	8005be6 <_usb_ep0setup+0x2c6>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8005c1e:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005c22:	2b00      	cmp	r3, #0
 8005c24:	f47f aea2 	bne.w	800596c <_usb_ep0setup+0x4c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005c28:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 8005c2c:	f013 010f 	ands.w	r1, r3, #15
 8005c30:	d09b      	beq.n	8005b6a <_usb_ep0setup+0x24a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005c32:	4a1b      	ldr	r2, [pc, #108]	; (8005ca0 <_usb_ep0setup+0x380>)
 8005c34:	f013 0f80 	tst.w	r3, #128	; 0x80
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c38:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8005c3c:	bf15      	itete	ne
 8005c3e:	f423 43f0 	bicne.w	r3, r3, #30720	; 0x7800
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c42:	f423 4390 	biceq.w	r3, r3, #18432	; 0x4800
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c46:	f023 0340 	bicne.w	r3, r3, #64	; 0x40
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c4a:	f023 0370 	biceq.w	r3, r3, #112	; 0x70
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c4e:	bf14      	ite	ne
 8005c50:	f083 0310 	eorne.w	r3, r3, #16
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c54:	f483 5380 	eoreq.w	r3, r3, #4096	; 0x1000
 8005c58:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005c5c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005c60:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8005c64:	e781      	b.n	8005b6a <_usb_ep0setup+0x24a>
      usbp->ep0state = USB_EP0_WAITING_STS;
 8005c66:	2303      	movs	r3, #3
 8005c68:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c6c:	f7ff fde4 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8005c70:	460b      	mov	r3, r1
 8005c72:	460a      	mov	r2, r1
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005c74:	2100      	movs	r1, #0
 8005c76:	4620      	mov	r0, r4
 8005c78:	f7fe ff32 	bl	8004ae0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8005c7c:	e6b3      	b.n	80059e6 <_usb_ep0setup+0xc6>
    if (usbp->ep0n != 0U) {
 8005c7e:	b139      	cbz	r1, 8005c90 <_usb_ep0setup+0x370>
      usbp->ep0state = USB_EP0_RX;
 8005c80:	2304      	movs	r3, #4
 8005c82:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c86:	f7ff fdd7 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005c8a:	e9d4 231a 	ldrd	r2, r3, [r4, #104]	; 0x68
 8005c8e:	e7f1      	b.n	8005c74 <_usb_ep0setup+0x354>
      usbp->ep0state = USB_EP0_SENDING_STS;
 8005c90:	2305      	movs	r3, #5
 8005c92:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c96:	f7ff fdcf 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005c9a:	460b      	mov	r3, r1
 8005c9c:	460a      	mov	r2, r1
 8005c9e:	e69e      	b.n	80059de <_usb_ep0setup+0xbe>
 8005ca0:	40005c00 	.word	0x40005c00

08005ca4 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005ca4:	b510      	push	{r4, lr}
 8005ca6:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8005caa:	4604      	mov	r4, r0
 8005cac:	2b06      	cmp	r3, #6
 8005cae:	d852      	bhi.n	8005d56 <_usb_ep0in+0xb2>
 8005cb0:	e8df f003 	tbb	[pc, r3]
 8005cb4:	311d0431 	.word	0x311d0431
 8005cb8:	2c31      	.short	0x2c31
 8005cba:	34          	.byte	0x34
 8005cbb:	00          	.byte	0x00
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8005cbc:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    max = (size_t)get_hword(&usbp->setup[6]);
 8005cbe:	f8b0 207a 	ldrh.w	r2, [r0, #122]	; 0x7a
    if ((usbp->ep0n < max) &&
 8005cc2:	4293      	cmp	r3, r2
 8005cc4:	d213      	bcs.n	8005cee <_usb_ep0in+0x4a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8005cc6:	68c2      	ldr	r2, [r0, #12]
 8005cc8:	8a11      	ldrh	r1, [r2, #16]
 8005cca:	fbb3 f2f1 	udiv	r2, r3, r1
 8005cce:	fb01 3112 	mls	r1, r1, r2, r3
    if ((usbp->ep0n < max) &&
 8005cd2:	b961      	cbnz	r1, 8005cee <_usb_ep0in+0x4a>
      osalSysLockFromISR();
 8005cd4:	f7ff fdb0 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005cd8:	460b      	mov	r3, r1
 8005cda:	460a      	mov	r2, r1
 8005cdc:	4620      	mov	r0, r4
 8005cde:	f7fe ff3b 	bl	8004b58 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8005ce2:	f7ff fdbd 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8005ce6:	2302      	movs	r3, #2
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
 8005ce8:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005cec:	bd10      	pop	{r4, pc}
    usbp->ep0state = USB_EP0_WAITING_STS;
 8005cee:	2303      	movs	r3, #3
 8005cf0:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    osalSysLockFromISR();
 8005cf4:	f7ff fda0 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8005cf8:	2300      	movs	r3, #0
 8005cfa:	4620      	mov	r0, r4
 8005cfc:	461a      	mov	r2, r3
 8005cfe:	4619      	mov	r1, r3
 8005d00:	f7fe feee 	bl	8004ae0 <usbStartReceiveI>
}
 8005d04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 8005d08:	f7ff bdaa 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
    if (usbp->ep0endcb != NULL) {
 8005d0c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005d0e:	b103      	cbz	r3, 8005d12 <_usb_ep0in+0x6e>
      usbp->ep0endcb(usbp);
 8005d10:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005d12:	2300      	movs	r3, #0
 8005d14:	e7e8      	b.n	8005ce8 <_usb_ep0in+0x44>
    osalDbgAssert(false, "EP0 state machine error");
 8005d16:	f7fe fe55 	bl	80049c4 <vTaskEndScheduler>
 8005d1a:	e7fe      	b.n	8005d1a <_usb_ep0in+0x76>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005d1c:	f248 0080 	movw	r0, #32896	; 0x8080
 8005d20:	490e      	ldr	r1, [pc, #56]	; (8005d5c <_usb_ep0in+0xb8>)
 8005d22:	680b      	ldr	r3, [r1, #0]
 8005d24:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005d28:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005d2c:	f083 0210 	eor.w	r2, r3, #16
 8005d30:	4302      	orrs	r2, r0
 8005d32:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005d34:	680b      	ldr	r3, [r1, #0]
 8005d36:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005d3a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005d3e:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8005d42:	4303      	orrs	r3, r0
 8005d44:	600b      	str	r3, [r1, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005d46:	6863      	ldr	r3, [r4, #4]
 8005d48:	681b      	ldr	r3, [r3, #0]
 8005d4a:	b113      	cbz	r3, 8005d52 <_usb_ep0in+0xae>
 8005d4c:	2106      	movs	r1, #6
 8005d4e:	4620      	mov	r0, r4
 8005d50:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005d52:	2306      	movs	r3, #6
 8005d54:	e7c8      	b.n	8005ce8 <_usb_ep0in+0x44>
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005d56:	f7fe fe35 	bl	80049c4 <vTaskEndScheduler>
 8005d5a:	e7fe      	b.n	8005d5a <_usb_ep0in+0xb6>
 8005d5c:	40005c00 	.word	0x40005c00

08005d60 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8005d60:	b510      	push	{r4, lr}
 8005d62:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8005d66:	4604      	mov	r4, r0
 8005d68:	2b06      	cmp	r3, #6
 8005d6a:	d83f      	bhi.n	8005dec <_usb_ep0out+0x8c>
 8005d6c:	e8df f003 	tbb	[pc, r3]
 8005d70:	131e1e1e 	.word	0x131e1e1e
 8005d74:	1e04      	.short	0x1e04
 8005d76:	21          	.byte	0x21
 8005d77:	00          	.byte	0x00

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8005d78:	2305      	movs	r3, #5
 8005d7a:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8005d7e:	f7ff fd5b 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8005d82:	2300      	movs	r3, #0
 8005d84:	4620      	mov	r0, r4
 8005d86:	461a      	mov	r2, r3
 8005d88:	4619      	mov	r1, r3
 8005d8a:	f7fe fee5 	bl	8004b58 <usbStartTransmitI>
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005d8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 8005d92:	f7ff bd65 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8005d96:	68c3      	ldr	r3, [r0, #12]
 8005d98:	699b      	ldr	r3, [r3, #24]
 8005d9a:	685b      	ldr	r3, [r3, #4]
 8005d9c:	b92b      	cbnz	r3, 8005daa <_usb_ep0out+0x4a>
    if (usbp->ep0endcb != NULL) {
 8005d9e:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005da0:	b103      	cbz	r3, 8005da4 <_usb_ep0out+0x44>
      usbp->ep0endcb(usbp);
 8005da2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005da4:	2300      	movs	r3, #0
    usbp->ep0state = USB_EP0_ERROR;
 8005da6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8005daa:	bd10      	pop	{r4, pc}
    osalDbgAssert(false, "EP0 state machine error");
 8005dac:	f7fe fe0a 	bl	80049c4 <vTaskEndScheduler>
 8005db0:	e7fe      	b.n	8005db0 <_usb_ep0out+0x50>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005db2:	f248 0080 	movw	r0, #32896	; 0x8080
 8005db6:	490f      	ldr	r1, [pc, #60]	; (8005df4 <_usb_ep0out+0x94>)
 8005db8:	680b      	ldr	r3, [r1, #0]
 8005dba:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005dbe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005dc2:	f083 0210 	eor.w	r2, r3, #16
 8005dc6:	4302      	orrs	r2, r0
 8005dc8:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005dca:	680b      	ldr	r3, [r1, #0]
 8005dcc:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005dd0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005dd4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8005dd8:	4303      	orrs	r3, r0
 8005dda:	600b      	str	r3, [r1, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005ddc:	6863      	ldr	r3, [r4, #4]
 8005dde:	681b      	ldr	r3, [r3, #0]
 8005de0:	b113      	cbz	r3, 8005de8 <_usb_ep0out+0x88>
 8005de2:	2106      	movs	r1, #6
 8005de4:	4620      	mov	r0, r4
 8005de6:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005de8:	2306      	movs	r3, #6
 8005dea:	e7dc      	b.n	8005da6 <_usb_ep0out+0x46>
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005dec:	f7fe fdea 	bl	80049c4 <vTaskEndScheduler>
 8005df0:	e7fe      	b.n	8005df0 <_usb_ep0out+0x90>
 8005df2:	bf00      	nop
 8005df4:	40005c00 	.word	0x40005c00

08005df8 <sofNeededCallback>:
static void sofNeededCallback(USBDriver *usbp, bool enable)
{
    (void) usbp;
    static bool sofEnabled = true;

    if(!allowDisableSOF && !enable) return;
 8005df8:	4b0c      	ldr	r3, [pc, #48]	; (8005e2c <sofNeededCallback+0x34>)
{
 8005dfa:	b510      	push	{r4, lr}
    if(!allowDisableSOF && !enable) return;
 8005dfc:	781b      	ldrb	r3, [r3, #0]
 8005dfe:	b903      	cbnz	r3, 8005e02 <sofNeededCallback+0xa>
 8005e00:	b199      	cbz	r1, 8005e2a <sofNeededCallback+0x32>
    if(sofEnabled == enable) return;
 8005e02:	4c0b      	ldr	r4, [pc, #44]	; (8005e30 <sofNeededCallback+0x38>)
 8005e04:	7823      	ldrb	r3, [r4, #0]
 8005e06:	428b      	cmp	r3, r1
 8005e08:	d00f      	beq.n	8005e2a <sofNeededCallback+0x32>

    syssts_t basepri = osalSysGetStatusAndLockX();
 8005e0a:	f7ff fd03 	bl	8005814 <ulPortEnterCriticalFromISR>

    if(enable) {
 8005e0e:	4b09      	ldr	r3, [pc, #36]	; (8005e34 <sofNeededCallback+0x3c>)
        STM32_USB->CNTR |= CNTR_SOFM;
 8005e10:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if(enable) {
 8005e12:	b139      	cbz	r1, 8005e24 <sofNeededCallback+0x2c>
        STM32_USB->CNTR |= CNTR_SOFM;
 8005e14:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    } else {
        STM32_USB->CNTR &=~ CNTR_SOFM;
 8005e18:	641a      	str	r2, [r3, #64]	; 0x40
    }

    sofEnabled = enable;
 8005e1a:	7021      	strb	r1, [r4, #0]

    osalSysRestoreStatusX(basepri);
}
 8005e1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysRestoreStatusX(basepri);
 8005e20:	f7ff bd12 	b.w	8005848 <vPortExitCriticalFromISR>
        STM32_USB->CNTR &=~ CNTR_SOFM;
 8005e24:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8005e28:	e7f6      	b.n	8005e18 <sofNeededCallback+0x20>
}
 8005e2a:	bd10      	pop	{r4, pc}
 8005e2c:	20000800 	.word	0x20000800
 8005e30:	20000911 	.word	0x20000911
 8005e34:	40005c00 	.word	0x40005c00

08005e38 <gpioCPUGetPinMode>:
{
 8005e38:	b538      	push	{r3, r4, r5, lr}
 8005e3a:	4604      	mov	r4, r0
    syssts_t sts = osalSysGetStatusAndLockX();
 8005e3c:	f7ff fcea 	bl	8005814 <ulPortEnterCriticalFromISR>
    cr = (uint64_t)(((ioportid_t)driver->driver)->CRH) << 32;
 8005e40:	6823      	ldr	r3, [r4, #0]
    uint8_t config = (cr >> (4*pin)) & 0xF;
 8005e42:	0089      	lsls	r1, r1, #2
    cr = (uint64_t)(((ioportid_t)driver->driver)->CRH) << 32;
 8005e44:	685d      	ldr	r5, [r3, #4]
    cr |= ((ioportid_t)driver->driver)->CRL;
 8005e46:	681c      	ldr	r4, [r3, #0]
    osalSysRestoreStatusX(sts);
 8005e48:	f7ff fcfe 	bl	8005848 <vPortExitCriticalFromISR>
    uint8_t config = (cr >> (4*pin)) & 0xF;
 8005e4c:	f1c1 0220 	rsb	r2, r1, #32
 8005e50:	f1a1 0320 	sub.w	r3, r1, #32
 8005e54:	fa05 f202 	lsl.w	r2, r5, r2
 8005e58:	fa24 f101 	lsr.w	r1, r4, r1
 8005e5c:	fa25 f303 	lsr.w	r3, r5, r3
 8005e60:	4311      	orrs	r1, r2
 8005e62:	4319      	orrs	r1, r3
}
 8005e64:	4b02      	ldr	r3, [pc, #8]	; (8005e70 <gpioCPUGetPinMode+0x38>)
    return cfgToMode[config];
 8005e66:	f001 010f 	and.w	r1, r1, #15
}
 8005e6a:	5c58      	ldrb	r0, [r3, r1]
 8005e6c:	bd38      	pop	{r3, r4, r5, pc}
 8005e6e:	bf00      	nop
 8005e70:	0800c8c0 	.word	0x0800c8c0
	...

08005e80 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8005e80:	4b18      	ldr	r3, [pc, #96]	; (8005ee4 <pxCurrentTCBConst+0x4>)
 8005e82:	681b      	ldr	r3, [r3, #0]
 8005e84:	4818      	ldr	r0, [pc, #96]	; (8005ee8 <pxCurrentTCBConst+0x8>)
 8005e86:	461a      	mov	r2, r3
 8005e88:	6002      	str	r2, [r0, #0]
 8005e8a:	f3ef 8009 	mrs	r0, PSP
 8005e8e:	f3bf 8f6f 	isb	sy
 8005e92:	4b13      	ldr	r3, [pc, #76]	; (8005ee0 <pxCurrentTCBConst>)
 8005e94:	681a      	ldr	r2, [r3, #0]
 8005e96:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005e9a:	4c14      	ldr	r4, [pc, #80]	; (8005eec <pxCurrentTCBConst+0xc>)
 8005e9c:	6824      	ldr	r4, [r4, #0]
 8005e9e:	f3ef 8111 	mrs	r1, BASEPRI
 8005ea2:	e920 0012 	stmdb	r0!, {r1, r4}
 8005ea6:	6010      	str	r0, [r2, #0]
 8005ea8:	e92d 4008 	stmdb	sp!, {r3, lr}
 8005eac:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8005eb0:	f380 8811 	msr	BASEPRI, r0
 8005eb4:	f005 fb9a 	bl	800b5ec <vTaskSwitchContext>
 8005eb8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005ebc:	6819      	ldr	r1, [r3, #0]
 8005ebe:	6808      	ldr	r0, [r1, #0]
 8005ec0:	c812      	ldmia	r0!, {r1, r4}
 8005ec2:	f381 8811 	msr	BASEPRI, r1
 8005ec6:	4909      	ldr	r1, [pc, #36]	; (8005eec <pxCurrentTCBConst+0xc>)
 8005ec8:	600c      	str	r4, [r1, #0]
 8005eca:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005ece:	f380 8809 	msr	PSP, r0
 8005ed2:	f3bf 8f6f 	isb	sy
 8005ed6:	4770      	bx	lr
 8005ed8:	f3af 8000 	nop.w
 8005edc:	f3af 8000 	nop.w

08005ee0 <pxCurrentTCBConst>:
 8005ee0:	200011a8 	.word	0x200011a8
	"                                       \n"
	"       .align 4                        \n"
	"pxCurrentTCBConst: .word pxCurrentTCB  \n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY),"r"(ulSyspri2Value)
	);
}
 8005ee4:	2000134c 	.word	0x2000134c
 8005ee8:	e000ed20 	.word	0xe000ed20
 8005eec:	20001358 	.word	0x20001358

08005ef0 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8005ef0:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
 8005ef2:	f7fe fd57 	bl	80049a4 <vPortEnterCritical>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8005ef6:	f7fe fc21 	bl	800473c <xTaskIncrementTick>
 8005efa:	b148      	cbz	r0, 8005f10 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
            ulSyspri2Value = portNVIC_SYSPRI2_REG;
 8005efc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005f00:	4a05      	ldr	r2, [pc, #20]	; (8005f18 <xPortSysTickHandler+0x28>)
 8005f02:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005f06:	6011      	str	r1, [r2, #0]
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005f08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005f0c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
		}
	}
	portENABLE_INTERRUPTS();
}
 8005f10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	portENABLE_INTERRUPTS();
 8005f14:	f7fe bf5e 	b.w	8004dd4 <vPortExitCritical>
 8005f18:	2000134c 	.word	0x2000134c

08005f1c <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8005f1c:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8005f20:	2b0f      	cmp	r3, #15
 8005f22:	d906      	bls.n	8005f32 <vPortValidateInterruptPriority+0x16>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8005f24:	4a09      	ldr	r2, [pc, #36]	; (8005f4c <vPortValidateInterruptPriority+0x30>)
 8005f26:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005f28:	4a09      	ldr	r2, [pc, #36]	; (8005f50 <vPortValidateInterruptPriority+0x34>)
 8005f2a:	7812      	ldrb	r2, [r2, #0]
 8005f2c:	429a      	cmp	r2, r3
 8005f2e:	d900      	bls.n	8005f32 <vPortValidateInterruptPriority+0x16>
 8005f30:	e7fe      	b.n	8005f30 <vPortValidateInterruptPriority+0x14>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005f32:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005f36:	4a07      	ldr	r2, [pc, #28]	; (8005f54 <vPortValidateInterruptPriority+0x38>)
 8005f38:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 8005f3c:	6812      	ldr	r2, [r2, #0]
 8005f3e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005f42:	4293      	cmp	r3, r2
 8005f44:	d900      	bls.n	8005f48 <vPortValidateInterruptPriority+0x2c>
 8005f46:	e7fe      	b.n	8005f46 <vPortValidateInterruptPriority+0x2a>
	}
 8005f48:	4770      	bx	lr
 8005f4a:	bf00      	nop
 8005f4c:	e000e3f0 	.word	0xe000e3f0
 8005f50:	20001340 	.word	0x20001340
 8005f54:	20001344 	.word	0x20001344

08005f58 <vPortBusyDelay>:
	/* In my case, each loop takes 8 cycles. This depends on many things, such
	 * as the number of flash wait states. You need to adjust this if you need
	 * an accurate polled delay (rarely needed) */
	cycles /= configPORT_BUSY_DELAY_SCALE;
	
	__asm volatile
 8005f58:	2300      	movs	r3, #0
	cycles /= configPORT_BUSY_DELAY_SCALE;
 8005f5a:	08c0      	lsrs	r0, r0, #3

08005f5c <loop9410>:
	__asm volatile
 8005f5c:	4283      	cmp	r3, r0
 8005f5e:	d001      	beq.n	8005f64 <done9410>
 8005f60:	3301      	adds	r3, #1
 8005f62:	e7fb      	b.n	8005f5c <loop9410>

08005f64 <done9410>:
		"       adds %0, 1           \n"
		"       b loop%=             \n"
		"done%=:                     \n"
		:"+r"(i): "r"(cycles)
	);
}
 8005f64:	4770      	bx	lr
	...

08005f68 <packetQueueReadByte.constprop.0>:

#include "packetqueue.h"

static uint8_t packetQueueReadByte(PacketQueue_t* queue)
{
    uint8_t retVal = queue->buffer[queue->readPtr];
 8005f68:	4b05      	ldr	r3, [pc, #20]	; (8005f80 <packetQueueReadByte.constprop.0+0x18>)
 8005f6a:	689a      	ldr	r2, [r3, #8]
 8005f6c:	6819      	ldr	r1, [r3, #0]
 8005f6e:	5c88      	ldrb	r0, [r1, r2]

    queue->readPtr++;
    if(queue->readPtr >= queue->bufferSize) {
 8005f70:	6859      	ldr	r1, [r3, #4]
    queue->readPtr++;
 8005f72:	3201      	adds	r2, #1
    if(queue->readPtr >= queue->bufferSize) {
 8005f74:	428a      	cmp	r2, r1
    queue->readPtr++;
 8005f76:	609a      	str	r2, [r3, #8]
        queue->readPtr = 0;
 8005f78:	bf24      	itt	cs
 8005f7a:	2200      	movcs	r2, #0
 8005f7c:	609a      	strcs	r2, [r3, #8]
    }

    return retVal;
}
 8005f7e:	4770      	bx	lr
 8005f80:	20001310 	.word	0x20001310

08005f84 <packetQueueWriteByte.constprop.0>:

static void packetQueueWriteByte(PacketQueue_t* queue, uint8_t byte)
 8005f84:	b570      	push	{r4, r5, r6, lr}
{
    if(queue->pktCount && queue->writePtr == queue->readPtr) {
 8005f86:	4c15      	ldr	r4, [pc, #84]	; (8005fdc <packetQueueWriteByte.constprop.0+0x58>)
static void packetQueueWriteByte(PacketQueue_t* queue, uint8_t byte)
 8005f88:	4605      	mov	r5, r0
    if(queue->pktCount && queue->writePtr == queue->readPtr) {
 8005f8a:	8aa3      	ldrh	r3, [r4, #20]
 8005f8c:	b1cb      	cbz	r3, 8005fc2 <packetQueueWriteByte.constprop.0+0x3e>
 8005f8e:	68a2      	ldr	r2, [r4, #8]
 8005f90:	6923      	ldr	r3, [r4, #16]
 8005f92:	429a      	cmp	r2, r3
 8005f94:	d115      	bne.n	8005fc2 <packetQueueWriteByte.constprop.0+0x3e>
        /* We are about to overwrite a packet, so discard it */
        uint16_t dropPktLen = (packetQueueReadByte(queue) << 8) |
 8005f96:	f7ff ffe7 	bl	8005f68 <packetQueueReadByte.constprop.0>
 8005f9a:	4606      	mov	r6, r0
                              (packetQueueReadByte(queue));
 8005f9c:	f7ff ffe4 	bl	8005f68 <packetQueueReadByte.constprop.0>
        uint16_t dropPktLen = (packetQueueReadByte(queue) << 8) |
 8005fa0:	ea40 2306 	orr.w	r3, r0, r6, lsl #8
        queue->readPtr += dropPktLen;
 8005fa4:	68a0      	ldr	r0, [r4, #8]
        if(queue->readPtr >= queue->bufferSize) {
 8005fa6:	6862      	ldr	r2, [r4, #4]
        queue->readPtr += dropPktLen;
 8005fa8:	b29b      	uxth	r3, r3
 8005faa:	4403      	add	r3, r0
        if(queue->readPtr >= queue->bufferSize) {
 8005fac:	4293      	cmp	r3, r2
        queue->readPtr += dropPktLen;
 8005fae:	60a3      	str	r3, [r4, #8]
            queue->readPtr -= queue->bufferSize;
 8005fb0:	bf24      	itt	cs
 8005fb2:	1a9b      	subcs	r3, r3, r2
 8005fb4:	60a3      	strcs	r3, [r4, #8]
        }
        queue->pktCount--;
 8005fb6:	8aa3      	ldrh	r3, [r4, #20]
 8005fb8:	3b01      	subs	r3, #1
 8005fba:	82a3      	strh	r3, [r4, #20]
        queue->numDropped++;
 8005fbc:	6a23      	ldr	r3, [r4, #32]
 8005fbe:	3301      	adds	r3, #1
 8005fc0:	6223      	str	r3, [r4, #32]
    }

    queue->buffer[queue->writePtr] = byte;
 8005fc2:	6923      	ldr	r3, [r4, #16]
 8005fc4:	6822      	ldr	r2, [r4, #0]
 8005fc6:	54d5      	strb	r5, [r2, r3]

    queue->writePtr++;
 8005fc8:	6923      	ldr	r3, [r4, #16]
    if(queue->writePtr >= queue->bufferSize) {
 8005fca:	6862      	ldr	r2, [r4, #4]
    queue->writePtr++;
 8005fcc:	3301      	adds	r3, #1
    if(queue->writePtr >= queue->bufferSize) {
 8005fce:	4293      	cmp	r3, r2
    queue->writePtr++;
 8005fd0:	6123      	str	r3, [r4, #16]
        queue->writePtr = 0;
 8005fd2:	bf24      	itt	cs
 8005fd4:	2300      	movcs	r3, #0
 8005fd6:	6123      	strcs	r3, [r4, #16]
    }
}
 8005fd8:	bd70      	pop	{r4, r5, r6, pc}
 8005fda:	bf00      	nop
 8005fdc:	20001310 	.word	0x20001310

08005fe0 <packetQueuePutBytes.constprop.0>:
    packetQueueWriteByte(queue, 0x00);
    packetQueueWriteByte(queue, 0x00);
    queue->pktLen = 0;
}

void packetQueuePutBytes(PacketQueue_t* queue, const uint8_t* payload, uint16_t size)
 8005fe0:	b570      	push	{r4, r5, r6, lr}
 8005fe2:	4606      	mov	r6, r0
 8005fe4:	460c      	mov	r4, r1
{
    for(uint32_t i=0; i<size; i++) {
 8005fe6:	2500      	movs	r5, #0
 8005fe8:	42a5      	cmp	r5, r4
 8005fea:	d304      	bcc.n	8005ff6 <packetQueuePutBytes.constprop.0+0x16>
        packetQueueWriteByte(queue, payload[i]);
    }

    queue->pktLen += size;
 8005fec:	4b04      	ldr	r3, [pc, #16]	; (8006000 <packetQueuePutBytes.constprop.0+0x20>)
 8005fee:	6999      	ldr	r1, [r3, #24]
 8005ff0:	4421      	add	r1, r4
 8005ff2:	6199      	str	r1, [r3, #24]
}
 8005ff4:	bd70      	pop	{r4, r5, r6, pc}
        packetQueueWriteByte(queue, payload[i]);
 8005ff6:	5d70      	ldrb	r0, [r6, r5]
 8005ff8:	f7ff ffc4 	bl	8005f84 <packetQueueWriteByte.constprop.0>
    for(uint32_t i=0; i<size; i++) {
 8005ffc:	3501      	adds	r5, #1
 8005ffe:	e7f3      	b.n	8005fe8 <packetQueuePutBytes.constprop.0+0x8>
 8006000:	20001310 	.word	0x20001310

08006004 <syslogWrite>:
    packetQueueReset(&syslogQueue);
    xSemaphoreGive(syslogSemaphore);
}

static size_t syslogWrite(void *instance, const uint8_t *bp, size_t n)
{
 8006004:	b510      	push	{r4, lr}
 8006006:	4614      	mov	r4, r2
 8006008:	4608      	mov	r0, r1
    (void)instance;

    packetQueuePutBytes(&syslogQueue, bp, n);
 800600a:	b291      	uxth	r1, r2
 800600c:	f7ff ffe8 	bl	8005fe0 <packetQueuePutBytes.constprop.0>

    return n;
}
 8006010:	4620      	mov	r0, r4
 8006012:	bd10      	pop	{r4, pc}

08006014 <syslogPut>:

static msg_t syslogPut(void *instance, uint8_t b)
{
 8006014:	b507      	push	{r0, r1, r2, lr}
 8006016:	f88d 1007 	strb.w	r1, [sp, #7]
    (void)instance;

    packetQueuePutBytes(&syslogQueue, &b, 1);
 800601a:	f10d 0007 	add.w	r0, sp, #7
 800601e:	2101      	movs	r1, #1
 8006020:	f7ff ffde 	bl	8005fe0 <packetQueuePutBytes.constprop.0>

    return MSG_OK;
}
 8006024:	2000      	movs	r0, #0
 8006026:	b003      	add	sp, #12
 8006028:	f85d fb04 	ldr.w	pc, [sp], #4

0800602c <packetQueueEndWritePacket.constprop.0>:

void packetQueueEndWritePacket(PacketQueue_t* queue)
{
    /* Did we write more bytes than the ENTIRE queue? */
    if(queue->pktLen >= queue->bufferSize-2) {
 800602c:	4b13      	ldr	r3, [pc, #76]	; (800607c <packetQueueEndWritePacket.constprop.0+0x50>)
 800602e:	685a      	ldr	r2, [r3, #4]
 8006030:	6999      	ldr	r1, [r3, #24]
 8006032:	3a02      	subs	r2, #2
 8006034:	4291      	cmp	r1, r2
 8006036:	d309      	bcc.n	800604c <packetQueueEndWritePacket.constprop.0+0x20>
        queue->numDropped+=queue->pktCount+1;
 8006038:	6a1a      	ldr	r2, [r3, #32]
 800603a:	8a99      	ldrh	r1, [r3, #20]
 800603c:	3201      	adds	r2, #1
 800603e:	440a      	add	r2, r1
 8006040:	621a      	str	r2, [r3, #32]
        queue->pktCount = 0;
 8006042:	2200      	movs	r2, #0
 8006044:	829a      	strh	r2, [r3, #20]
        queue->readPtr = 0;
 8006046:	609a      	str	r2, [r3, #8]
        queue->writePtr = 0;
 8006048:	611a      	str	r2, [r3, #16]
        return;
 800604a:	4770      	bx	lr
    }

    /* Packet too long? */
    if(queue->pktLen > 0xffff) {
 800604c:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
        queue->writePtr = queue->lenHeaderStart;
 8006050:	69da      	ldr	r2, [r3, #28]
    if(queue->pktLen > 0xffff) {
 8006052:	d304      	bcc.n	800605e <packetQueueEndWritePacket.constprop.0+0x32>
        queue->writePtr = queue->lenHeaderStart;
 8006054:	611a      	str	r2, [r3, #16]
        queue->numDropped++;
 8006056:	6a1a      	ldr	r2, [r3, #32]
 8006058:	3201      	adds	r2, #1
 800605a:	621a      	str	r2, [r3, #32]
        return;
 800605c:	4770      	bx	lr
    }

    uint32_t hdrIndex = queue->lenHeaderStart;
    queue->buffer[hdrIndex] = queue->pktLen >> 8;
 800605e:	6818      	ldr	r0, [r3, #0]
 8006060:	0a09      	lsrs	r1, r1, #8
 8006062:	5481      	strb	r1, [r0, r2]
    hdrIndex++;
    if(hdrIndex >= queue->bufferSize) {
 8006064:	6859      	ldr	r1, [r3, #4]
    hdrIndex++;
 8006066:	3201      	adds	r2, #1
        hdrIndex = 0;
 8006068:	428a      	cmp	r2, r1
 800606a:	bf28      	it	cs
 800606c:	2200      	movcs	r2, #0
    }
    queue->buffer[hdrIndex] = queue->pktLen & 0xff;
 800606e:	6998      	ldr	r0, [r3, #24]
 8006070:	6819      	ldr	r1, [r3, #0]
 8006072:	5488      	strb	r0, [r1, r2]
    queue->pktCount++;
 8006074:	8a9a      	ldrh	r2, [r3, #20]
 8006076:	3201      	adds	r2, #1
 8006078:	829a      	strh	r2, [r3, #20]
}
 800607a:	4770      	bx	lr
 800607c:	20001310 	.word	0x20001310

08006080 <vTaskDelete.constprop.0>:
	void vTaskDelete( TaskHandle_t xTaskToDelete )
 8006080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8006082:	4d2f      	ldr	r5, [pc, #188]	; (8006140 <vTaskDelete.constprop.0+0xc0>)
		taskENTER_CRITICAL();
 8006084:	f7fe fc8e 	bl	80049a4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8006088:	682c      	ldr	r4, [r5, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800608a:	1d26      	adds	r6, r4, #4
 800608c:	4630      	mov	r0, r6
 800608e:	f7fe fb0c 	bl	80046aa <uxListRemove>
 8006092:	b960      	cbnz	r0, 80060ae <vTaskDelete.constprop.0+0x2e>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8006094:	2014      	movs	r0, #20
 8006096:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8006098:	4b2a      	ldr	r3, [pc, #168]	; (8006144 <vTaskDelete.constprop.0+0xc4>)
 800609a:	4378      	muls	r0, r7
 800609c:	581b      	ldr	r3, [r3, r0]
 800609e:	b933      	cbnz	r3, 80060ae <vTaskDelete.constprop.0+0x2e>
 80060a0:	2201      	movs	r2, #1
 80060a2:	4929      	ldr	r1, [pc, #164]	; (8006148 <vTaskDelete.constprop.0+0xc8>)
 80060a4:	40ba      	lsls	r2, r7
 80060a6:	680b      	ldr	r3, [r1, #0]
 80060a8:	ea23 0302 	bic.w	r3, r3, r2
 80060ac:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80060ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80060b0:	b11b      	cbz	r3, 80060ba <vTaskDelete.constprop.0+0x3a>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80060b2:	f104 0018 	add.w	r0, r4, #24
 80060b6:	f7fe faf8 	bl	80046aa <uxListRemove>
			uxTaskNumber++;
 80060ba:	4a24      	ldr	r2, [pc, #144]	; (800614c <vTaskDelete.constprop.0+0xcc>)
 80060bc:	6813      	ldr	r3, [r2, #0]
 80060be:	3301      	adds	r3, #1
 80060c0:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 80060c2:	682b      	ldr	r3, [r5, #0]
 80060c4:	429c      	cmp	r4, r3
 80060c6:	d113      	bne.n	80060f0 <vTaskDelete.constprop.0+0x70>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 80060c8:	4631      	mov	r1, r6
 80060ca:	4821      	ldr	r0, [pc, #132]	; (8006150 <vTaskDelete.constprop.0+0xd0>)
 80060cc:	f7fe faca 	bl	8004664 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 80060d0:	4a20      	ldr	r2, [pc, #128]	; (8006154 <vTaskDelete.constprop.0+0xd4>)
 80060d2:	6813      	ldr	r3, [r2, #0]
 80060d4:	3301      	adds	r3, #1
 80060d6:	6013      	str	r3, [r2, #0]
		taskEXIT_CRITICAL();
 80060d8:	f7fe fe7c 	bl	8004dd4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 80060dc:	4b1e      	ldr	r3, [pc, #120]	; (8006158 <vTaskDelete.constprop.0+0xd8>)
 80060de:	681b      	ldr	r3, [r3, #0]
 80060e0:	b36b      	cbz	r3, 800613e <vTaskDelete.constprop.0+0xbe>
			if( pxTCB == pxCurrentTCB )
 80060e2:	682b      	ldr	r3, [r5, #0]
 80060e4:	429c      	cmp	r4, r3
 80060e6:	d12a      	bne.n	800613e <vTaskDelete.constprop.0+0xbe>
				configASSERT( uxSchedulerSuspended == 0 );
 80060e8:	4b1c      	ldr	r3, [pc, #112]	; (800615c <vTaskDelete.constprop.0+0xdc>)
 80060ea:	681b      	ldr	r3, [r3, #0]
 80060ec:	b153      	cbz	r3, 8006104 <vTaskDelete.constprop.0+0x84>
 80060ee:	e7fe      	b.n	80060ee <vTaskDelete.constprop.0+0x6e>
				--uxCurrentNumberOfTasks;
 80060f0:	4a1b      	ldr	r2, [pc, #108]	; (8006160 <vTaskDelete.constprop.0+0xe0>)
				prvDeleteTCB( pxTCB );
 80060f2:	4620      	mov	r0, r4
				--uxCurrentNumberOfTasks;
 80060f4:	6813      	ldr	r3, [r2, #0]
 80060f6:	3b01      	subs	r3, #1
 80060f8:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 80060fa:	f7ff f931 	bl	8005360 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 80060fe:	f7fe fb0b 	bl	8004718 <prvResetNextTaskUnblockTime>
 8006102:	e7e9      	b.n	80060d8 <vTaskDelete.constprop.0+0x58>
				portYIELD_WITHIN_API();
 8006104:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8006108:	4a16      	ldr	r2, [pc, #88]	; (8006164 <vTaskDelete.constprop.0+0xe4>)
 800610a:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800610e:	6011      	str	r1, [r2, #0]
 8006110:	4a15      	ldr	r2, [pc, #84]	; (8006168 <vTaskDelete.constprop.0+0xe8>)
 8006112:	6812      	ldr	r2, [r2, #0]
 8006114:	b14a      	cbz	r2, 800612a <vTaskDelete.constprop.0+0xaa>
 8006116:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800611a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800611e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006122:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8006126:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800612a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800612e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006132:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8006136:	f3bf 8f4f 	dsb	sy
 800613a:	f3bf 8f6f 	isb	sy
	}
 800613e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006140:	200011a8 	.word	0x200011a8
 8006144:	200011b8 	.word	0x200011b8
 8006148:	20001374 	.word	0x20001374
 800614c:	20001370 	.word	0x20001370
 8006150:	20001634 	.word	0x20001634
 8006154:	20001360 	.word	0x20001360
 8006158:	20001614 	.word	0x20001614
 800615c:	2000136c 	.word	0x2000136c
 8006160:	2000135c 	.word	0x2000135c
 8006164:	2000134c 	.word	0x2000134c
 8006168:	20001358 	.word	0x20001358

0800616c <runInThreadBody>:
{
 800616c:	b508      	push	{r3, lr}
    func();
 800616e:	4780      	blx	r0
}
 8006170:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vTaskDelete(NULL);
 8006174:	f7ff bf84 	b.w	8006080 <vTaskDelete.constprop.0>

08006178 <_usb_reset.constprop.0>:
void _usb_reset(USBDriver *usbp) {
 8006178:	b570      	push	{r4, r5, r6, lr}
  usbp->status        = 0;
 800617a:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 800617c:	2302      	movs	r3, #2
 800617e:	4c16      	ldr	r4, [pc, #88]	; (80061d8 <_usb_reset.constprop.0+0x60>)
    usbp->epc[i] = NULL;
 8006180:	2220      	movs	r2, #32
 8006182:	4629      	mov	r1, r5
 8006184:	f104 000c 	add.w	r0, r4, #12
  usbp->state         = USB_READY;
 8006188:	7023      	strb	r3, [r4, #0]
  usbp->status        = 0;
 800618a:	67e5      	str	r5, [r4, #124]	; 0x7c
  usbp->transmitting  = 0;
 800618c:	60a5      	str	r5, [r4, #8]
    usbp->epc[i] = NULL;
 800618e:	f005 fb15 	bl	800b7bc <memset>
  STM32_USB->DADDR  = DADDR_EF;
 8006192:	2280      	movs	r2, #128	; 0x80
  STM32_USB->BTABLE = BTABLE_ADDR;
 8006194:	4b11      	ldr	r3, [pc, #68]	; (80061dc <_usb_reset.constprop.0+0x64>)
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006196:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64
 800619a:	651d      	str	r5, [r3, #80]	; 0x50
  STM32_USB->ISTR   = 0;
 800619c:	645d      	str	r5, [r3, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 800619e:	64da      	str	r2, [r3, #76]	; 0x4c
  if (usbp->config->sof_cb != NULL)
 80061a0:	6862      	ldr	r2, [r4, #4]
  usb_lld_init_endpoint(usbp, 0);
 80061a2:	4629      	mov	r1, r5
  if (usbp->config->sof_cb != NULL)
 80061a4:	68d2      	ldr	r2, [r2, #12]
  usb_lld_init_endpoint(usbp, 0);
 80061a6:	4620      	mov	r0, r4
    cntr |= CNTR_SOFM;
 80061a8:	42aa      	cmp	r2, r5
 80061aa:	bf0c      	ite	eq
 80061ac:	f44f 421c 	moveq.w	r2, #39936	; 0x9c00
 80061b0:	f44f 421e 	movne.w	r2, #40448	; 0x9e00
  STM32_USB->CNTR = cntr;
 80061b4:	641a      	str	r2, [r3, #64]	; 0x40
  usbp->pmnext = 64;
 80061b6:	2340      	movs	r3, #64	; 0x40
 80061b8:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  usbp->epc[0] = &ep0config;
 80061bc:	4b08      	ldr	r3, [pc, #32]	; (80061e0 <_usb_reset.constprop.0+0x68>)
 80061be:	60e3      	str	r3, [r4, #12]
  usb_lld_init_endpoint(usbp, 0);
 80061c0:	f7fe fd80 	bl	8004cc4 <usb_lld_init_endpoint>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80061c4:	6863      	ldr	r3, [r4, #4]
 80061c6:	681b      	ldr	r3, [r3, #0]
 80061c8:	b123      	cbz	r3, 80061d4 <_usb_reset.constprop.0+0x5c>
 80061ca:	4629      	mov	r1, r5
 80061cc:	4620      	mov	r0, r4
}
 80061ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80061d2:	4718      	bx	r3
}
 80061d4:	bd70      	pop	{r4, r5, r6, pc}
 80061d6:	bf00      	nop
 80061d8:	20000f54 	.word	0x20000f54
 80061dc:	40005c00 	.word	0x40005c00
 80061e0:	0800c974 	.word	0x0800c974

080061e4 <Vector90>:
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 80061e4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  istr = STM32_USB->ISTR;
 80061e8:	4d92      	ldr	r5, [pc, #584]	; (8006434 <Vector90+0x250>)
 80061ea:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  if (istr & ISTR_RESET) {
 80061ec:	0566      	lsls	r6, r4, #21
 80061ee:	d504      	bpl.n	80061fa <Vector90+0x16>
    STM32_USB->ISTR = ~ISTR_RESET;
 80061f0:	f46f 6380 	mvn.w	r3, #1024	; 0x400
 80061f4:	646b      	str	r3, [r5, #68]	; 0x44
    _usb_reset(usbp);
 80061f6:	f7ff ffbf 	bl	8006178 <_usb_reset.constprop.0>
  if (istr & ISTR_SUSP) {
 80061fa:	0520      	lsls	r0, r4, #20
 80061fc:	d511      	bpl.n	8006222 <Vector90+0x3e>
    STM32_USB->CNTR |= CNTR_FSUSP;
 80061fe:	6c2b      	ldr	r3, [r5, #64]	; 0x40
  usbp->saved_state = usbp->state;
 8006200:	488d      	ldr	r0, [pc, #564]	; (8006438 <Vector90+0x254>)
 8006202:	f043 0308 	orr.w	r3, r3, #8
 8006206:	642b      	str	r3, [r5, #64]	; 0x40
    STM32_USB->ISTR = ~ISTR_SUSP;
 8006208:	f46f 6300 	mvn.w	r3, #2048	; 0x800
 800620c:	646b      	str	r3, [r5, #68]	; 0x44
 800620e:	7803      	ldrb	r3, [r0, #0]
 8006210:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 8006214:	2305      	movs	r3, #5
 8006216:	7003      	strb	r3, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006218:	6843      	ldr	r3, [r0, #4]
 800621a:	681b      	ldr	r3, [r3, #0]
 800621c:	b10b      	cbz	r3, 8006222 <Vector90+0x3e>
 800621e:	2104      	movs	r1, #4
 8006220:	4798      	blx	r3
  if (istr & ISTR_WKUP) {
 8006222:	04e1      	lsls	r1, r4, #19
 8006224:	d514      	bpl.n	8006250 <Vector90+0x6c>
    uint32_t fnr = STM32_USB->FNR;
 8006226:	4b83      	ldr	r3, [pc, #524]	; (8006434 <Vector90+0x250>)
 8006228:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 800622a:	0412      	lsls	r2, r2, #16
 800622c:	d40c      	bmi.n	8006248 <Vector90+0x64>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 800622e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  usbp->state = usbp->saved_state;
 8006230:	4881      	ldr	r0, [pc, #516]	; (8006438 <Vector90+0x254>)
 8006232:	f022 0208 	bic.w	r2, r2, #8
 8006236:	641a      	str	r2, [r3, #64]	; 0x40
 8006238:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800623c:	7003      	strb	r3, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800623e:	6843      	ldr	r3, [r0, #4]
 8006240:	681b      	ldr	r3, [r3, #0]
 8006242:	b10b      	cbz	r3, 8006248 <Vector90+0x64>
 8006244:	2105      	movs	r1, #5
 8006246:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_WKUP;
 8006248:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800624c:	4b79      	ldr	r3, [pc, #484]	; (8006434 <Vector90+0x250>)
 800624e:	645a      	str	r2, [r3, #68]	; 0x44
  if (istr & ISTR_SOF) {
 8006250:	05a3      	lsls	r3, r4, #22
 8006252:	d508      	bpl.n	8006266 <Vector90+0x82>
    _usb_isr_invoke_sof_cb(usbp);
 8006254:	4878      	ldr	r0, [pc, #480]	; (8006438 <Vector90+0x254>)
 8006256:	6843      	ldr	r3, [r0, #4]
 8006258:	68db      	ldr	r3, [r3, #12]
 800625a:	b103      	cbz	r3, 800625e <Vector90+0x7a>
 800625c:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 800625e:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8006262:	4b74      	ldr	r3, [pc, #464]	; (8006434 <Vector90+0x250>)
 8006264:	645a      	str	r2, [r3, #68]	; 0x44
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8006266:	4e74      	ldr	r6, [pc, #464]	; (8006438 <Vector90+0x254>)
    EPR_CLEAR_CTR_TX(ep);
 8006268:	4d74      	ldr	r5, [pc, #464]	; (800643c <Vector90+0x258>)
  while (istr & ISTR_CTR) {
 800626a:	f414 4100 	ands.w	r1, r4, #32768	; 0x8000
 800626e:	d122      	bne.n	80062b6 <Vector90+0xd2>
    UBaseType_t isIt = xYieldPending;
 8006270:	4b73      	ldr	r3, [pc, #460]	; (8006440 <Vector90+0x25c>)
 8006272:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8006274:	6019      	str	r1, [r3, #0]
  OSAL_IRQ_EPILOGUE();
 8006276:	b1e2      	cbz	r2, 80062b2 <Vector90+0xce>
 8006278:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800627c:	4a71      	ldr	r2, [pc, #452]	; (8006444 <Vector90+0x260>)
 800627e:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8006282:	6011      	str	r1, [r2, #0]
 8006284:	4a70      	ldr	r2, [pc, #448]	; (8006448 <Vector90+0x264>)
 8006286:	6812      	ldr	r2, [r2, #0]
 8006288:	b14a      	cbz	r2, 800629e <Vector90+0xba>
 800628a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800628e:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8006292:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006296:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800629a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800629e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80062a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80062a6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80062aa:	f3bf 8f4f 	dsb	sy
 80062ae:	f3bf 8f6f 	isb	sy
}
 80062b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 80062b6:	f004 040f 	and.w	r4, r4, #15
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
 80062ba:	00a7      	lsls	r7, r4, #2
 80062bc:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80062c0:	f507 47b8 	add.w	r7, r7, #23552	; 0x5c00
  uint32_t epr = STM32_USB->EPR[ep];
 80062c4:	f8d7 a000 	ldr.w	sl, [r7]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80062c8:	f104 0902 	add.w	r9, r4, #2
 80062cc:	eb06 0389 	add.w	r3, r6, r9, lsl #2
  if (epr & EPR_CTR_TX) {
 80062d0:	f01a 0f80 	tst.w	sl, #128	; 0x80
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80062d4:	f8d3 8004 	ldr.w	r8, [r3, #4]
  if (epr & EPR_CTR_TX) {
 80062d8:	d025      	beq.n	8006326 <Vector90+0x142>
    EPR_CLEAR_CTR_TX(ep);
 80062da:	683a      	ldr	r2, [r7, #0]
    USBInEndpointState *isp = epcp->in_state;
 80062dc:	f8d8 3014 	ldr.w	r3, [r8, #20]
    EPR_CLEAR_CTR_TX(ep);
 80062e0:	402a      	ands	r2, r5
 80062e2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80062e6:	603a      	str	r2, [r7, #0]
    isp->txcnt += isp->txlast;
 80062e8:	68d9      	ldr	r1, [r3, #12]
 80062ea:	685a      	ldr	r2, [r3, #4]
    n = isp->txsize - isp->txcnt;
 80062ec:	6818      	ldr	r0, [r3, #0]
    isp->txcnt += isp->txlast;
 80062ee:	440a      	add	r2, r1
    if (n > 0) {
 80062f0:	1a80      	subs	r0, r0, r2
    isp->txcnt += isp->txlast;
 80062f2:	605a      	str	r2, [r3, #4]
    if (n > 0) {
 80062f4:	d02c      	beq.n	8006350 <Vector90+0x16c>
      if (n > epcp->in_maxsize)
 80062f6:	f8b8 2010 	ldrh.w	r2, [r8, #16]
 80062fa:	4282      	cmp	r2, r0
 80062fc:	bf28      	it	cs
 80062fe:	4602      	movcs	r2, r0
      isp->txbuf += isp->txlast;
 8006300:	6898      	ldr	r0, [r3, #8]
 8006302:	4401      	add	r1, r0
      isp->txlast = n;
 8006304:	e9c3 1202 	strd	r1, r2, [r3, #8]
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8006308:	4620      	mov	r0, r4
 800630a:	f7fd ff29 	bl	8004160 <usb_packet_write_from_buffer>
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800630e:	683b      	ldr	r3, [r7, #0]
 8006310:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8006314:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006318:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800631c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8006320:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006324:	603b      	str	r3, [r7, #0]
  if (epr & EPR_CTR_RX) {
 8006326:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
 800632a:	d06a      	beq.n	8006402 <Vector90+0x21e>
    EPR_CLEAR_CTR_RX(ep);
 800632c:	683b      	ldr	r3, [r7, #0]
    if (epr & EPR_SETUP) {
 800632e:	f41a 6f00 	tst.w	sl, #2048	; 0x800
    EPR_CLEAR_CTR_RX(ep);
 8006332:	ea03 0305 	and.w	r3, r3, r5
 8006336:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800633a:	603b      	str	r3, [r7, #0]
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 800633c:	b2e1      	uxtb	r1, r4
    if (epr & EPR_SETUP) {
 800633e:	d016      	beq.n	800636e <Vector90+0x18a>
      _usb_isr_invoke_setup_cb(usbp, ep);
 8006340:	eb06 0989 	add.w	r9, r6, r9, lsl #2
 8006344:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8006348:	685b      	ldr	r3, [r3, #4]
        _usb_isr_invoke_out_cb(usbp, ep);
 800634a:	4630      	mov	r0, r6
 800634c:	4798      	blx	r3
 800634e:	e058      	b.n	8006402 <Vector90+0x21e>
      _usb_isr_invoke_in_cb(usbp, ep);
 8006350:	2301      	movs	r3, #1
 8006352:	fa03 f204 	lsl.w	r2, r3, r4
 8006356:	8933      	ldrh	r3, [r6, #8]
 8006358:	ea23 0302 	bic.w	r3, r3, r2
 800635c:	8133      	strh	r3, [r6, #8]
 800635e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8006362:	2b00      	cmp	r3, #0
 8006364:	d0df      	beq.n	8006326 <Vector90+0x142>
 8006366:	4621      	mov	r1, r4
 8006368:	4630      	mov	r0, r6
 800636a:	4798      	blx	r3
 800636c:	e7db      	b.n	8006326 <Vector90+0x142>
      USBOutEndpointState *osp = epcp->out_state;
 800636e:	f8d8 2018 	ldr.w	r2, [r8, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006372:	4b30      	ldr	r3, [pc, #192]	; (8006434 <Vector90+0x250>)
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 8006374:	f8d2 c008 	ldr.w	ip, [r2, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006378:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800637a:	46e1      	mov	r9, ip
 800637c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8006380:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8006384:	eb03 1004 	add.w	r0, r3, r4, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006388:	6883      	ldr	r3, [r0, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800638a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800638e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8006392:	f3ce 0009 	ubfx	r0, lr, #0, #10
 8006396:	f3ce 0e48 	ubfx	lr, lr, #1, #9
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800639a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
  while (i >= 2) {
 800639e:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
 80063a2:	eb0a 0a43 	add.w	sl, sl, r3, lsl #1
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 80063a6:	005b      	lsls	r3, r3, #1
  while (i >= 2) {
 80063a8:	4553      	cmp	r3, sl
 80063aa:	f109 0902 	add.w	r9, r9, #2
 80063ae:	d12b      	bne.n	8006408 <Vector90+0x224>
  if (i >= 1) {
 80063b0:	f06f 0901 	mvn.w	r9, #1
 80063b4:	fb09 090e 	mla	r9, r9, lr, r0
 80063b8:	f1b9 0f00 	cmp.w	r9, #0
 80063bc:	d002      	beq.n	80063c4 <Vector90+0x1e0>
    *buf = (uint8_t)*pmap;
 80063be:	681b      	ldr	r3, [r3, #0]
 80063c0:	f80c 301e 	strb.w	r3, [ip, lr, lsl #1]
      osp->rxbuf += n;
 80063c4:	6893      	ldr	r3, [r2, #8]
 80063c6:	4403      	add	r3, r0
 80063c8:	6093      	str	r3, [r2, #8]
      osp->rxcnt  += n;
 80063ca:	6853      	ldr	r3, [r2, #4]
 80063cc:	4403      	add	r3, r0
 80063ce:	6053      	str	r3, [r2, #4]
      osp->rxsize -= n;
 80063d0:	6813      	ldr	r3, [r2, #0]
 80063d2:	1a1b      	subs	r3, r3, r0
 80063d4:	6013      	str	r3, [r2, #0]
      osp->rxpkts -= 1;
 80063d6:	8993      	ldrh	r3, [r2, #12]
 80063d8:	3b01      	subs	r3, #1
 80063da:	b29b      	uxth	r3, r3
 80063dc:	8193      	strh	r3, [r2, #12]
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 80063de:	f8b8 2012 	ldrh.w	r2, [r8, #18]
 80063e2:	4282      	cmp	r2, r0
 80063e4:	d800      	bhi.n	80063e8 <Vector90+0x204>
 80063e6:	b9c3      	cbnz	r3, 800641a <Vector90+0x236>
        _usb_isr_invoke_out_cb(usbp, ep);
 80063e8:	2301      	movs	r3, #1
 80063ea:	fa03 f204 	lsl.w	r2, r3, r4
 80063ee:	8973      	ldrh	r3, [r6, #10]
 80063f0:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 80063f4:	ea23 0302 	bic.w	r3, r3, r2
 80063f8:	8173      	strh	r3, [r6, #10]
 80063fa:	68e3      	ldr	r3, [r4, #12]
 80063fc:	68db      	ldr	r3, [r3, #12]
 80063fe:	2b00      	cmp	r3, #0
 8006400:	d1a3      	bne.n	800634a <Vector90+0x166>
    istr = STM32_USB->ISTR;
 8006402:	4b0c      	ldr	r3, [pc, #48]	; (8006434 <Vector90+0x250>)
 8006404:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8006406:	e730      	b.n	800626a <Vector90+0x86>
    uint32_t w = *pmap++;
 8006408:	f853 bb04 	ldr.w	fp, [r3], #4
    *buf++ = (uint8_t)w;
 800640c:	f809 bc02 	strb.w	fp, [r9, #-2]
    *buf++ = (uint8_t)(w >> 8);
 8006410:	ea4f 2b1b 	mov.w	fp, fp, lsr #8
 8006414:	f809 bc01 	strb.w	fp, [r9, #-1]
    i -= 2;
 8006418:	e7c6      	b.n	80063a8 <Vector90+0x1c4>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800641a:	683b      	ldr	r3, [r7, #0]
 800641c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8006420:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006424:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8006428:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800642c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006430:	603b      	str	r3, [r7, #0]
 8006432:	e7e6      	b.n	8006402 <Vector90+0x21e>
 8006434:	40005c00 	.word	0x40005c00
 8006438:	20000f54 	.word	0x20000f54
 800643c:	ffff070f 	.word	0xffff070f
 8006440:	2000164c 	.word	0x2000164c
 8006444:	2000134c 	.word	0x2000134c
 8006448:	20001358 	.word	0x20001358

0800644c <dmaStreamAllocate.constprop.0>:
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 800644c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  osalDbgCheck(dmastp != NULL);
 800644e:	b910      	cbnz	r0, 8006456 <dmaStreamAllocate.constprop.0+0xa>
 8006450:	f7fe fab8 	bl	80049c4 <vTaskEndScheduler>
 8006454:	e7fe      	b.n	8006454 <dmaStreamAllocate.constprop.0+0x8>
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8006456:	2301      	movs	r3, #1
 8006458:	4e1f      	ldr	r6, [pc, #124]	; (80064d8 <dmaStreamAllocate.constprop.0+0x8c>)
 800645a:	7c47      	ldrb	r7, [r0, #17]
 800645c:	6835      	ldr	r5, [r6, #0]
 800645e:	fa03 f407 	lsl.w	r4, r3, r7
 8006462:	422c      	tst	r4, r5
 8006464:	d135      	bne.n	80064d2 <dmaStreamAllocate.constprop.0+0x86>
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8006466:	4b1d      	ldr	r3, [pc, #116]	; (80064dc <dmaStreamAllocate.constprop.0+0x90>)
 8006468:	f843 1037 	str.w	r1, [r3, r7, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 800646c:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 8006470:	605a      	str	r2, [r3, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8006472:	066b      	lsls	r3, r5, #25
    rccEnableDMA1(false);
 8006474:	bf08      	it	eq
 8006476:	4a1a      	ldreq	r2, [pc, #104]	; (80064e0 <dmaStreamAllocate.constprop.0+0x94>)
  dmaStreamDisable(dmastp);
 8006478:	6801      	ldr	r1, [r0, #0]
    rccEnableDMA1(false);
 800647a:	bf02      	ittt	eq
 800647c:	6953      	ldreq	r3, [r2, #20]
 800647e:	f043 0301 	orreq.w	r3, r3, #1
 8006482:	6153      	streq	r3, [r2, #20]
  dmaStreamDisable(dmastp);
 8006484:	6843      	ldr	r3, [r0, #4]
 8006486:	681a      	ldr	r2, [r3, #0]
 8006488:	f022 020f 	bic.w	r2, r2, #15
 800648c:	601a      	str	r2, [r3, #0]
 800648e:	220e      	movs	r2, #14
 8006490:	7c07      	ldrb	r7, [r0, #16]
 8006492:	40ba      	lsls	r2, r7
 8006494:	604a      	str	r2, [r1, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8006496:	2200      	movs	r2, #0
 8006498:	601a      	str	r2, [r3, #0]
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 800649a:	6883      	ldr	r3, [r0, #8]
 800649c:	421d      	tst	r5, r3
 800649e:	d114      	bne.n	80064ca <dmaStreamAllocate.constprop.0+0x7e>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80064a0:	21c0      	movs	r1, #192	; 0xc0
    nvicEnableVector(dmastp->vector, priority);
 80064a2:	7c83      	ldrb	r3, [r0, #18]
 80064a4:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
 80064a8:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80064ac:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80064b0:	2201      	movs	r2, #1
 80064b2:	f003 011f 	and.w	r1, r3, #31
 80064b6:	095b      	lsrs	r3, r3, #5
 80064b8:	009b      	lsls	r3, r3, #2
 80064ba:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80064be:	408a      	lsls	r2, r1
 80064c0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80064c4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80064c8:	601a      	str	r2, [r3, #0]
  return false;
 80064ca:	2000      	movs	r0, #0
  dma_streams_mask |= (1U << dmastp->selfindex);
 80064cc:	432c      	orrs	r4, r5
 80064ce:	6034      	str	r4, [r6, #0]
}
 80064d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return true;
 80064d2:	4618      	mov	r0, r3
 80064d4:	e7fc      	b.n	80064d0 <dmaStreamAllocate.constprop.0+0x84>
 80064d6:	bf00      	nop
 80064d8:	20001044 	.word	0x20001044
 80064dc:	20000fe8 	.word	0x20000fe8
 80064e0:	40021000 	.word	0x40021000

080064e4 <xTaskNotifyWait.constprop.0>:
	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
 80064e4:	b570      	push	{r4, r5, r6, lr}
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 80064e6:	4c27      	ldr	r4, [pc, #156]	; (8006584 <xTaskNotifyWait.constprop.0+0xa0>)
	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
 80064e8:	4606      	mov	r6, r0
 80064ea:	460d      	mov	r5, r1
 80064ec:	4610      	mov	r0, r2
		taskENTER_CRITICAL();
 80064ee:	f7fe fa59 	bl	80049a4 <vPortEnterCritical>
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 80064f2:	6823      	ldr	r3, [r4, #0]
 80064f4:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80064f8:	2b02      	cmp	r3, #2
 80064fa:	d028      	beq.n	800654e <xTaskNotifyWait.constprop.0+0x6a>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 80064fc:	2101      	movs	r1, #1
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 80064fe:	6822      	ldr	r2, [r4, #0]
 8006500:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8006502:	ea23 0306 	bic.w	r3, r3, r6
 8006506:	6613      	str	r3, [r2, #96]	; 0x60
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 8006508:	6823      	ldr	r3, [r4, #0]
 800650a:	f883 1064 	strb.w	r1, [r3, #100]	; 0x64
				if( xTicksToWait > ( TickType_t ) 0 )
 800650e:	b1f0      	cbz	r0, 800654e <xTaskNotifyWait.constprop.0+0x6a>
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8006510:	f7fe f9da 	bl	80048c8 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 8006514:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8006518:	4a1b      	ldr	r2, [pc, #108]	; (8006588 <xTaskNotifyWait.constprop.0+0xa4>)
 800651a:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800651e:	6011      	str	r1, [r2, #0]
 8006520:	4a1a      	ldr	r2, [pc, #104]	; (800658c <xTaskNotifyWait.constprop.0+0xa8>)
 8006522:	6812      	ldr	r2, [r2, #0]
 8006524:	b14a      	cbz	r2, 800653a <xTaskNotifyWait.constprop.0+0x56>
 8006526:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800652a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800652e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006532:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8006536:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800653a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800653e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006542:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8006546:	f3bf 8f4f 	dsb	sy
 800654a:	f3bf 8f6f 	isb	sy
		taskEXIT_CRITICAL();
 800654e:	f7fe fc41 	bl	8004dd4 <vPortExitCritical>
		taskENTER_CRITICAL();
 8006552:	f7fe fa27 	bl	80049a4 <vPortEnterCritical>
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 8006556:	6823      	ldr	r3, [r4, #0]
 8006558:	2000      	movs	r0, #0
 800655a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800655c:	602b      	str	r3, [r5, #0]
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 800655e:	6823      	ldr	r3, [r4, #0]
 8006560:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8006564:	2b02      	cmp	r3, #2
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8006566:	bf04      	itt	eq
 8006568:	6823      	ldreq	r3, [r4, #0]
 800656a:	6e1a      	ldreq	r2, [r3, #96]	; 0x60
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800656c:	f04f 0200 	mov.w	r2, #0
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8006570:	bf08      	it	eq
 8006572:	6618      	streq	r0, [r3, #96]	; 0x60
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8006574:	6823      	ldr	r3, [r4, #0]
				xReturn = pdTRUE;
 8006576:	bf08      	it	eq
 8006578:	2001      	moveq	r0, #1
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800657a:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
		taskEXIT_CRITICAL();
 800657e:	f7fe fc29 	bl	8004dd4 <vPortExitCritical>
	}
 8006582:	bd70      	pop	{r4, r5, r6, pc}
 8006584:	200011a8 	.word	0x200011a8
 8006588:	2000134c 	.word	0x2000134c
 800658c:	20001358 	.word	0x20001358

08006590 <taskPeriodicMon>:
{
 8006590:	b507      	push	{r0, r1, r2, lr}
        MonitorEntry* entry = monThreadFirst;
 8006592:	4e0d      	ldr	r6, [pc, #52]	; (80065c8 <taskPeriodicMon+0x38>)
        bool workToCome = false;
 8006594:	2500      	movs	r5, #0
        MonitorEntry* entry = monThreadFirst;
 8006596:	6834      	ldr	r4, [r6, #0]
        while(entry) {
 8006598:	b95c      	cbnz	r4, 80065b2 <taskPeriodicMon+0x22>
        if(!workToCome) {
 800659a:	b92d      	cbnz	r5, 80065a8 <taskPeriodicMon+0x18>
            xTaskNotifyWait(0, ULONG_MAX, (uint32_t*)&ulInterruptStatus, portMAX_DELAY);
 800659c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80065a0:	4628      	mov	r0, r5
 80065a2:	a901      	add	r1, sp, #4
 80065a4:	f7ff ff9e 	bl	80064e4 <xTaskNotifyWait.constprop.0>
        osalThreadSleepSeconds(10);
 80065a8:	f242 7010 	movw	r0, #10000	; 0x2710
 80065ac:	f7fe feec 	bl	8005388 <vTaskDelay>
    for(;;) {
 80065b0:	e7f0      	b.n	8006594 <taskPeriodicMon+0x4>
            if(entry->active) {
 80065b2:	7c23      	ldrb	r3, [r4, #16]
 80065b4:	b12b      	cbz	r3, 80065c2 <taskPeriodicMon+0x32>
                if(entry->callback) {
 80065b6:	6823      	ldr	r3, [r4, #0]
 80065b8:	b11b      	cbz	r3, 80065c2 <taskPeriodicMon+0x32>
                    entry->active = entry->callback(entry->param);
 80065ba:	6860      	ldr	r0, [r4, #4]
 80065bc:	4798      	blx	r3
 80065be:	7420      	strb	r0, [r4, #16]
                    workToCome |= entry->active;
 80065c0:	4305      	orrs	r5, r0
            entry = entry->next;
 80065c2:	68a4      	ldr	r4, [r4, #8]
 80065c4:	e7e8      	b.n	8006598 <taskPeriodicMon+0x8>
 80065c6:	bf00      	nop
 80065c8:	200011a0 	.word	0x200011a0

080065cc <osalThreadSuspendTimeoutS>:
{
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
}

msg_t osalThreadSuspendTimeoutS(thread_reference_t* thread_reference, systime_t timeout)
{
 80065cc:	b513      	push	{r0, r1, r4, lr}
 80065ce:	4604      	mov	r4, r0
 80065d0:	4608      	mov	r0, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80065d2:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80065d6:	b12b      	cbz	r3, 80065e4 <osalThreadSuspendTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80065d8:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80065dc:	b12b      	cbz	r3, 80065ea <osalThreadSuspendTimeoutS+0x1e>
    msg_t ulInterruptStatus;
    osalDbgCheckClassS();
 80065de:	f7fe f9f1 	bl	80049c4 <vTaskEndScheduler>
 80065e2:	e7fe      	b.n	80065e2 <osalThreadSuspendTimeoutS+0x16>
 80065e4:	f7fe f9ee 	bl	80049c4 <vTaskEndScheduler>
 80065e8:	e7fe      	b.n	80065e8 <osalThreadSuspendTimeoutS+0x1c>

    if(!timeout) {
 80065ea:	b181      	cbz	r1, 800660e <osalThreadSuspendTimeoutS+0x42>
        return MSG_TIMEOUT;
    }

    if(thread_reference) {
 80065ec:	b134      	cbz	r4, 80065fc <osalThreadSuspendTimeoutS+0x30>

xTaskHandle xGetCurrentTaskHandle( void )
{
    xTaskHandle xReturn;

    portENTER_CRITICAL();
 80065ee:	f7fe f9d9 	bl	80049a4 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80065f2:	4b0a      	ldr	r3, [pc, #40]	; (800661c <osalThreadSuspendTimeoutS+0x50>)
 80065f4:	6819      	ldr	r1, [r3, #0]
    portEXIT_CRITICAL();
 80065f6:	f7fe fbed 	bl	8004dd4 <vPortExitCritical>
        *thread_reference = xGetCurrentTaskHandle();
 80065fa:	6021      	str	r1, [r4, #0]
    }

    if(!xTaskNotifyWait(ULONG_MAX, ULONG_MAX, (uint32_t*)&ulInterruptStatus, timeout )) {
 80065fc:	4602      	mov	r2, r0
 80065fe:	a901      	add	r1, sp, #4
 8006600:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006604:	f7ff ff6e 	bl	80064e4 <xTaskNotifyWait.constprop.0>
 8006608:	b920      	cbnz	r0, 8006614 <osalThreadSuspendTimeoutS+0x48>
        if(thread_reference) {
 800660a:	b104      	cbz	r4, 800660e <osalThreadSuspendTimeoutS+0x42>
            *thread_reference = NULL;
 800660c:	6020      	str	r0, [r4, #0]
        return MSG_TIMEOUT;
 800660e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006612:	e000      	b.n	8006616 <osalThreadSuspendTimeoutS+0x4a>
        }

        return MSG_TIMEOUT;
    }

    return ulInterruptStatus;
 8006614:	9801      	ldr	r0, [sp, #4]
}
 8006616:	b002      	add	sp, #8
 8006618:	bd10      	pop	{r4, pc}
 800661a:	bf00      	nop
 800661c:	200011a8 	.word	0x200011a8

08006620 <spiReceive.part.0>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006620:	b570      	push	{r4, r5, r6, lr}
 8006622:	460d      	mov	r5, r1
 8006624:	4616      	mov	r6, r2

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 8006626:	f7fe f9bd 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800662a:	7803      	ldrb	r3, [r0, #0]
 800662c:	2b02      	cmp	r3, #2
 800662e:	d002      	beq.n	8006636 <spiReceive.part.0+0x16>
 8006630:	f7fe f9c8 	bl	80049c4 <vTaskEndScheduler>
 8006634:	e7fe      	b.n	8006634 <spiReceive.part.0+0x14>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8006636:	6843      	ldr	r3, [r0, #4]
 8006638:	681b      	ldr	r3, [r3, #0]
 800663a:	b113      	cbz	r3, 8006642 <spiReceive.part.0+0x22>
 800663c:	f7fe f9c2 	bl	80049c4 <vTaskEndScheduler>
 8006640:	e7fe      	b.n	8006640 <spiReceive.part.0+0x20>
  spiStartReceiveI(spip, n, rxbuf);
 8006642:	2303      	movs	r3, #3
 8006644:	7003      	strb	r3, [r0, #0]
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8006646:	6e43      	ldr	r3, [r0, #100]	; 0x64
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8006648:	4a0f      	ldr	r2, [pc, #60]	; (8006688 <spiReceive.part.0+0x68>)
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800664a:	685c      	ldr	r4, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800664c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800664e:	60e6      	str	r6, [r4, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8006650:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8006654:	6065      	str	r5, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8006656:	6023      	str	r3, [r4, #0]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8006658:	6e83      	ldr	r3, [r0, #104]	; 0x68
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
 800665a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800665e:	685b      	ldr	r3, [r3, #4]
 8006660:	3008      	adds	r0, #8
 8006662:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8006664:	6e82      	ldr	r2, [r0, #104]	; 0x68
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8006666:	605d      	str	r5, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8006668:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800666a:	6822      	ldr	r2, [r4, #0]
 800666c:	f042 0201 	orr.w	r2, r2, #1
 8006670:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8006672:	681a      	ldr	r2, [r3, #0]
 8006674:	f042 0201 	orr.w	r2, r2, #1
 8006678:	601a      	str	r2, [r3, #0]
 800667a:	f7ff ffa7 	bl	80065cc <osalThreadSuspendTimeoutS>
  (void) osalThreadSuspendS(&spip->thread);
  osalSysUnlock();
}
 800667e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  osalSysUnlock();
 8006682:	f7fe bbb3 	b.w	8004dec <osalSysUnlock.lto_priv.0>
 8006686:	bf00      	nop
 8006688:	0800c970 	.word	0x0800c970

0800668c <osalThreadEnqueueTimeoutS>:
{
 800668c:	b570      	push	{r4, r5, r6, lr}
 800668e:	4605      	mov	r5, r0
    if(!timeout) {
 8006690:	4608      	mov	r0, r1
 8006692:	2900      	cmp	r1, #0
 8006694:	d03f      	beq.n	8006716 <osalThreadEnqueueTimeoutS+0x8a>
    osalDbgCheck(thread_queue != NULL);
 8006696:	b915      	cbnz	r5, 800669e <osalThreadEnqueueTimeoutS+0x12>
 8006698:	f7fe f994 	bl	80049c4 <vTaskEndScheduler>
 800669c:	e7fe      	b.n	800669c <osalThreadEnqueueTimeoutS+0x10>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800669e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80066a2:	2b00      	cmp	r3, #0
 80066a4:	d034      	beq.n	8006710 <osalThreadEnqueueTimeoutS+0x84>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80066a6:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80066aa:	b113      	cbz	r3, 80066b2 <osalThreadEnqueueTimeoutS+0x26>
    osalDbgCheckClassS();
 80066ac:	f7fe f98a 	bl	80049c4 <vTaskEndScheduler>
 80066b0:	e7fe      	b.n	80066b0 <osalThreadEnqueueTimeoutS+0x24>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80066b2:	4e1a      	ldr	r6, [pc, #104]	; (800671c <osalThreadEnqueueTimeoutS+0x90>)
    portENTER_CRITICAL();
 80066b4:	f7fe f976 	bl	80049a4 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80066b8:	6834      	ldr	r4, [r6, #0]
    portEXIT_CRITICAL();
 80066ba:	f7fe fb8b 	bl	8004dd4 <vPortExitCritical>
    vTaskSetThreadLocalStoragePointer(currentTask, LOCAL_STORAGE_QUEUE_NEXT, thread_queue->head);
 80066be:	682b      	ldr	r3, [r5, #0]
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 80066c0:	b9e4      	cbnz	r4, 80066fc <osalThreadEnqueueTimeoutS+0x70>
 80066c2:	6832      	ldr	r2, [r6, #0]
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066c4:	6553      	str	r3, [r2, #84]	; 0x54
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 80066c6:	b9dc      	cbnz	r4, 8006700 <osalThreadEnqueueTimeoutS+0x74>
 80066c8:	6832      	ldr	r2, [r6, #0]
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066ca:	2100      	movs	r1, #0
 80066cc:	6591      	str	r1, [r2, #88]	; 0x58
    if(thread_queue->head){
 80066ce:	b103      	cbz	r3, 80066d2 <osalThreadEnqueueTimeoutS+0x46>
 80066d0:	659c      	str	r4, [r3, #88]	; 0x58
    if(!thread_queue->tail){
 80066d2:	686b      	ldr	r3, [r5, #4]
    thread_queue->head = currentTask;
 80066d4:	602c      	str	r4, [r5, #0]
    if(!thread_queue->tail){
 80066d6:	b903      	cbnz	r3, 80066da <osalThreadEnqueueTimeoutS+0x4e>
        thread_queue->tail = currentTask;
 80066d8:	606c      	str	r4, [r5, #4]
    msg_t msg = osalThreadSuspendTimeoutS(NULL, timeout);
 80066da:	4601      	mov	r1, r0
 80066dc:	2000      	movs	r0, #0
 80066de:	f7ff ff75 	bl	80065cc <osalThreadSuspendTimeoutS>
    if(msg == MSG_TIMEOUT) {
 80066e2:	1c43      	adds	r3, r0, #1
 80066e4:	d109      	bne.n	80066fa <osalThreadEnqueueTimeoutS+0x6e>
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80066e6:	b96c      	cbnz	r4, 8006704 <osalThreadEnqueueTimeoutS+0x78>
 80066e8:	6833      	ldr	r3, [r6, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 80066ea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80066ec:	b904      	cbnz	r4, 80066f0 <osalThreadEnqueueTimeoutS+0x64>
 80066ee:	6834      	ldr	r4, [r6, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 80066f0:	6da2      	ldr	r2, [r4, #88]	; 0x58
        if(nextTask){
 80066f2:	b14b      	cbz	r3, 8006708 <osalThreadEnqueueTimeoutS+0x7c>
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066f4:	659a      	str	r2, [r3, #88]	; 0x58
        if(prevTask){
 80066f6:	b14a      	cbz	r2, 800670c <osalThreadEnqueueTimeoutS+0x80>
 80066f8:	6553      	str	r3, [r2, #84]	; 0x54
}
 80066fa:	bd70      	pop	{r4, r5, r6, pc}
 80066fc:	4622      	mov	r2, r4
 80066fe:	e7e1      	b.n	80066c4 <osalThreadEnqueueTimeoutS+0x38>
 8006700:	4622      	mov	r2, r4
 8006702:	e7e2      	b.n	80066ca <osalThreadEnqueueTimeoutS+0x3e>
 8006704:	4623      	mov	r3, r4
 8006706:	e7f0      	b.n	80066ea <osalThreadEnqueueTimeoutS+0x5e>
            thread_queue->tail = prevTask;
 8006708:	606a      	str	r2, [r5, #4]
 800670a:	e7f4      	b.n	80066f6 <osalThreadEnqueueTimeoutS+0x6a>
            thread_queue->head = nextTask;
 800670c:	602b      	str	r3, [r5, #0]
 800670e:	e7f4      	b.n	80066fa <osalThreadEnqueueTimeoutS+0x6e>
    osalDbgCheckClassS();
 8006710:	f7fe f958 	bl	80049c4 <vTaskEndScheduler>
 8006714:	e7fe      	b.n	8006714 <osalThreadEnqueueTimeoutS+0x88>
        return MSG_TIMEOUT;
 8006716:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800671a:	e7ee      	b.n	80066fa <osalThreadEnqueueTimeoutS+0x6e>
 800671c:	200011a8 	.word	0x200011a8

08006720 <ibqGetFullBufferTimeoutS>:
                                 systime_t timeout) {
 8006720:	b538      	push	{r3, r4, r5, lr}
 8006722:	4604      	mov	r4, r0
 8006724:	460d      	mov	r5, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006726:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800672a:	b12b      	cbz	r3, 8006738 <ibqGetFullBufferTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 800672c:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 8006730:	b16b      	cbz	r3, 800674e <ibqGetFullBufferTimeoutS+0x2e>
  osalDbgCheckClassS();
 8006732:	f7fe f947 	bl	80049c4 <vTaskEndScheduler>
 8006736:	e7fe      	b.n	8006736 <ibqGetFullBufferTimeoutS+0x16>
 8006738:	f7fe f944 	bl	80049c4 <vTaskEndScheduler>
 800673c:	e7fe      	b.n	800673c <ibqGetFullBufferTimeoutS+0x1c>
    if (ibqp->suspended) {
 800673e:	7a23      	ldrb	r3, [r4, #8]
 8006740:	b9ab      	cbnz	r3, 800676e <ibqGetFullBufferTimeoutS+0x4e>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8006742:	4629      	mov	r1, r5
 8006744:	4620      	mov	r0, r4
 8006746:	f7ff ffa1 	bl	800668c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800674a:	2800      	cmp	r0, #0
 800674c:	db0e      	blt.n	800676c <ibqGetFullBufferTimeoutS+0x4c>
  while (ibqIsEmptyI(ibqp)) {
 800674e:	68e3      	ldr	r3, [r4, #12]
 8006750:	2b00      	cmp	r3, #0
 8006752:	d0f4      	beq.n	800673e <ibqGetFullBufferTimeoutS+0x1e>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8006754:	68e3      	ldr	r3, [r4, #12]
 8006756:	b913      	cbnz	r3, 800675e <ibqGetFullBufferTimeoutS+0x3e>
 8006758:	f7fe f934 	bl	80049c4 <vTaskEndScheduler>
 800675c:	e7fe      	b.n	800675c <ibqGetFullBufferTimeoutS+0x3c>
  return MSG_OK;
 800675e:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8006760:	6962      	ldr	r2, [r4, #20]
 8006762:	1d13      	adds	r3, r2, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8006764:	6812      	ldr	r2, [r2, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8006766:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8006768:	4413      	add	r3, r2
 800676a:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 800676c:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 800676e:	f06f 0001 	mvn.w	r0, #1
 8006772:	e7fb      	b.n	800676c <ibqGetFullBufferTimeoutS+0x4c>

08006774 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8006774:	b538      	push	{r3, r4, r5, lr}
 8006776:	460d      	mov	r5, r1
  osalSysLock();
 8006778:	f7fe f914 	bl	80049a4 <vPortEnterCritical>
  if (ibqp->ptr == NULL) {
 800677c:	6a83      	ldr	r3, [r0, #40]	; 0x28
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 800677e:	4604      	mov	r4, r0
  if (ibqp->ptr == NULL) {
 8006780:	b943      	cbnz	r3, 8006794 <ibqGetTimeout+0x20>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8006782:	4629      	mov	r1, r5
 8006784:	f7ff ffcc 	bl	8006720 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8006788:	4605      	mov	r5, r0
 800678a:	b118      	cbz	r0, 8006794 <ibqGetTimeout+0x20>
  osalSysUnlock();
 800678c:	f7fe fb2e 	bl	8004dec <osalSysUnlock.lto_priv.0>
}
 8006790:	4628      	mov	r0, r5
 8006792:	bd38      	pop	{r3, r4, r5, pc}
  msg = (msg_t)*ibqp->ptr;
 8006794:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 8006796:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  msg = (msg_t)*ibqp->ptr;
 8006798:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 800679c:	4293      	cmp	r3, r2
  ibqp->ptr++;
 800679e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 80067a0:	d3f4      	bcc.n	800678c <ibqGetTimeout+0x18>
    ibqReleaseEmptyBufferS(ibqp);
 80067a2:	4620      	mov	r0, r4
 80067a4:	f7fe f91a 	bl	80049dc <ibqReleaseEmptyBufferS>
 80067a8:	e7f0      	b.n	800678c <ibqGetTimeout+0x18>

080067aa <_get.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 80067aa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80067ae:	3018      	adds	r0, #24
 80067b0:	f7ff bfe0 	b.w	8006774 <ibqGetTimeout>

080067b4 <_gett.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 80067b4:	3018      	adds	r0, #24
 80067b6:	f7ff bfdd 	b.w	8006774 <ibqGetTimeout>

080067ba <obqGetEmptyBufferTimeoutS>:
                                systime_t timeout) {
 80067ba:	b538      	push	{r3, r4, r5, lr}
 80067bc:	4604      	mov	r4, r0
 80067be:	460d      	mov	r5, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80067c0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80067c4:	b12b      	cbz	r3, 80067d2 <obqGetEmptyBufferTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80067c6:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80067ca:	b16b      	cbz	r3, 80067e8 <obqGetEmptyBufferTimeoutS+0x2e>
  osalDbgCheckClassS();
 80067cc:	f7fe f8fa 	bl	80049c4 <vTaskEndScheduler>
 80067d0:	e7fe      	b.n	80067d0 <obqGetEmptyBufferTimeoutS+0x16>
 80067d2:	f7fe f8f7 	bl	80049c4 <vTaskEndScheduler>
 80067d6:	e7fe      	b.n	80067d6 <obqGetEmptyBufferTimeoutS+0x1c>
    if (obqp->suspended) {
 80067d8:	7a23      	ldrb	r3, [r4, #8]
 80067da:	b9ab      	cbnz	r3, 8006808 <obqGetEmptyBufferTimeoutS+0x4e>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 80067dc:	4629      	mov	r1, r5
 80067de:	4620      	mov	r0, r4
 80067e0:	f7ff ff54 	bl	800668c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80067e4:	2800      	cmp	r0, #0
 80067e6:	db0e      	blt.n	8006806 <obqGetEmptyBufferTimeoutS+0x4c>
  while (obqIsFullI(obqp)) {
 80067e8:	68e3      	ldr	r3, [r4, #12]
 80067ea:	2b00      	cmp	r3, #0
 80067ec:	d0f4      	beq.n	80067d8 <obqGetEmptyBufferTimeoutS+0x1e>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80067ee:	68e3      	ldr	r3, [r4, #12]
 80067f0:	b913      	cbnz	r3, 80067f8 <obqGetEmptyBufferTimeoutS+0x3e>
 80067f2:	f7fe f8e7 	bl	80049c4 <vTaskEndScheduler>
 80067f6:	e7fe      	b.n	80067f6 <obqGetEmptyBufferTimeoutS+0x3c>
  return MSG_OK;
 80067f8:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80067fa:	6923      	ldr	r3, [r4, #16]
 80067fc:	1d1a      	adds	r2, r3, #4
 80067fe:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8006800:	69e2      	ldr	r2, [r4, #28]
 8006802:	4413      	add	r3, r2
 8006804:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8006806:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8006808:	f06f 0001 	mvn.w	r0, #1
 800680c:	e7fb      	b.n	8006806 <obqGetEmptyBufferTimeoutS+0x4c>

0800680e <obqPutTimeout>:
                    systime_t timeout) {
 800680e:	b570      	push	{r4, r5, r6, lr}
 8006810:	460d      	mov	r5, r1
 8006812:	4616      	mov	r6, r2
  osalSysLock();
 8006814:	f7fe f8c6 	bl	80049a4 <vPortEnterCritical>
  if (obqp->ptr == NULL) {
 8006818:	6a83      	ldr	r3, [r0, #40]	; 0x28
                    systime_t timeout) {
 800681a:	4604      	mov	r4, r0
  if (obqp->ptr == NULL) {
 800681c:	b933      	cbnz	r3, 800682c <obqPutTimeout+0x1e>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800681e:	4631      	mov	r1, r6
 8006820:	f7ff ffcb 	bl	80067ba <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8006824:	b110      	cbz	r0, 800682c <obqPutTimeout+0x1e>
      osalSysUnlock();
 8006826:	f7fe fae1 	bl	8004dec <osalSysUnlock.lto_priv.0>
}
 800682a:	bd70      	pop	{r4, r5, r6, pc}
  *obqp->ptr = b;
 800682c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800682e:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8006830:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8006832:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
 8006834:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8006836:	4293      	cmp	r3, r2
  obqp->ptr++;
 8006838:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 800683a:	d304      	bcc.n	8006846 <obqPutTimeout+0x38>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800683c:	69e1      	ldr	r1, [r4, #28]
 800683e:	4620      	mov	r0, r4
 8006840:	3904      	subs	r1, #4
 8006842:	f7fe f905 	bl	8004a50 <obqPostFullBufferS>
  osalSysUnlock();
 8006846:	f7fe fad1 	bl	8004dec <osalSysUnlock.lto_priv.0>
  return MSG_OK;
 800684a:	2000      	movs	r0, #0
 800684c:	e7ed      	b.n	800682a <obqPutTimeout+0x1c>

0800684e <_put.lto_priv.1>:
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800684e:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static msg_t _put(void *ip, uint8_t b) {
 8006852:	b538      	push	{r3, r4, r5, lr}
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006854:	6893      	ldr	r3, [r2, #8]
static msg_t _put(void *ip, uint8_t b) {
 8006856:	4604      	mov	r4, r0
 8006858:	460d      	mov	r5, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800685a:	b113      	cbz	r3, 8006862 <_put.lto_priv.1+0x14>
 800685c:	2101      	movs	r1, #1
 800685e:	6810      	ldr	r0, [r2, #0]
 8006860:	4798      	blx	r3
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8006862:	4629      	mov	r1, r5
 8006864:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8006868:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
}
 800686c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8006870:	f7ff bfcd 	b.w	800680e <obqPutTimeout>

08006874 <_putt.lto_priv.1>:
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8006874:	b570      	push	{r4, r5, r6, lr}
 8006876:	4616      	mov	r6, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006878:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 800687c:	4604      	mov	r4, r0
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800687e:	6893      	ldr	r3, [r2, #8]
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8006880:	460d      	mov	r5, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006882:	b113      	cbz	r3, 800688a <_putt.lto_priv.1+0x16>
 8006884:	2101      	movs	r1, #1
 8006886:	6810      	ldr	r0, [r2, #0]
 8006888:	4798      	blx	r3
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800688a:	4632      	mov	r2, r6
 800688c:	4629      	mov	r1, r5
 800688e:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8006892:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8006896:	f7ff bfba 	b.w	800680e <obqPutTimeout>

0800689a <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800689a:	b538      	push	{r3, r4, r5, lr}
 800689c:	4604      	mov	r4, r0
 800689e:	460d      	mov	r5, r1
  uint8_t b;

  osalSysLock();
 80068a0:	f7fe f880 	bl	80049a4 <vPortEnterCritical>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 80068a4:	68a3      	ldr	r3, [r4, #8]
 80068a6:	b19b      	cbz	r3, 80068d0 <iqGetTimeout+0x36>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 80068a8:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80068aa:	69a2      	ldr	r2, [r4, #24]
  iqp->q_counter--;
 80068ac:	3b01      	subs	r3, #1
 80068ae:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80068b0:	1c53      	adds	r3, r2, #1
 80068b2:	61a3      	str	r3, [r4, #24]
 80068b4:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 80068b6:	6922      	ldr	r2, [r4, #16]
 80068b8:	4293      	cmp	r3, r2
    iqp->q_rdptr = iqp->q_buffer;
 80068ba:	bf24      	itt	cs
 80068bc:	68e3      	ldrcs	r3, [r4, #12]
 80068be:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80068c0:	69e3      	ldr	r3, [r4, #28]
 80068c2:	b10b      	cbz	r3, 80068c8 <iqGetTimeout+0x2e>
    iqp->q_notify(iqp);
 80068c4:	4620      	mov	r0, r4
 80068c6:	4798      	blx	r3
  }

  osalSysUnlock();
 80068c8:	f7fe fa90 	bl	8004dec <osalSysUnlock.lto_priv.0>

  return (msg_t)b;
 80068cc:	4628      	mov	r0, r5
 80068ce:	e007      	b.n	80068e0 <iqGetTimeout+0x46>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80068d0:	4629      	mov	r1, r5
 80068d2:	4620      	mov	r0, r4
 80068d4:	f7ff feda 	bl	800668c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80068d8:	2800      	cmp	r0, #0
 80068da:	dae3      	bge.n	80068a4 <iqGetTimeout+0xa>
      osalSysUnlock();
 80068dc:	f7fe fa86 	bl	8004dec <osalSysUnlock.lto_priv.0>
}
 80068e0:	bd38      	pop	{r3, r4, r5, pc}

080068e2 <_get.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80068e2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80068e6:	3018      	adds	r0, #24
 80068e8:	f7ff bfd7 	b.w	800689a <iqGetTimeout>

080068ec <_gett.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80068ec:	3018      	adds	r0, #24
 80068ee:	f7ff bfd4 	b.w	800689a <iqGetTimeout>
	...

080068f4 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80068f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80068f8:	4604      	mov	r4, r0
 80068fa:	460d      	mov	r5, r1
 80068fc:	461f      	mov	r7, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 80068fe:	4616      	mov	r6, r2
 8006900:	b912      	cbnz	r2, 8006908 <iqReadTimeout+0x14>
 8006902:	f7fe f85f 	bl	80049c4 <vTaskEndScheduler>
 8006906:	e7fe      	b.n	8006906 <iqReadTimeout+0x12>
  size_t r = 0;
 8006908:	f04f 0800 	mov.w	r8, #0
		xReturn = xTickCount;
 800690c:	f8df a088 	ldr.w	sl, [pc, #136]	; 8006998 <iqReadTimeout+0xa4>
  qnotify_t nfy = iqp->q_notify;
 8006910:	f8d0 901c 	ldr.w	r9, [r0, #28]

  osalSysLock();
 8006914:	f7fe f846 	bl	80049a4 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006918:	f7ff fb00 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800691c:	f8da 3000 	ldr.w	r3, [sl]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006920:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 8006924:	18fb      	adds	r3, r7, r3
 8006926:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
 8006928:	68a3      	ldr	r3, [r4, #8]
 800692a:	b1e3      	cbz	r3, 8006966 <iqReadTimeout+0x72>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800692c:	68a3      	ldr	r3, [r4, #8]
 800692e:	3b01      	subs	r3, #1
 8006930:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8006932:	69a3      	ldr	r3, [r4, #24]
 8006934:	1c5a      	adds	r2, r3, #1
 8006936:	61a2      	str	r2, [r4, #24]
 8006938:	781b      	ldrb	r3, [r3, #0]
 800693a:	f805 3b01 	strb.w	r3, [r5], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800693e:	6923      	ldr	r3, [r4, #16]
 8006940:	69a2      	ldr	r2, [r4, #24]
 8006942:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8006944:	bf24      	itt	cs
 8006946:	68e3      	ldrcs	r3, [r4, #12]
 8006948:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800694a:	f1b9 0f00 	cmp.w	r9, #0
 800694e:	d001      	beq.n	8006954 <iqReadTimeout+0x60>
      nfy(iqp);
 8006950:	4620      	mov	r0, r4
 8006952:	47c8      	blx	r9
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8006954:	f7fe fa4a 	bl	8004dec <osalSysUnlock.lto_priv.0>

    r++;
    if (--n == 0U) {
 8006958:	3e01      	subs	r6, #1
    r++;
 800695a:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 800695e:	d016      	beq.n	800698e <iqReadTimeout+0x9a>
      return r;
    }

    osalSysLock();
 8006960:	f7fe f820 	bl	80049a4 <vPortEnterCritical>
    while (iqIsEmptyI(iqp)) {
 8006964:	e7e0      	b.n	8006928 <iqReadTimeout+0x34>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006966:	f11b 0f03 	cmn.w	fp, #3
 800696a:	d906      	bls.n	800697a <iqReadTimeout+0x86>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800696c:	4639      	mov	r1, r7
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 800696e:	4620      	mov	r0, r4
 8006970:	f7ff fe8c 	bl	800668c <osalThreadEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8006974:	2800      	cmp	r0, #0
 8006976:	d0d7      	beq.n	8006928 <iqReadTimeout+0x34>
 8006978:	e007      	b.n	800698a <iqReadTimeout+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800697a:	f7ff facf 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800697e:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8006982:	9b01      	ldr	r3, [sp, #4]
 8006984:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8006986:	428f      	cmp	r7, r1
 8006988:	d2f1      	bcs.n	800696e <iqReadTimeout+0x7a>
        osalSysUnlock();
 800698a:	f7fe fa2f 	bl	8004dec <osalSysUnlock.lto_priv.0>
  }
}
 800698e:	4640      	mov	r0, r8
 8006990:	b003      	add	sp, #12
 8006992:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006996:	bf00      	nop
 8006998:	20001648 	.word	0x20001648

0800699c <_read.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800699c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80069a0:	3018      	adds	r0, #24
 80069a2:	f7ff bfa7 	b.w	80068f4 <iqReadTimeout>

080069a6 <_readt.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80069a6:	3018      	adds	r0, #24
 80069a8:	f7ff bfa4 	b.w	80068f4 <iqReadTimeout>

080069ac <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80069ac:	b570      	push	{r4, r5, r6, lr}
 80069ae:	4604      	mov	r4, r0
 80069b0:	460d      	mov	r5, r1
 80069b2:	4616      	mov	r6, r2

  osalSysLock();
 80069b4:	f7fd fff6 	bl	80049a4 <vPortEnterCritical>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80069b8:	68a3      	ldr	r3, [r4, #8]
 80069ba:	b1a3      	cbz	r3, 80069e6 <oqPutTimeout+0x3a>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80069bc:	68a3      	ldr	r3, [r4, #8]
 80069be:	3b01      	subs	r3, #1
 80069c0:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80069c2:	6963      	ldr	r3, [r4, #20]
 80069c4:	1c5a      	adds	r2, r3, #1
 80069c6:	6162      	str	r2, [r4, #20]
 80069c8:	701d      	strb	r5, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80069ca:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 80069ce:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80069d0:	bf24      	itt	cs
 80069d2:	68e3      	ldrcs	r3, [r4, #12]
 80069d4:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80069d6:	69e3      	ldr	r3, [r4, #28]
 80069d8:	b10b      	cbz	r3, 80069de <oqPutTimeout+0x32>
    oqp->q_notify(oqp);
 80069da:	4620      	mov	r0, r4
 80069dc:	4798      	blx	r3
  }

  osalSysUnlock();
 80069de:	f7fe fa05 	bl	8004dec <osalSysUnlock.lto_priv.0>
 80069e2:	2000      	movs	r0, #0
 80069e4:	e007      	b.n	80069f6 <oqPutTimeout+0x4a>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80069e6:	4631      	mov	r1, r6
 80069e8:	4620      	mov	r0, r4
 80069ea:	f7ff fe4f 	bl	800668c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80069ee:	2800      	cmp	r0, #0
 80069f0:	dae2      	bge.n	80069b8 <oqPutTimeout+0xc>
      osalSysUnlock();
 80069f2:	f7fe f9fb 	bl	8004dec <osalSysUnlock.lto_priv.0>

  return MSG_OK;
}
 80069f6:	bd70      	pop	{r4, r5, r6, pc}

080069f8 <_put.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80069f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80069fc:	303c      	adds	r0, #60	; 0x3c
 80069fe:	f7ff bfd5 	b.w	80069ac <oqPutTimeout>

08006a02 <_putt.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8006a02:	303c      	adds	r0, #60	; 0x3c
 8006a04:	f7ff bfd2 	b.w	80069ac <oqPutTimeout>

08006a08 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8006a08:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006a0c:	4604      	mov	r4, r0
 8006a0e:	460d      	mov	r5, r1
 8006a10:	461f      	mov	r7, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 8006a12:	4616      	mov	r6, r2
 8006a14:	b912      	cbnz	r2, 8006a1c <oqWriteTimeout+0x14>
 8006a16:	f7fd ffd5 	bl	80049c4 <vTaskEndScheduler>
 8006a1a:	e7fe      	b.n	8006a1a <oqWriteTimeout+0x12>
  size_t w = 0;
 8006a1c:	f04f 0800 	mov.w	r8, #0
 8006a20:	f8df a088 	ldr.w	sl, [pc, #136]	; 8006aac <oqWriteTimeout+0xa4>
  qnotify_t nfy = oqp->q_notify;
 8006a24:	f8d0 901c 	ldr.w	r9, [r0, #28]

  osalSysLock();
 8006a28:	f7fd ffbc 	bl	80049a4 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006a2c:	f7ff fa76 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8006a30:	f8da 3000 	ldr.w	r3, [sl]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006a34:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 8006a38:	18fb      	adds	r3, r7, r3
 8006a3a:	9301      	str	r3, [sp, #4]
    while (oqIsFullI(oqp)) {
 8006a3c:	68a3      	ldr	r3, [r4, #8]
 8006a3e:	b1e3      	cbz	r3, 8006a7a <oqWriteTimeout+0x72>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8006a40:	68a3      	ldr	r3, [r4, #8]
 8006a42:	3b01      	subs	r3, #1
 8006a44:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8006a46:	6963      	ldr	r3, [r4, #20]
 8006a48:	1c5a      	adds	r2, r3, #1
 8006a4a:	6162      	str	r2, [r4, #20]
 8006a4c:	f815 2b01 	ldrb.w	r2, [r5], #1
 8006a50:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8006a52:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8006a56:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8006a58:	bf24      	itt	cs
 8006a5a:	68e3      	ldrcs	r3, [r4, #12]
 8006a5c:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8006a5e:	f1b9 0f00 	cmp.w	r9, #0
 8006a62:	d001      	beq.n	8006a68 <oqWriteTimeout+0x60>
      nfy(oqp);
 8006a64:	4620      	mov	r0, r4
 8006a66:	47c8      	blx	r9
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8006a68:	f7fe f9c0 	bl	8004dec <osalSysUnlock.lto_priv.0>

    w++;
    if (--n == 0U) {
 8006a6c:	3e01      	subs	r6, #1
    w++;
 8006a6e:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 8006a72:	d016      	beq.n	8006aa2 <oqWriteTimeout+0x9a>
      return w;
    }

    osalSysLock();
 8006a74:	f7fd ff96 	bl	80049a4 <vPortEnterCritical>
  while (true) {
 8006a78:	e7e0      	b.n	8006a3c <oqWriteTimeout+0x34>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006a7a:	f11b 0f03 	cmn.w	fp, #3
 8006a7e:	d906      	bls.n	8006a8e <oqWriteTimeout+0x86>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8006a80:	4639      	mov	r1, r7
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8006a82:	4620      	mov	r0, r4
 8006a84:	f7ff fe02 	bl	800668c <osalThreadEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8006a88:	2800      	cmp	r0, #0
 8006a8a:	d0d7      	beq.n	8006a3c <oqWriteTimeout+0x34>
 8006a8c:	e007      	b.n	8006a9e <oqWriteTimeout+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006a8e:	f7ff fa45 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8006a92:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8006a96:	9b01      	ldr	r3, [sp, #4]
 8006a98:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8006a9a:	428f      	cmp	r7, r1
 8006a9c:	d2f1      	bcs.n	8006a82 <oqWriteTimeout+0x7a>
        osalSysUnlock();
 8006a9e:	f7fe f9a5 	bl	8004dec <osalSysUnlock.lto_priv.0>
  }
}
 8006aa2:	4640      	mov	r0, r8
 8006aa4:	b003      	add	sp, #12
 8006aa6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006aaa:	bf00      	nop
 8006aac:	20001648 	.word	0x20001648

08006ab0 <_write.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8006ab0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006ab4:	303c      	adds	r0, #60	; 0x3c
 8006ab6:	f7ff bfa7 	b.w	8006a08 <oqWriteTimeout>

08006aba <_writet.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8006aba:	303c      	adds	r0, #60	; 0x3c
 8006abc:	f7ff bfa4 	b.w	8006a08 <oqWriteTimeout>

08006ac0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8006ac0:	b5f0      	push	{r4, r5, r6, r7, lr}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8006ac2:	f100 040b 	add.w	r4, r0, #11
 8006ac6:	4623      	mov	r3, r4
  do {
    i = (int)(l % radix);
 8006ac8:	460d      	mov	r5, r1
 8006aca:	fbb1 f1f2 	udiv	r1, r1, r2
 8006ace:	fb02 5711 	mls	r7, r2, r1, r5
    i += '0';
 8006ad2:	f107 0630 	add.w	r6, r7, #48	; 0x30
    if (i > '9')
 8006ad6:	2e39      	cmp	r6, #57	; 0x39
      i += 'A' - '0' - 10;
 8006ad8:	bfc8      	it	gt
 8006ada:	f107 0637 	addgt.w	r6, r7, #55	; 0x37
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8006ade:	4295      	cmp	r5, r2
    *--q = i;
 8006ae0:	f803 6d01 	strb.w	r6, [r3, #-1]!
  } while ((ll /= radix) != 0);
 8006ae4:	d2f0      	bcs.n	8006ac8 <long_to_string_with_divisor.constprop.0+0x8>
 8006ae6:	1e42      	subs	r2, r0, #1

  i = (int)(p + MAX_FILLER - q);
 8006ae8:	1ae1      	subs	r1, r4, r3
  do
    *p++ = *q++;
 8006aea:	f813 5b01 	ldrb.w	r5, [r3], #1
  while (--i);
 8006aee:	429c      	cmp	r4, r3
    *p++ = *q++;
 8006af0:	f802 5f01 	strb.w	r5, [r2, #1]!
  while (--i);
 8006af4:	d1f9      	bne.n	8006aea <long_to_string_with_divisor.constprop.0+0x2a>

  return p;
}
 8006af6:	4408      	add	r0, r1
 8006af8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08006afc <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006afc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b00:	460b      	mov	r3, r1
 8006b02:	4680      	mov	r8, r0
 8006b04:	4614      	mov	r4, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8006b06:	f04f 0900 	mov.w	r9, #0
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006b0a:	b087      	sub	sp, #28
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006b0c:	461f      	mov	r7, r3
 8006b0e:	f817 1b01 	ldrb.w	r1, [r7], #1
    if (c == 0)
 8006b12:	2900      	cmp	r1, #0
 8006b14:	f000 8152 	beq.w	8006dbc <chvprintf+0x2c0>
      return n;
    if (c != '%') {
 8006b18:	2925      	cmp	r1, #37	; 0x25
 8006b1a:	d007      	beq.n	8006b2c <chvprintf+0x30>
      streamPut(chp, (uint8_t)c);
 8006b1c:	f8d8 3000 	ldr.w	r3, [r8]
 8006b20:	4640      	mov	r0, r8
 8006b22:	689b      	ldr	r3, [r3, #8]
 8006b24:	4798      	blx	r3
      n++;
 8006b26:	f109 0901 	add.w	r9, r9, #1
      continue;
 8006b2a:	e112      	b.n	8006d52 <chvprintf+0x256>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8006b2c:	785a      	ldrb	r2, [r3, #1]
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8006b2e:	f04f 0b00 	mov.w	fp, #0
    if (*fmt == '-') {
 8006b32:	2a2d      	cmp	r2, #45	; 0x2d
      fmt++;
 8006b34:	bf08      	it	eq
 8006b36:	1c9f      	addeq	r7, r3, #2
    if (*fmt == '0') {
 8006b38:	f897 a000 	ldrb.w	sl, [r7]
      left_align = TRUE;
 8006b3c:	bf0c      	ite	eq
 8006b3e:	2301      	moveq	r3, #1
    left_align = FALSE;
 8006b40:	2300      	movne	r3, #0
    if (*fmt == '0') {
 8006b42:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
    filler = ' ';
 8006b46:	bf18      	it	ne
 8006b48:	f04f 0a20 	movne.w	sl, #32
    left_align = FALSE;
 8006b4c:	9301      	str	r3, [sp, #4]
      fmt++;
 8006b4e:	bf08      	it	eq
 8006b50:	3701      	addeq	r7, #1
    while (TRUE) {
      c = *fmt++;
 8006b52:	f817 2b01 	ldrb.w	r2, [r7], #1
      if (c >= '0' && c <= '9')
 8006b56:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8006b5a:	b2c9      	uxtb	r1, r1
 8006b5c:	2909      	cmp	r1, #9
 8006b5e:	d904      	bls.n	8006b6a <chvprintf+0x6e>
        c -= '0';
      else if (c == '*')
 8006b60:	2a2a      	cmp	r2, #42	; 0x2a
 8006b62:	d106      	bne.n	8006b72 <chvprintf+0x76>
        c = va_arg(ap, int);
 8006b64:	f854 1b04 	ldr.w	r1, [r4], #4
 8006b68:	b2c9      	uxtb	r1, r1
      else
        break;
      width = width * 10 + c;
 8006b6a:	230a      	movs	r3, #10
 8006b6c:	fb03 1b0b 	mla	fp, r3, fp, r1
      c = *fmt++;
 8006b70:	e7ef      	b.n	8006b52 <chvprintf+0x56>
    }
    precision = 0;
    if (c == '.') {
 8006b72:	2a2e      	cmp	r2, #46	; 0x2e
    precision = 0;
 8006b74:	f04f 0100 	mov.w	r1, #0
    if (c == '.') {
 8006b78:	d10f      	bne.n	8006b9a <chvprintf+0x9e>
      while (TRUE) {
        c = *fmt++;
 8006b7a:	f817 2b01 	ldrb.w	r2, [r7], #1
        if (c >= '0' && c <= '9')
 8006b7e:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
 8006b82:	b2c0      	uxtb	r0, r0
 8006b84:	2809      	cmp	r0, #9
 8006b86:	d904      	bls.n	8006b92 <chvprintf+0x96>
          c -= '0';
        else if (c == '*')
 8006b88:	2a2a      	cmp	r2, #42	; 0x2a
 8006b8a:	d106      	bne.n	8006b9a <chvprintf+0x9e>
          c = va_arg(ap, int);
 8006b8c:	f854 0b04 	ldr.w	r0, [r4], #4
 8006b90:	b2c0      	uxtb	r0, r0
        else
          break;
        precision *= 10;
        precision += c;
 8006b92:	230a      	movs	r3, #10
 8006b94:	fb03 0101 	mla	r1, r3, r1, r0
        c = *fmt++;
 8006b98:	e7ef      	b.n	8006b7a <chvprintf+0x7e>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8006b9a:	f002 00df 	and.w	r0, r2, #223	; 0xdf
 8006b9e:	284c      	cmp	r0, #76	; 0x4c
 8006ba0:	d115      	bne.n	8006bce <chvprintf+0xd2>
      is_long = TRUE;
      if (*fmt)
 8006ba2:	7838      	ldrb	r0, [r7, #0]
 8006ba4:	b108      	cbz	r0, 8006baa <chvprintf+0xae>
        c = *fmt++;
 8006ba6:	4602      	mov	r2, r0
 8006ba8:	3701      	adds	r7, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8006baa:	2a64      	cmp	r2, #100	; 0x64
 8006bac:	d06f      	beq.n	8006c8e <chvprintf+0x192>
 8006bae:	f200 80e3 	bhi.w	8006d78 <chvprintf+0x27c>
 8006bb2:	2a58      	cmp	r2, #88	; 0x58
 8006bb4:	f000 80d9 	beq.w	8006d6a <chvprintf+0x26e>
 8006bb8:	d821      	bhi.n	8006bfe <chvprintf+0x102>
 8006bba:	2a4f      	cmp	r2, #79	; 0x4f
 8006bbc:	f000 80b5 	beq.w	8006d2a <chvprintf+0x22e>
 8006bc0:	f200 80d5 	bhi.w	8006d6e <chvprintf+0x272>
 8006bc4:	2a44      	cmp	r2, #68	; 0x44
 8006bc6:	d062      	beq.n	8006c8e <chvprintf+0x192>
 8006bc8:	2a49      	cmp	r2, #73	; 0x49
 8006bca:	d060      	beq.n	8006c8e <chvprintf+0x192>
 8006bcc:	e010      	b.n	8006bf0 <chvprintf+0xf4>
      is_long = (c >= 'A') && (c <= 'Z');
 8006bce:	f1a2 0041 	sub.w	r0, r2, #65	; 0x41
    switch (c) {
 8006bd2:	2a64      	cmp	r2, #100	; 0x64
      is_long = (c >= 'A') && (c <= 'Z');
 8006bd4:	b2c0      	uxtb	r0, r0
    switch (c) {
 8006bd6:	d056      	beq.n	8006c86 <chvprintf+0x18a>
 8006bd8:	d81e      	bhi.n	8006c18 <chvprintf+0x11c>
 8006bda:	2a55      	cmp	r2, #85	; 0x55
 8006bdc:	f000 8096 	beq.w	8006d0c <chvprintf+0x210>
 8006be0:	d80a      	bhi.n	8006bf8 <chvprintf+0xfc>
 8006be2:	2a49      	cmp	r2, #73	; 0x49
 8006be4:	d04f      	beq.n	8006c86 <chvprintf+0x18a>
 8006be6:	2a4f      	cmp	r2, #79	; 0x4f
 8006be8:	f000 809b 	beq.w	8006d22 <chvprintf+0x226>
 8006bec:	2a44      	cmp	r2, #68	; 0x44
 8006bee:	d04a      	beq.n	8006c86 <chvprintf+0x18a>
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 8006bf0:	4626      	mov	r6, r4
      *p++ = c;
 8006bf2:	f88d 200c 	strb.w	r2, [sp, #12]
      break;
 8006bf6:	e00b      	b.n	8006c10 <chvprintf+0x114>
    switch (c) {
 8006bf8:	2a58      	cmp	r2, #88	; 0x58
 8006bfa:	f000 8094 	beq.w	8006d26 <chvprintf+0x22a>
 8006bfe:	2a63      	cmp	r2, #99	; 0x63
 8006c00:	d1f6      	bne.n	8006bf0 <chvprintf+0xf4>
      *p++ = va_arg(ap, int);
 8006c02:	4626      	mov	r6, r4
      filler = ' ';
 8006c04:	f04f 0a20 	mov.w	sl, #32
      *p++ = va_arg(ap, int);
 8006c08:	f856 2b04 	ldr.w	r2, [r6], #4
 8006c0c:	f88d 200c 	strb.w	r2, [sp, #12]
    s = tmpbuf;
 8006c10:	ac03      	add	r4, sp, #12
      *p++ = c;
 8006c12:	f10d 000d 	add.w	r0, sp, #13
      break;
 8006c16:	e04c      	b.n	8006cb2 <chvprintf+0x1b6>
    switch (c) {
 8006c18:	2a69      	cmp	r2, #105	; 0x69
 8006c1a:	d034      	beq.n	8006c86 <chvprintf+0x18a>
 8006c1c:	f1a2 056f 	sub.w	r5, r2, #111	; 0x6f
 8006c20:	b2ee      	uxtb	r6, r5
 8006c22:	2e09      	cmp	r6, #9
 8006c24:	d8e4      	bhi.n	8006bf0 <chvprintf+0xf4>
 8006c26:	2d09      	cmp	r5, #9
 8006c28:	d8e2      	bhi.n	8006bf0 <chvprintf+0xf4>
 8006c2a:	a301      	add	r3, pc, #4	; (adr r3, 8006c30 <chvprintf+0x134>)
 8006c2c:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 8006c30:	08006d23 	.word	0x08006d23
 8006c34:	08006bf1 	.word	0x08006bf1
 8006c38:	08006bf1 	.word	0x08006bf1
 8006c3c:	08006bf1 	.word	0x08006bf1
 8006c40:	08006c59 	.word	0x08006c59
 8006c44:	08006bf1 	.word	0x08006bf1
 8006c48:	08006d0d 	.word	0x08006d0d
 8006c4c:	08006bf1 	.word	0x08006bf1
 8006c50:	08006bf1 	.word	0x08006bf1
 8006c54:	08006d27 	.word	0x08006d27
      if ((s = va_arg(ap, char *)) == 0)
 8006c58:	4626      	mov	r6, r4
        s = "(null)";
 8006c5a:	4b5a      	ldr	r3, [pc, #360]	; (8006dc4 <chvprintf+0x2c8>)
      if ((s = va_arg(ap, char *)) == 0)
 8006c5c:	f856 4b04 	ldr.w	r4, [r6], #4
        precision = 32767;
 8006c60:	f647 72ff 	movw	r2, #32767	; 0x7fff
        s = "(null)";
 8006c64:	2c00      	cmp	r4, #0
 8006c66:	bf08      	it	eq
 8006c68:	461c      	moveq	r4, r3
        precision = 32767;
 8006c6a:	2900      	cmp	r1, #0
 8006c6c:	bf08      	it	eq
 8006c6e:	4611      	moveq	r1, r2
 8006c70:	4620      	mov	r0, r4
 8006c72:	4421      	add	r1, r4
      for (p = s; *p && (--precision >= 0); p++)
 8006c74:	7802      	ldrb	r2, [r0, #0]
 8006c76:	b10a      	cbz	r2, 8006c7c <chvprintf+0x180>
 8006c78:	4288      	cmp	r0, r1
 8006c7a:	d102      	bne.n	8006c82 <chvprintf+0x186>
      filler = ' ';
 8006c7c:	f04f 0a20 	mov.w	sl, #32
 8006c80:	e017      	b.n	8006cb2 <chvprintf+0x1b6>
      for (p = s; *p && (--precision >= 0); p++)
 8006c82:	3001      	adds	r0, #1
 8006c84:	e7f6      	b.n	8006c74 <chvprintf+0x178>
      if (is_long)
 8006c86:	2819      	cmp	r0, #25
        l = va_arg(ap, int);
 8006c88:	f104 0604 	add.w	r6, r4, #4
      if (is_long)
 8006c8c:	d83c      	bhi.n	8006d08 <chvprintf+0x20c>
        l = va_arg(ap, long);
 8006c8e:	4626      	mov	r6, r4
 8006c90:	f856 1b04 	ldr.w	r1, [r6], #4
      if (l < 0) {
 8006c94:	2900      	cmp	r1, #0
        *p++ = '-';
 8006c96:	bfbc      	itt	lt
 8006c98:	222d      	movlt	r2, #45	; 0x2d
 8006c9a:	f88d 200c 	strblt.w	r2, [sp, #12]
  return long_to_string_with_divisor(p, num, radix, 0);
 8006c9e:	f04f 020a 	mov.w	r2, #10
        l = -l;
 8006ca2:	bfba      	itte	lt
 8006ca4:	4249      	neglt	r1, r1
        *p++ = '-';
 8006ca6:	f10d 000d 	addlt.w	r0, sp, #13
    p = tmpbuf;
 8006caa:	a803      	addge	r0, sp, #12
  return long_to_string_with_divisor(p, num, radix, 0);
 8006cac:	f7ff ff08 	bl	8006ac0 <long_to_string_with_divisor.constprop.0>
    s = tmpbuf;
 8006cb0:	ac03      	add	r4, sp, #12
    }
    i = (int)(p - s);
 8006cb2:	1b05      	subs	r5, r0, r4
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006cb4:	9901      	ldr	r1, [sp, #4]
    if ((width -= i) < 0)
 8006cb6:	ebab 0305 	sub.w	r3, fp, r5
 8006cba:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
    if (left_align == FALSE)
 8006cbe:	2900      	cmp	r1, #0
 8006cc0:	d149      	bne.n	8006d56 <chvprintf+0x25a>
      width = -width;
    if (width < 0) {
 8006cc2:	2b00      	cmp	r3, #0
      width = -width;
 8006cc4:	f1c2 0b00 	rsb	fp, r2, #0
    if (width < 0) {
 8006cc8:	dd1c      	ble.n	8006d04 <chvprintf+0x208>
      if (*s == '-' && filler == '0') {
 8006cca:	7821      	ldrb	r1, [r4, #0]
 8006ccc:	292d      	cmp	r1, #45	; 0x2d
 8006cce:	d10d      	bne.n	8006cec <chvprintf+0x1f0>
 8006cd0:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
 8006cd4:	d10a      	bne.n	8006cec <chvprintf+0x1f0>
        streamPut(chp, (uint8_t)*s++);
 8006cd6:	f8d8 3000 	ldr.w	r3, [r8]
 8006cda:	4640      	mov	r0, r8
 8006cdc:	689b      	ldr	r3, [r3, #8]
 8006cde:	9201      	str	r2, [sp, #4]
 8006ce0:	4798      	blx	r3
 8006ce2:	9a01      	ldr	r2, [sp, #4]
        n++;
        i--;
 8006ce4:	3d01      	subs	r5, #1
      n++;
 8006ce6:	f109 0901 	add.w	r9, r9, #1
        streamPut(chp, (uint8_t)*s++);
 8006cea:	3401      	adds	r4, #1
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8006cec:	f8d8 3000 	ldr.w	r3, [r8]
 8006cf0:	4651      	mov	r1, sl
 8006cf2:	4640      	mov	r0, r8
 8006cf4:	689b      	ldr	r3, [r3, #8]
 8006cf6:	9201      	str	r2, [sp, #4]
 8006cf8:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8006cfa:	f11b 0b01 	adds.w	fp, fp, #1
 8006cfe:	9a01      	ldr	r2, [sp, #4]
 8006d00:	d1f4      	bne.n	8006cec <chvprintf+0x1f0>
 8006d02:	4491      	add	r9, r2
 8006d04:	462b      	mov	r3, r5
 8006d06:	e01b      	b.n	8006d40 <chvprintf+0x244>
        l = va_arg(ap, int);
 8006d08:	6821      	ldr	r1, [r4, #0]
 8006d0a:	e7c3      	b.n	8006c94 <chvprintf+0x198>
      c = 10;
 8006d0c:	220a      	movs	r2, #10
        l = va_arg(ap, unsigned int);
 8006d0e:	4626      	mov	r6, r4
      if (is_long)
 8006d10:	2819      	cmp	r0, #25
        l = va_arg(ap, unsigned int);
 8006d12:	f856 1b04 	ldr.w	r1, [r6], #4
      if (is_long)
 8006d16:	d802      	bhi.n	8006d1e <chvprintf+0x222>
        l = va_arg(ap, unsigned long);
 8006d18:	4626      	mov	r6, r4
 8006d1a:	f856 1b04 	ldr.w	r1, [r6], #4
  return long_to_string_with_divisor(p, num, radix, 0);
 8006d1e:	a803      	add	r0, sp, #12
 8006d20:	e7c4      	b.n	8006cac <chvprintf+0x1b0>
      c = 8;
 8006d22:	2208      	movs	r2, #8
 8006d24:	e7f3      	b.n	8006d0e <chvprintf+0x212>
    switch (c) {
 8006d26:	2210      	movs	r2, #16
 8006d28:	e7f1      	b.n	8006d0e <chvprintf+0x212>
 8006d2a:	2208      	movs	r2, #8
 8006d2c:	e7f4      	b.n	8006d18 <chvprintf+0x21c>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8006d2e:	f8d8 2000 	ldr.w	r2, [r8]
 8006d32:	4640      	mov	r0, r8
 8006d34:	6892      	ldr	r2, [r2, #8]
 8006d36:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006d3a:	9301      	str	r3, [sp, #4]
 8006d3c:	4790      	blx	r2
      n++;
 8006d3e:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 8006d40:	3b01      	subs	r3, #1
 8006d42:	d5f4      	bpl.n	8006d2e <chvprintf+0x232>
 8006d44:	2d00      	cmp	r5, #0
 8006d46:	bfa8      	it	ge
 8006d48:	44a9      	addge	r9, r5
 8006d4a:	465c      	mov	r4, fp
    }

    while (width) {
 8006d4c:	b92c      	cbnz	r4, 8006d5a <chvprintf+0x25e>
 8006d4e:	4634      	mov	r4, r6
 8006d50:	44d9      	add	r9, fp
 8006d52:	463b      	mov	r3, r7
 8006d54:	e6da      	b.n	8006b0c <chvprintf+0x10>
 8006d56:	4693      	mov	fp, r2
 8006d58:	e7d4      	b.n	8006d04 <chvprintf+0x208>
      streamPut(chp, (uint8_t)filler);
 8006d5a:	f8d8 3000 	ldr.w	r3, [r8]
 8006d5e:	4651      	mov	r1, sl
 8006d60:	4640      	mov	r0, r8
 8006d62:	689b      	ldr	r3, [r3, #8]
 8006d64:	4798      	blx	r3
      n++;
      width--;
 8006d66:	3c01      	subs	r4, #1
 8006d68:	e7f0      	b.n	8006d4c <chvprintf+0x250>
    switch (c) {
 8006d6a:	2210      	movs	r2, #16
 8006d6c:	e7d4      	b.n	8006d18 <chvprintf+0x21c>
 8006d6e:	2a55      	cmp	r2, #85	; 0x55
 8006d70:	f47f af3e 	bne.w	8006bf0 <chvprintf+0xf4>
      c = 10;
 8006d74:	220a      	movs	r2, #10
      if (is_long)
 8006d76:	e7cf      	b.n	8006d18 <chvprintf+0x21c>
    switch (c) {
 8006d78:	2a69      	cmp	r2, #105	; 0x69
 8006d7a:	d088      	beq.n	8006c8e <chvprintf+0x192>
 8006d7c:	f1a2 006f 	sub.w	r0, r2, #111	; 0x6f
 8006d80:	b2c5      	uxtb	r5, r0
 8006d82:	2d09      	cmp	r5, #9
 8006d84:	f63f af34 	bhi.w	8006bf0 <chvprintf+0xf4>
 8006d88:	2809      	cmp	r0, #9
 8006d8a:	f63f af31 	bhi.w	8006bf0 <chvprintf+0xf4>
 8006d8e:	a301      	add	r3, pc, #4	; (adr r3, 8006d94 <chvprintf+0x298>)
 8006d90:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 8006d94:	08006d2b 	.word	0x08006d2b
 8006d98:	08006bf1 	.word	0x08006bf1
 8006d9c:	08006bf1 	.word	0x08006bf1
 8006da0:	08006bf1 	.word	0x08006bf1
 8006da4:	08006c59 	.word	0x08006c59
 8006da8:	08006bf1 	.word	0x08006bf1
 8006dac:	08006d75 	.word	0x08006d75
 8006db0:	08006bf1 	.word	0x08006bf1
 8006db4:	08006bf1 	.word	0x08006bf1
 8006db8:	08006d6b 	.word	0x08006d6b
    }
  }
}
 8006dbc:	4648      	mov	r0, r9
 8006dbe:	b007      	add	sp, #28
 8006dc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006dc4:	0800ba6e 	.word	0x0800ba6e

08006dc8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>:
	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
 8006dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToNotify );
 8006dca:	4604      	mov	r4, r0
 8006dcc:	b900      	cbnz	r0, 8006dd0 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x8>
 8006dce:	e7fe      	b.n	8006dce <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x6>
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006dd0:	f7ff f8a4 	bl	8005f1c <vPortValidateInterruptPriority>
		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006dd4:	f7fe fd1e 	bl	8005814 <ulPortEnterCriticalFromISR>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8006dd8:	2202      	movs	r2, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8006dda:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006dde:	4606      	mov	r6, r0
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006de0:	2b01      	cmp	r3, #1
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8006de2:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8006de6:	b2dd      	uxtb	r5, r3
					pxTCB->ulNotifiedValue = ulValue;
 8006de8:	6621      	str	r1, [r4, #96]	; 0x60
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006dea:	d11f      	bne.n	8006e2c <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x64>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8006dec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006dee:	b103      	cbz	r3, 8006df2 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x2a>
 8006df0:	e7fe      	b.n	8006df0 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x28>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006df2:	4b13      	ldr	r3, [pc, #76]	; (8006e40 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x78>)
 8006df4:	681b      	ldr	r3, [r3, #0]
 8006df6:	b9f3      	cbnz	r3, 8006e36 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x6e>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006df8:	1d27      	adds	r7, r4, #4
 8006dfa:	4638      	mov	r0, r7
 8006dfc:	f7fd fc55 	bl	80046aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006e00:	4a10      	ldr	r2, [pc, #64]	; (8006e44 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x7c>)
 8006e02:	2014      	movs	r0, #20
 8006e04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006e06:	6811      	ldr	r1, [r2, #0]
 8006e08:	409d      	lsls	r5, r3
 8006e0a:	430d      	orrs	r5, r1
 8006e0c:	4639      	mov	r1, r7
 8006e0e:	6015      	str	r5, [r2, #0]
 8006e10:	4a0d      	ldr	r2, [pc, #52]	; (8006e48 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x80>)
 8006e12:	fb00 2003 	mla	r0, r0, r3, r2
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8006e16:	f7fd fc25 	bl	8004664 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006e1a:	4b0c      	ldr	r3, [pc, #48]	; (8006e4c <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x84>)
 8006e1c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006e1e:	681b      	ldr	r3, [r3, #0]
 8006e20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006e22:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8006e24:	bf82      	ittt	hi
 8006e26:	2201      	movhi	r2, #1
 8006e28:	4b09      	ldrhi	r3, [pc, #36]	; (8006e50 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x88>)
 8006e2a:	601a      	strhi	r2, [r3, #0]
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006e2c:	4630      	mov	r0, r6
	}
 8006e2e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006e32:	f7fe bd09 	b.w	8005848 <vPortExitCriticalFromISR>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8006e36:	4807      	ldr	r0, [pc, #28]	; (8006e54 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x8c>)
 8006e38:	f104 0118 	add.w	r1, r4, #24
 8006e3c:	e7eb      	b.n	8006e16 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x4e>
 8006e3e:	bf00      	nop
 8006e40:	2000136c 	.word	0x2000136c
 8006e44:	20001374 	.word	0x20001374
 8006e48:	200011b8 	.word	0x200011b8
 8006e4c:	200011a8 	.word	0x200011a8
 8006e50:	2000164c 	.word	0x2000164c
 8006e54:	20001600 	.word	0x20001600

08006e58 <osalThreadResumeI.part.0.lto_priv.0>:
{
    osalDbgCheck(mutex != NULL);
    xSemaphoreGive(mutex->handle);
}

static inline void osalThreadResumeI(thread_reference_t* thread_reference, msg_t msg)
 8006e58:	b510      	push	{r4, lr}
 8006e5a:	4604      	mov	r4, r0
{
    osalDbgCheckClassI();
    if(*thread_reference) {
 8006e5c:	6800      	ldr	r0, [r0, #0]
 8006e5e:	b118      	cbz	r0, 8006e68 <osalThreadResumeI.part.0.lto_priv.0+0x10>
        xTaskNotifyFromISR( *thread_reference, msg, eSetValueWithOverwrite, NULL );
 8006e60:	f7ff ffb2 	bl	8006dc8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>
        *thread_reference = NULL;
 8006e64:	2300      	movs	r3, #0
 8006e66:	6023      	str	r3, [r4, #0]
    }
}
 8006e68:	bd10      	pop	{r4, pc}

08006e6a <osalThreadDequeueI>:
static bool osalThreadDequeueI(threads_queue_t* thread_queue, msg_t msg){
 8006e6a:	4603      	mov	r3, r0
 8006e6c:	b507      	push	{r0, r1, r2, lr}
    if(!thread_queue->tail){
 8006e6e:	6840      	ldr	r0, [r0, #4]
 8006e70:	b160      	cbz	r0, 8006e8c <osalThreadDequeueI+0x22>
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 8006e72:	6d82      	ldr	r2, [r0, #88]	; 0x58
    thread_reference_t toWakeUp = thread_queue->tail;
 8006e74:	9001      	str	r0, [sp, #4]
    if(prevTask){
 8006e76:	b162      	cbz	r2, 8006e92 <osalThreadDequeueI+0x28>
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 8006e78:	2000      	movs	r0, #0
 8006e7a:	6550      	str	r0, [r2, #84]	; 0x54
    thread_queue->tail = prevTask;
 8006e7c:	605a      	str	r2, [r3, #4]
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006e7e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006e82:	b143      	cbz	r3, 8006e96 <osalThreadDequeueI+0x2c>
 8006e84:	a801      	add	r0, sp, #4
 8006e86:	f7ff ffe7 	bl	8006e58 <osalThreadResumeI.part.0.lto_priv.0>
    return true;
 8006e8a:	2001      	movs	r0, #1
}
 8006e8c:	b003      	add	sp, #12
 8006e8e:	f85d fb04 	ldr.w	pc, [sp], #4
        thread_queue->head = NULL;
 8006e92:	601a      	str	r2, [r3, #0]
 8006e94:	e7f2      	b.n	8006e7c <osalThreadDequeueI+0x12>
    osalDbgCheckClassI();
 8006e96:	f7fd fd95 	bl	80049c4 <vTaskEndScheduler>
 8006e9a:	e7fe      	b.n	8006e9a <osalThreadDequeueI+0x30>

08006e9c <osalThreadDequeueNextI.constprop.0>:
void osalThreadDequeueNextI(threads_queue_t* thread_queue, msg_t msg)
 8006e9c:	b508      	push	{r3, lr}
    osalDbgCheck(thread_queue != NULL);
 8006e9e:	b910      	cbnz	r0, 8006ea6 <osalThreadDequeueNextI.constprop.0+0xa>
 8006ea0:	f7fd fd90 	bl	80049c4 <vTaskEndScheduler>
 8006ea4:	e7fe      	b.n	8006ea4 <osalThreadDequeueNextI.constprop.0+0x8>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006ea6:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006eaa:	b123      	cbz	r3, 8006eb6 <osalThreadDequeueNextI.constprop.0+0x1a>
}
 8006eac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    osalThreadDequeueI(thread_queue, msg);
 8006eb0:	2100      	movs	r1, #0
 8006eb2:	f7ff bfda 	b.w	8006e6a <osalThreadDequeueI>
    osalDbgCheckClassI();
 8006eb6:	f7fd fd85 	bl	80049c4 <vTaskEndScheduler>
 8006eba:	e7fe      	b.n	8006eba <osalThreadDequeueNextI.constprop.0+0x1e>

08006ebc <osalThreadDequeueAllI.constprop.0>:
void osalThreadDequeueAllI(threads_queue_t* thread_queue, msg_t msg)
 8006ebc:	b510      	push	{r4, lr}
    osalDbgCheck(thread_queue != NULL);
 8006ebe:	4604      	mov	r4, r0
 8006ec0:	b910      	cbnz	r0, 8006ec8 <osalThreadDequeueAllI.constprop.0+0xc>
 8006ec2:	f7fd fd7f 	bl	80049c4 <vTaskEndScheduler>
 8006ec6:	e7fe      	b.n	8006ec6 <osalThreadDequeueAllI.constprop.0+0xa>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006ec8:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006ecc:	b913      	cbnz	r3, 8006ed4 <osalThreadDequeueAllI.constprop.0+0x18>
    osalDbgCheckClassI();
 8006ece:	f7fd fd79 	bl	80049c4 <vTaskEndScheduler>
 8006ed2:	e7fe      	b.n	8006ed2 <osalThreadDequeueAllI.constprop.0+0x16>
    while(osalThreadDequeueI(thread_queue, msg));
 8006ed4:	f06f 0101 	mvn.w	r1, #1
 8006ed8:	4620      	mov	r0, r4
 8006eda:	f7ff ffc6 	bl	8006e6a <osalThreadDequeueI>
 8006ede:	2800      	cmp	r0, #0
 8006ee0:	d1f8      	bne.n	8006ed4 <osalThreadDequeueAllI.constprop.0+0x18>
}
 8006ee2:	bd10      	pop	{r4, pc}

08006ee4 <osalEventBroadcastFlagsI>:
    
    return result;
}

void osalEventBroadcastFlagsI(event_source_t* event_source, eventflags_t set)
{
 8006ee4:	b570      	push	{r4, r5, r6, lr}
    osalDbgCheck(event_source != NULL);
 8006ee6:	4604      	mov	r4, r0
 8006ee8:	b910      	cbnz	r0, 8006ef0 <osalEventBroadcastFlagsI+0xc>
 8006eea:	f7fd fd6b 	bl	80049c4 <vTaskEndScheduler>
 8006eee:	e7fe      	b.n	8006eee <osalEventBroadcastFlagsI+0xa>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006ef0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006ef4:	b34b      	cbz	r3, 8006f4a <osalEventBroadcastFlagsI+0x66>
    osalDbgCheckClassI();

    event_source->setEvents |= set;
 8006ef6:	6846      	ldr	r6, [r0, #4]
    eventflags_t localEvents = event_source->setEvents;

    if(event_source->eventCallback){
 8006ef8:	68c3      	ldr	r3, [r0, #12]
    event_source->setEvents |= set;
 8006efa:	430e      	orrs	r6, r1
 8006efc:	6046      	str	r6, [r0, #4]
    if(event_source->eventCallback){
 8006efe:	b10b      	cbz	r3, 8006f04 <osalEventBroadcastFlagsI+0x20>
        event_source->eventCallback(event_source, localEvents);
 8006f00:	4631      	mov	r1, r6
 8006f02:	4798      	blx	r3
    }

    /* Any repeaters? */
    event_repeater_t* repeater = event_source->firstRepeater;
 8006f04:	6825      	ldr	r5, [r4, #0]
    while(repeater){
 8006f06:	b965      	cbnz	r5, 8006f22 <osalEventBroadcastFlagsI+0x3e>
        event_source->setEvents &=~ repeater->triggerEvents;
        repeater = repeater->nextRepeater;
    }
   
    /* Wake up any waiting threads that may be waiting on remaining events */
    if(event_source->setEvents){
 8006f08:	6863      	ldr	r3, [r4, #4]
 8006f0a:	b30b      	cbz	r3, 8006f50 <osalEventBroadcastFlagsI+0x6c>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006f0c:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006f10:	b1c3      	cbz	r3, 8006f44 <osalEventBroadcastFlagsI+0x60>
 8006f12:	f104 0008 	add.w	r0, r4, #8
 8006f16:	f06f 0102 	mvn.w	r1, #2
        osalThreadResumeI(&event_source->waitThread, MSG_EVENT_W);
    }
}
 8006f1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006f1e:	f7ff bf9b 	b.w	8006e58 <osalThreadResumeI.part.0.lto_priv.0>
        if(localEvents & repeater->triggerEvents){
 8006f22:	692b      	ldr	r3, [r5, #16]
 8006f24:	421e      	tst	r6, r3
 8006f26:	d006      	beq.n	8006f36 <osalEventBroadcastFlagsI+0x52>
            repeater->setEvents |= localEvents;
 8006f28:	696b      	ldr	r3, [r5, #20]
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f2a:	69a9      	ldr	r1, [r5, #24]
            repeater->setEvents |= localEvents;
 8006f2c:	4333      	orrs	r3, r6
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f2e:	68e8      	ldr	r0, [r5, #12]
            repeater->setEvents |= localEvents;
 8006f30:	616b      	str	r3, [r5, #20]
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f32:	f7ff ffd7 	bl	8006ee4 <osalEventBroadcastFlagsI>
        event_source->setEvents &=~ repeater->triggerEvents;
 8006f36:	692a      	ldr	r2, [r5, #16]
 8006f38:	6863      	ldr	r3, [r4, #4]
        repeater = repeater->nextRepeater;
 8006f3a:	682d      	ldr	r5, [r5, #0]
        event_source->setEvents &=~ repeater->triggerEvents;
 8006f3c:	ea23 0302 	bic.w	r3, r3, r2
 8006f40:	6063      	str	r3, [r4, #4]
 8006f42:	e7e0      	b.n	8006f06 <osalEventBroadcastFlagsI+0x22>
 8006f44:	f7fd fd3e 	bl	80049c4 <vTaskEndScheduler>
 8006f48:	e7fe      	b.n	8006f48 <osalEventBroadcastFlagsI+0x64>
    osalDbgCheckClassI();
 8006f4a:	f7fd fd3b 	bl	80049c4 <vTaskEndScheduler>
 8006f4e:	e7fe      	b.n	8006f4e <osalEventBroadcastFlagsI+0x6a>
}
 8006f50:	bd70      	pop	{r4, r5, r6, pc}

08006f52 <sduDataTransmitted>:
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006f52:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006f56:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006f5a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006f5c:	4605      	mov	r5, r0
 8006f5e:	460e      	mov	r6, r1
  if (sdup == NULL) {
 8006f60:	b394      	cbz	r4, 8006fc8 <sduDataTransmitted+0x76>
  osalSysLockFromISR();
 8006f62:	f7fe fc69 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 8006f66:	2108      	movs	r1, #8
 8006f68:	1d20      	adds	r0, r4, #4
 8006f6a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 8006f6e:	f7ff ffb9 	bl	8006ee4 <osalEventBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8006f72:	68fb      	ldr	r3, [r7, #12]
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8006f74:	f104 0850 	add.w	r8, r4, #80	; 0x50
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8006f78:	695b      	ldr	r3, [r3, #20]
 8006f7a:	681b      	ldr	r3, [r3, #0]
 8006f7c:	b1bb      	cbz	r3, 8006fae <sduDataTransmitted+0x5c>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006f7e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006f82:	b33b      	cbz	r3, 8006fd4 <sduDataTransmitted+0x82>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8006f84:	e9d4 2318 	ldrd	r2, r3, [r4, #96]	; 0x60
 8006f88:	429a      	cmp	r2, r3
 8006f8a:	d104      	bne.n	8006f96 <sduDataTransmitted+0x44>
 8006f8c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8006f8e:	b112      	cbz	r2, 8006f96 <sduDataTransmitted+0x44>
 8006f90:	f7fd fd18 	bl	80049c4 <vTaskEndScheduler>
 8006f94:	e7fe      	b.n	8006f94 <sduDataTransmitted+0x42>
  obqp->bcounter++;
 8006f96:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8006f98:	3201      	adds	r2, #1
 8006f9a:	65e2      	str	r2, [r4, #92]	; 0x5c
  obqp->brdptr += obqp->bsize;
 8006f9c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8006f9e:	4413      	add	r3, r2
  if (obqp->brdptr >= obqp->btop) {
 8006fa0:	6ea2      	ldr	r2, [r4, #104]	; 0x68
  obqp->brdptr += obqp->bsize;
 8006fa2:	6663      	str	r3, [r4, #100]	; 0x64
  if (obqp->brdptr >= obqp->btop) {
 8006fa4:	4293      	cmp	r3, r2
 8006fa6:	d212      	bcs.n	8006fce <sduDataTransmitted+0x7c>
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8006fa8:	4640      	mov	r0, r8
 8006faa:	f7ff ff77 	bl	8006e9c <osalThreadDequeueNextI.constprop.0>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8006fae:	4640      	mov	r0, r8
 8006fb0:	a901      	add	r1, sp, #4
 8006fb2:	f7fd fd39 	bl	8004a28 <obqGetFullBufferI>
  if (buf != NULL) {
 8006fb6:	4602      	mov	r2, r0
 8006fb8:	b178      	cbz	r0, 8006fda <sduDataTransmitted+0x88>
    usbStartTransmitI(usbp, ep, buf, n);
 8006fba:	9b01      	ldr	r3, [sp, #4]
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8006fbc:	4631      	mov	r1, r6
 8006fbe:	4628      	mov	r0, r5
 8006fc0:	f7fd fdca 	bl	8004b58 <usbStartTransmitI>
  osalSysUnlockFromISR();
 8006fc4:	f7fe fc4c 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
}
 8006fc8:	b002      	add	sp, #8
 8006fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    obqp->brdptr = obqp->buffers;
 8006fce:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006fd0:	6663      	str	r3, [r4, #100]	; 0x64
 8006fd2:	e7e9      	b.n	8006fa8 <sduDataTransmitted+0x56>
  osalDbgCheckClassI();
 8006fd4:	f7fd fcf6 	bl	80049c4 <vTaskEndScheduler>
 8006fd8:	e7fe      	b.n	8006fd8 <sduDataTransmitted+0x86>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8006fda:	68fb      	ldr	r3, [r7, #12]
 8006fdc:	695a      	ldr	r2, [r3, #20]
 8006fde:	6812      	ldr	r2, [r2, #0]
 8006fe0:	b132      	cbz	r2, 8006ff0 <sduDataTransmitted+0x9e>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8006fe2:	8a1b      	ldrh	r3, [r3, #16]
 8006fe4:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8006fe6:	4013      	ands	r3, r2
 8006fe8:	d102      	bne.n	8006ff0 <sduDataTransmitted+0x9e>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8006fea:	f105 0274 	add.w	r2, r5, #116	; 0x74
 8006fee:	e7e5      	b.n	8006fbc <sduDataTransmitted+0x6a>
    if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006ff0:	f8d4 2498 	ldr.w	r2, [r4, #1176]	; 0x498
 8006ff4:	6893      	ldr	r3, [r2, #8]
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	d0e4      	beq.n	8006fc4 <sduDataTransmitted+0x72>
 8006ffa:	2101      	movs	r1, #1
 8006ffc:	6810      	ldr	r0, [r2, #0]
 8006ffe:	4798      	blx	r3
 8007000:	e7e0      	b.n	8006fc4 <sduDataTransmitted+0x72>

08007002 <osalThreadResumeI.lto_priv.0>:
{
 8007002:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007004:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007008:	b11b      	cbz	r3, 8007012 <osalThreadResumeI.lto_priv.0+0x10>
}
 800700a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800700e:	f7ff bf23 	b.w	8006e58 <osalThreadResumeI.part.0.lto_priv.0>
    osalDbgCheckClassI();
 8007012:	f7fd fcd7 	bl	80049c4 <vTaskEndScheduler>
 8007016:	e7fe      	b.n	8007016 <osalThreadResumeI.lto_priv.0+0x14>

08007018 <i2c_lld_serve_rx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8007018:	f011 0108 	ands.w	r1, r1, #8
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800701c:	b538      	push	{r3, r4, r5, lr}
 800701e:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8007020:	d002      	beq.n	8007028 <i2c_lld_serve_rx_end_irq+0x10>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8007022:	f7fd fccf 	bl	80049c4 <vTaskEndScheduler>
 8007026:	e7fe      	b.n	8007026 <i2c_lld_serve_rx_end_irq+0xe>
  dmaStreamDisable(i2cp->dmarx);
 8007028:	6f02      	ldr	r2, [r0, #112]	; 0x70
  I2C_TypeDef *dp = i2cp->i2c;
 800702a:	6f83      	ldr	r3, [r0, #120]	; 0x78
  dmaStreamDisable(i2cp->dmarx);
 800702c:	6855      	ldr	r5, [r2, #4]
 800702e:	6828      	ldr	r0, [r5, #0]
 8007030:	f020 000f 	bic.w	r0, r0, #15
 8007034:	6028      	str	r0, [r5, #0]
 8007036:	7c15      	ldrb	r5, [r2, #16]
 8007038:	6810      	ldr	r0, [r2, #0]
 800703a:	220e      	movs	r2, #14
 800703c:	40aa      	lsls	r2, r5
 800703e:	6042      	str	r2, [r0, #4]
  dp->CR2 &= ~I2C_CR2_LAST;
 8007040:	685a      	ldr	r2, [r3, #4]
 8007042:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8007046:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8007048:	681a      	ldr	r2, [r3, #0]
 800704a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800704e:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8007050:	681a      	ldr	r2, [r3, #0]
 8007052:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007056:	601a      	str	r2, [r3, #0]
  _i2c_wakeup_isr(i2cp);
 8007058:	f7fe fbee 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 800705c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8007060:	f7ff ffcf 	bl	8007002 <osalThreadResumeI.lto_priv.0>
}
 8007064:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  _i2c_wakeup_isr(i2cp);
 8007068:	f7fe bbfa 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>

0800706c <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 800706c:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800706e:	4d4d      	ldr	r5, [pc, #308]	; (80071a4 <VectorBC+0x138>)
 8007070:	6fac      	ldr	r4, [r5, #120]	; 0x78
  i2cp->numInterrupts++;
 8007072:	f8d5 2080 	ldr.w	r2, [r5, #128]	; 0x80
  uint32_t regSR2 = dp->SR2;
 8007076:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 8007078:	6966      	ldr	r6, [r4, #20]
  i2cp->numInterrupts++;
 800707a:	3201      	adds	r2, #1
  if ((event & I2C_SR1_BERR) || (i2cp->numInterrupts>=30)) {
 800707c:	05f1      	lsls	r1, r6, #23
  i2cp->numInterrupts++;
 800707e:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
  if ((event & I2C_SR1_BERR) || (i2cp->numInterrupts>=30)) {
 8007082:	d401      	bmi.n	8007088 <VectorBC+0x1c>
 8007084:	2a1d      	cmp	r2, #29
 8007086:	d91c      	bls.n	80070c2 <VectorBC+0x56>
    dp->SR1 &= ~I2C_SR1_BERR;
 8007088:	6963      	ldr	r3, [r4, #20]
    _i2c_wakeup_error_isr(i2cp);
 800708a:	f06f 0101 	mvn.w	r1, #1
    dp->SR1 &= ~I2C_SR1_BERR;
 800708e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007092:	6163      	str	r3, [r4, #20]
    dp->CR2 &=~ I2C_CR2_ITEVTEN | I2C_CR2_ITERREN | I2C_CR2_ITBUFEN;
 8007094:	6863      	ldr	r3, [r4, #4]
 8007096:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800709a:	6063      	str	r3, [r4, #4]
    i2cp->errors = I2C_BUS_ERROR;
 800709c:	2301      	movs	r3, #1
 800709e:	60ab      	str	r3, [r5, #8]
    _i2c_wakeup_error_isr(i2cp);
 80070a0:	f7fe fbca 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 80070a4:	4840      	ldr	r0, [pc, #256]	; (80071a8 <VectorBC+0x13c>)
 80070a6:	f7ff ffac 	bl	8007002 <osalThreadResumeI.lto_priv.0>
 80070aa:	f7fe fbd9 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
    xYieldPending = pdFALSE;
 80070ae:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 80070b0:	4b3e      	ldr	r3, [pc, #248]	; (80071ac <VectorBC+0x140>)
 80070b2:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 80070b4:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 80070b6:	2a00      	cmp	r2, #0
 80070b8:	d072      	beq.n	80071a0 <VectorBC+0x134>
}
 80070ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80070be:	f7fc be5d 	b.w	8003d7c <Vector6C.part.0>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80070c2:	4a3b      	ldr	r2, [pc, #236]	; (80071b0 <VectorBC+0x144>)
 80070c4:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 80070c8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80070cc:	4293      	cmp	r3, r2
 80070ce:	d030      	beq.n	8007132 <VectorBC+0xc6>
 80070d0:	d80a      	bhi.n	80070e8 <VectorBC+0x7c>
 80070d2:	3a07      	subs	r2, #7
 80070d4:	4293      	cmp	r3, r2
 80070d6:	d01d      	beq.n	8007114 <VectorBC+0xa8>
 80070d8:	3201      	adds	r2, #1
 80070da:	4293      	cmp	r3, r2
 80070dc:	d02e      	beq.n	800713c <VectorBC+0xd0>
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80070de:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 80070e2:	bf18      	it	ne
 80070e4:	69a3      	ldrne	r3, [r4, #24]
 80070e6:	e7e2      	b.n	80070ae <VectorBC+0x42>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80070e8:	4a32      	ldr	r2, [pc, #200]	; (80071b4 <VectorBC+0x148>)
 80070ea:	4293      	cmp	r3, r2
 80070ec:	d03c      	beq.n	8007168 <VectorBC+0xfc>
 80070ee:	3202      	adds	r2, #2
 80070f0:	4293      	cmp	r3, r2
 80070f2:	d1f4      	bne.n	80070de <VectorBC+0x72>
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 80070f4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80070f6:	685b      	ldr	r3, [r3, #4]
 80070f8:	6859      	ldr	r1, [r3, #4]
 80070fa:	2900      	cmp	r1, #0
 80070fc:	d03f      	beq.n	800717e <VectorBC+0x112>
      i2cp->addr |= 0x01;
 80070fe:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 8007102:	f043 0301 	orr.w	r3, r3, #1
 8007106:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800710a:	6823      	ldr	r3, [r4, #0]
 800710c:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 8007110:	6023      	str	r3, [r4, #0]
      return;
 8007112:	e7cc      	b.n	80070ae <VectorBC+0x42>
    if ((i2cp->addr >> 8) > 0) { 
 8007114:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
 8007118:	0a13      	lsrs	r3, r2, #8
 800711a:	d008      	beq.n	800712e <VectorBC+0xc2>
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800711c:	f003 0306 	and.w	r3, r3, #6
 8007120:	f002 0201 	and.w	r2, r2, #1
 8007124:	4313      	orrs	r3, r2
 8007126:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800712a:	6123      	str	r3, [r4, #16]
    break;
 800712c:	e7d7      	b.n	80070de <VectorBC+0x72>
      dp->DR = i2cp->addr;
 800712e:	6122      	str	r2, [r4, #16]
 8007130:	e7d5      	b.n	80070de <VectorBC+0x72>
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8007132:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 8007136:	f3c3 0347 	ubfx	r3, r3, #1, #8
 800713a:	e7f6      	b.n	800712a <VectorBC+0xbe>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800713c:	6863      	ldr	r3, [r4, #4]
 800713e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007142:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8007144:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007146:	685b      	ldr	r3, [r3, #4]
 8007148:	681a      	ldr	r2, [r3, #0]
 800714a:	f042 0201 	orr.w	r2, r2, #1
 800714e:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8007150:	6862      	ldr	r2, [r4, #4]
 8007152:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8007156:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8007158:	685b      	ldr	r3, [r3, #4]
 800715a:	2b01      	cmp	r3, #1
 800715c:	d8bf      	bhi.n	80070de <VectorBC+0x72>
      dp->CR1 &= ~I2C_CR1_ACK;
 800715e:	6823      	ldr	r3, [r4, #0]
 8007160:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007164:	6023      	str	r3, [r4, #0]
 8007166:	e7ba      	b.n	80070de <VectorBC+0x72>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8007168:	6863      	ldr	r3, [r4, #4]
 800716a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800716e:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8007170:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8007172:	685a      	ldr	r2, [r3, #4]
 8007174:	6813      	ldr	r3, [r2, #0]
 8007176:	f043 0301 	orr.w	r3, r3, #1
 800717a:	6013      	str	r3, [r2, #0]
    break;
 800717c:	e7af      	b.n	80070de <VectorBC+0x72>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800717e:	6863      	ldr	r3, [r4, #4]
 8007180:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007184:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8007186:	6823      	ldr	r3, [r4, #0]
 8007188:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800718c:	6023      	str	r3, [r4, #0]
    _i2c_wakeup_isr(i2cp);
 800718e:	f7fe fb53 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 8007192:	f105 0060 	add.w	r0, r5, #96	; 0x60
 8007196:	f7ff ff34 	bl	8007002 <osalThreadResumeI.lto_priv.0>
 800719a:	f7fe fb61 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
    break;
 800719e:	e79e      	b.n	80070de <VectorBC+0x72>
}
 80071a0:	bd70      	pop	{r4, r5, r6, pc}
 80071a2:	bf00      	nop
 80071a4:	20000934 	.word	0x20000934
 80071a8:	20000994 	.word	0x20000994
 80071ac:	2000164c 	.word	0x2000164c
 80071b0:	00030008 	.word	0x00030008
 80071b4:	00070082 	.word	0x00070082

080071b8 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80071b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 80071ba:	4b35      	ldr	r3, [pc, #212]	; (8007290 <VectorC0+0xd8>)
 80071bc:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80071be:	6951      	ldr	r1, [r2, #20]

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80071c0:	f401 445f 	and.w	r4, r1, #57088	; 0xdf00
 80071c4:	43e4      	mvns	r4, r4
 80071c6:	6154      	str	r4, [r2, #20]
  dmaStreamDisable(i2cp->dmatx);
 80071c8:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  uint16_t sr = I2CD1.i2c->SR1;
 80071ca:	b288      	uxth	r0, r1
  dmaStreamDisable(i2cp->dmatx);
 80071cc:	6866      	ldr	r6, [r4, #4]
 80071ce:	6835      	ldr	r5, [r6, #0]
 80071d0:	f025 050f 	bic.w	r5, r5, #15
 80071d4:	6035      	str	r5, [r6, #0]
 80071d6:	7c25      	ldrb	r5, [r4, #16]
 80071d8:	6826      	ldr	r6, [r4, #0]
 80071da:	240e      	movs	r4, #14
 80071dc:	fa04 f505 	lsl.w	r5, r4, r5
 80071e0:	6075      	str	r5, [r6, #4]
  dmaStreamDisable(i2cp->dmarx);
 80071e2:	6f1d      	ldr	r5, [r3, #112]	; 0x70
 80071e4:	686f      	ldr	r7, [r5, #4]
 80071e6:	683e      	ldr	r6, [r7, #0]
 80071e8:	f026 060f 	bic.w	r6, r6, #15
 80071ec:	603e      	str	r6, [r7, #0]
 80071ee:	682e      	ldr	r6, [r5, #0]
 80071f0:	7c2d      	ldrb	r5, [r5, #16]
 80071f2:	40ac      	lsls	r4, r5
 80071f4:	6074      	str	r4, [r6, #4]
  i2cp->numInterrupts++;
 80071f6:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 80071fa:	3401      	adds	r4, #1
 80071fc:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8007200:	f411 7480 	ands.w	r4, r1, #256	; 0x100
    i2cp->errors |= I2C_BUS_ERROR;
 8007204:	bf18      	it	ne
 8007206:	2401      	movne	r4, #1
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8007208:	0587      	lsls	r7, r0, #22
    i2cp->errors |= I2C_BUS_ERROR;
 800720a:	609c      	str	r4, [r3, #8]
    i2cp->errors |= I2C_ARBITRATION_LOST;
 800720c:	bf42      	ittt	mi
 800720e:	689c      	ldrmi	r4, [r3, #8]
 8007210:	f044 0402 	orrmi.w	r4, r4, #2
 8007214:	609c      	strmi	r4, [r3, #8]
  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8007216:	0546      	lsls	r6, r0, #21
 8007218:	d50b      	bpl.n	8007232 <VectorC0+0x7a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800721a:	6855      	ldr	r5, [r2, #4]
    i2cp->errors |= I2C_ACK_FAILURE;
 800721c:	689c      	ldr	r4, [r3, #8]
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800721e:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 8007222:	6055      	str	r5, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8007224:	6815      	ldr	r5, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8007226:	f044 0404 	orr.w	r4, r4, #4
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800722a:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 800722e:	6015      	str	r5, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8007230:	609c      	str	r4, [r3, #8]
  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8007232:	0505      	lsls	r5, r0, #20
    i2cp->errors |= I2C_OVERRUN;
 8007234:	bf42      	ittt	mi
 8007236:	689a      	ldrmi	r2, [r3, #8]
 8007238:	f042 0208 	orrmi.w	r2, r2, #8
 800723c:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800723e:	0444      	lsls	r4, r0, #17
    i2cp->errors |= I2C_TIMEOUT;
 8007240:	bf42      	ittt	mi
 8007242:	689a      	ldrmi	r2, [r3, #8]
 8007244:	f042 0220 	orrmi.w	r2, r2, #32
 8007248:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800724a:	04c0      	lsls	r0, r0, #19
    i2cp->errors |= I2C_PEC_ERROR;
 800724c:	bf42      	ittt	mi
 800724e:	689a      	ldrmi	r2, [r3, #8]
 8007250:	f042 0210 	orrmi.w	r2, r2, #16
 8007254:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8007256:	0409      	lsls	r1, r1, #16
    i2cp->errors |= I2C_SMB_ALERT;
 8007258:	689a      	ldr	r2, [r3, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800725a:	d50c      	bpl.n	8007276 <VectorC0+0xbe>
    i2cp->errors |= I2C_SMB_ALERT;
 800725c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8007260:	609a      	str	r2, [r3, #8]
    _i2c_wakeup_error_isr(i2cp);
 8007262:	f7fe fae9 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 8007266:	f06f 0101 	mvn.w	r1, #1
 800726a:	480a      	ldr	r0, [pc, #40]	; (8007294 <VectorC0+0xdc>)
 800726c:	f7ff fec9 	bl	8007002 <osalThreadResumeI.lto_priv.0>
 8007270:	f7fe faf6 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
 8007274:	e001      	b.n	800727a <VectorC0+0xc2>
  if (i2cp->errors != I2C_NO_ERROR)
 8007276:	2a00      	cmp	r2, #0
 8007278:	d1f3      	bne.n	8007262 <VectorC0+0xaa>
 800727a:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 800727c:	4b06      	ldr	r3, [pc, #24]	; (8007298 <VectorC0+0xe0>)
 800727e:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8007280:	6019      	str	r1, [r3, #0]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8007282:	b11a      	cbz	r2, 800728c <VectorC0+0xd4>
}
 8007284:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8007288:	f7fc bd78 	b.w	8003d7c <Vector6C.part.0>
 800728c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800728e:	bf00      	nop
 8007290:	20000934 	.word	0x20000934
 8007294:	20000994 	.word	0x20000994
 8007298:	2000164c 	.word	0x2000164c

0800729c <spi_lld_serve_rx_interrupt>:
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800729c:	b538      	push	{r3, r4, r5, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800729e:	070b      	lsls	r3, r1, #28
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 80072a0:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80072a2:	d502      	bpl.n	80072aa <spi_lld_serve_rx_interrupt+0xe>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 80072a4:	f7fd fb8e 	bl	80049c4 <vTaskEndScheduler>
 80072a8:	e7fe      	b.n	80072a8 <spi_lld_serve_rx_interrupt+0xc>
  dmaStreamDisable(spip->dmatx);
 80072aa:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80072ac:	6859      	ldr	r1, [r3, #4]
 80072ae:	680a      	ldr	r2, [r1, #0]
 80072b0:	f022 020f 	bic.w	r2, r2, #15
 80072b4:	600a      	str	r2, [r1, #0]
 80072b6:	7c1a      	ldrb	r2, [r3, #16]
 80072b8:	6819      	ldr	r1, [r3, #0]
 80072ba:	230e      	movs	r3, #14
 80072bc:	fa03 f202 	lsl.w	r2, r3, r2
 80072c0:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(spip->dmarx);
 80072c2:	6e42      	ldr	r2, [r0, #100]	; 0x64
 80072c4:	6855      	ldr	r5, [r2, #4]
 80072c6:	6829      	ldr	r1, [r5, #0]
 80072c8:	f021 010f 	bic.w	r1, r1, #15
 80072cc:	6029      	str	r1, [r5, #0]
 80072ce:	6811      	ldr	r1, [r2, #0]
 80072d0:	7c12      	ldrb	r2, [r2, #16]
 80072d2:	4093      	lsls	r3, r2
 80072d4:	604b      	str	r3, [r1, #4]
  _spi_isr_code(spip);
 80072d6:	6843      	ldr	r3, [r0, #4]
 80072d8:	681b      	ldr	r3, [r3, #0]
 80072da:	b12b      	cbz	r3, 80072e8 <spi_lld_serve_rx_interrupt+0x4c>
 80072dc:	2204      	movs	r2, #4
 80072de:	7002      	strb	r2, [r0, #0]
 80072e0:	4798      	blx	r3
 80072e2:	7823      	ldrb	r3, [r4, #0]
 80072e4:	2b04      	cmp	r3, #4
 80072e6:	d101      	bne.n	80072ec <spi_lld_serve_rx_interrupt+0x50>
 80072e8:	2302      	movs	r3, #2
 80072ea:	7023      	strb	r3, [r4, #0]
 80072ec:	f7fe faa4 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80072f0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80072f4:	b12b      	cbz	r3, 8007302 <spi_lld_serve_rx_interrupt+0x66>
    if(*thread_reference) {
 80072f6:	68a0      	ldr	r0, [r4, #8]
 80072f8:	b930      	cbnz	r0, 8007308 <spi_lld_serve_rx_interrupt+0x6c>
}
 80072fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  _spi_isr_code(spip);
 80072fe:	f7fe baaf 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
    osalDbgCheckClassI();
 8007302:	f7fd fb5f 	bl	80049c4 <vTaskEndScheduler>
 8007306:	e7fe      	b.n	8007306 <spi_lld_serve_rx_interrupt+0x6a>
        xTaskNotifyFromISR( *thread_reference, msg, eSetValueWithOverwrite, NULL );
 8007308:	2100      	movs	r1, #0
 800730a:	f7ff fd5d 	bl	8006dc8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>
        *thread_reference = NULL;
 800730e:	2300      	movs	r3, #0
 8007310:	60a3      	str	r3, [r4, #8]
 8007312:	e7f2      	b.n	80072fa <spi_lld_serve_rx_interrupt+0x5e>

08007314 <gpioSetPinMode.isra.0>:
bool gpioSetPinMode(uint16_t pin, uint8_t mode)
 8007314:	b510      	push	{r4, lr}
 8007316:	4604      	mov	r4, r0
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 8007318:	0a00      	lsrs	r0, r0, #8
 800731a:	f7fd f84d 	bl	80043b8 <gpioGetPortDriver>
    return port->functions->setMode(port, gpioPin, mode);
 800731e:	6883      	ldr	r3, [r0, #8]
 8007320:	460a      	mov	r2, r1
 8007322:	681b      	ldr	r3, [r3, #0]
 8007324:	b2e1      	uxtb	r1, r4
}
 8007326:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return port->functions->setMode(port, gpioPin, mode);
 800732a:	4718      	bx	r3

0800732c <systemEnableMCO>:
    syslog("USB init done.");
}


void systemEnableMCO(bool enable)
{
 800732c:	b510      	push	{r4, lr}
 800732e:	4c0a      	ldr	r4, [pc, #40]	; (8007358 <systemEnableMCO+0x2c>)
    if(enable) {
 8007330:	b140      	cbz	r0, 8007344 <systemEnableMCO+0x18>
        gpioSetPinMode(GPIO_MIX_SW_LO, PAL_MODE_STM32_ALTERNATE_PUSHPULL);
 8007332:	2110      	movs	r1, #16
 8007334:	2008      	movs	r0, #8
 8007336:	f7ff ffed 	bl	8007314 <gpioSetPinMode.isra.0>
        RCC->CFGR |= STM32_MCOSEL_SYSCLK;
 800733a:	6863      	ldr	r3, [r4, #4]
 800733c:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8007340:	6063      	str	r3, [r4, #4]
    } else {
        RCC->CFGR &=~ STM32_MCOSEL_SYSCLK;
        gpioSetPinMode(GPIO_MIX_SW_LO, PAL_MODE_INPUT);
    }
}
 8007342:	bd10      	pop	{r4, pc}
        RCC->CFGR &=~ STM32_MCOSEL_SYSCLK;
 8007344:	6863      	ldr	r3, [r4, #4]
        gpioSetPinMode(GPIO_MIX_SW_LO, PAL_MODE_INPUT);
 8007346:	2102      	movs	r1, #2
        RCC->CFGR &=~ STM32_MCOSEL_SYSCLK;
 8007348:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800734c:	6063      	str	r3, [r4, #4]
        gpioSetPinMode(GPIO_MIX_SW_LO, PAL_MODE_INPUT);
 800734e:	2008      	movs	r0, #8
}
 8007350:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        gpioSetPinMode(GPIO_MIX_SW_LO, PAL_MODE_INPUT);
 8007354:	f7ff bfde 	b.w	8007314 <gpioSetPinMode.isra.0>
 8007358:	40021000 	.word	0x40021000

0800735c <i2cSafeRawHardwareControl>:
{
 800735c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    i2cSafeConfig* config = (i2cSafeConfig*)i2c->i2cSafeConfig;
 8007360:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
 8007362:	4604      	mov	r4, r0
  osalDbgCheck((i2cp != NULL) && (config != NULL));
 8007364:	b915      	cbnz	r5, 800736c <i2cSafeRawHardwareControl+0x10>
 8007366:	f7fd fb2d 	bl	80049c4 <vTaskEndScheduler>
 800736a:	e7fe      	b.n	800736a <i2cSafeRawHardwareControl+0xe>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800736c:	7803      	ldrb	r3, [r0, #0]
 800736e:	1e5a      	subs	r2, r3, #1
 8007370:	2a01      	cmp	r2, #1
 8007372:	d904      	bls.n	800737e <i2cSafeRawHardwareControl+0x22>
 8007374:	2b05      	cmp	r3, #5
 8007376:	d002      	beq.n	800737e <i2cSafeRawHardwareControl+0x22>
 8007378:	f7fd fb24 	bl	80049c4 <vTaskEndScheduler>
 800737c:	e7fe      	b.n	800737c <i2cSafeRawHardwareControl+0x20>
  osalSysLock();
 800737e:	f7fd fb11 	bl	80049a4 <vPortEnterCritical>
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8007382:	f894 8000 	ldrb.w	r8, [r4]
  I2C_TypeDef *dp = i2cp->i2c;
 8007386:	6fa6      	ldr	r6, [r4, #120]	; 0x78
  if (i2cp->state == I2C_STOP) {
 8007388:	f1b8 0f01 	cmp.w	r8, #1
  i2cp->config = config;
 800738c:	6065      	str	r5, [r4, #4]
 800738e:	d13a      	bne.n	8007406 <i2cSafeRawHardwareControl+0xaa>

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8007390:	238a      	movs	r3, #138	; 0x8a
 8007392:	229a      	movs	r2, #154	; 0x9a
 8007394:	e9c4 321a 	strd	r3, r2, [r4, #104]	; 0x68
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_P2M;

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8007398:	4b6b      	ldr	r3, [pc, #428]	; (8007548 <i2cSafeRawHardwareControl+0x1ec>)
 800739a:	429c      	cmp	r4, r3
 800739c:	d133      	bne.n	8007406 <i2cSafeRawHardwareControl+0xaa>
      bool b;

      rccResetI2C1();
 800739e:	4f6b      	ldr	r7, [pc, #428]	; (800754c <i2cSafeRawHardwareControl+0x1f0>)
      b = dmaStreamAllocate(i2cp->dmarx,
 80073a0:	4622      	mov	r2, r4
      rccResetI2C1();
 80073a2:	693b      	ldr	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 80073a4:	496a      	ldr	r1, [pc, #424]	; (8007550 <i2cSafeRawHardwareControl+0x1f4>)
      rccResetI2C1();
 80073a6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80073aa:	613b      	str	r3, [r7, #16]
 80073ac:	2300      	movs	r3, #0
      b = dmaStreamAllocate(i2cp->dmarx,
 80073ae:	6f20      	ldr	r0, [r4, #112]	; 0x70
      rccResetI2C1();
 80073b0:	613b      	str	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 80073b2:	f7ff f84b 	bl	800644c <dmaStreamAllocate.constprop.0>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80073b6:	b110      	cbz	r0, 80073be <i2cSafeRawHardwareControl+0x62>
 80073b8:	f7fd fb04 	bl	80049c4 <vTaskEndScheduler>
 80073bc:	e7fe      	b.n	80073bc <i2cSafeRawHardwareControl+0x60>
      b = dmaStreamAllocate(i2cp->dmatx,
 80073be:	4622      	mov	r2, r4
 80073c0:	4964      	ldr	r1, [pc, #400]	; (8007554 <i2cSafeRawHardwareControl+0x1f8>)
 80073c2:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80073c4:	f7ff f842 	bl	800644c <dmaStreamAllocate.constprop.0>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80073c8:	b110      	cbz	r0, 80073d0 <i2cSafeRawHardwareControl+0x74>
 80073ca:	f7fd fafb 	bl	80049c4 <vTaskEndScheduler>
 80073ce:	e7fe      	b.n	80073ce <i2cSafeRawHardwareControl+0x72>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80073d0:	22c0      	movs	r2, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80073d2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
      rccEnableI2C1(FALSE);
 80073d6:	69fb      	ldr	r3, [r7, #28]
 80073d8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80073dc:	61fb      	str	r3, [r7, #28]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80073de:	4b5e      	ldr	r3, [pc, #376]	; (8007558 <i2cSafeRawHardwareControl+0x1fc>)
 80073e0:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80073e4:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80073e8:	6019      	str	r1, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80073ea:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80073ee:	f8c3 8184 	str.w	r8, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80073f2:	f8c3 8004 	str.w	r8, [r3, #4]
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80073f6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80073f8:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80073fc:	66a3      	str	r3, [r4, #104]	; 0x68
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80073fe:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8007400:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8007404:	66e3      	str	r3, [r4, #108]	; 0x6c
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8007406:	6f23      	ldr	r3, [r4, #112]	; 0x70
  int32_t clock_speed = i2cp->config->clock_speed;
 8007408:	6867      	ldr	r7, [r4, #4]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800740a:	685a      	ldr	r2, [r3, #4]
 800740c:	f106 0310 	add.w	r3, r6, #16
 8007410:	6093      	str	r3, [r2, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8007412:	6f62      	ldr	r2, [r4, #116]	; 0x74
  int32_t clock_speed = i2cp->config->clock_speed;
 8007414:	6879      	ldr	r1, [r7, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8007416:	6852      	ldr	r2, [r2, #4]
  osalDbgCheck((i2cp != NULL) &&
 8007418:	1e48      	subs	r0, r1, #1
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800741a:	6093      	str	r3, [r2, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800741c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8007420:	f44f 6210 	mov.w	r2, #2304	; 0x900
  dp->CR1 = I2C_CR1_SWRST;
 8007424:	6033      	str	r3, [r6, #0]
  dp->CR1 = 0;
 8007426:	2300      	movs	r3, #0
 8007428:	6033      	str	r3, [r6, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800742a:	6072      	str	r2, [r6, #4]
  osalDbgCheck((i2cp != NULL) &&
 800742c:	4a4b      	ldr	r2, [pc, #300]	; (800755c <i2cSafeRawHardwareControl+0x200>)
 800742e:	4290      	cmp	r0, r2
 8007430:	d902      	bls.n	8007438 <i2cSafeRawHardwareControl+0xdc>
 8007432:	f7fd fac7 	bl	80049c4 <vTaskEndScheduler>
 8007436:	e7fe      	b.n	8007436 <i2cSafeRawHardwareControl+0xda>
  I2C_TypeDef *dp = i2cp->i2c;
 8007438:	6fa0      	ldr	r0, [r4, #120]	; 0x78
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 800743a:	7a3a      	ldrb	r2, [r7, #8]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800743c:	f8d0 c004 	ldr.w	ip, [r0, #4]
 8007440:	f02c 0c3f 	bic.w	ip, ip, #63	; 0x3f
 8007444:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8007448:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800744c:	f8c0 c004 	str.w	ip, [r0, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8007450:	f8d0 c004 	ldr.w	ip, [r0, #4]
 8007454:	f04c 0c24 	orr.w	ip, ip, #36	; 0x24
 8007458:	f8c0 c004 	str.w	ip, [r0, #4]
  if (clock_speed <= 100000) {
 800745c:	f8df c100 	ldr.w	ip, [pc, #256]	; 8007560 <i2cSafeRawHardwareControl+0x204>
 8007460:	4561      	cmp	r1, ip
 8007462:	d839      	bhi.n	80074d8 <i2cSafeRawHardwareControl+0x17c>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 8007464:	2a01      	cmp	r2, #1
 8007466:	d002      	beq.n	800746e <i2cSafeRawHardwareControl+0x112>
 8007468:	f7fd faac 	bl	80049c4 <vTaskEndScheduler>
 800746c:	e7fe      	b.n	800746c <i2cSafeRawHardwareControl+0x110>
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 800746e:	4a3d      	ldr	r2, [pc, #244]	; (8007564 <i2cSafeRawHardwareControl+0x208>)
 8007470:	0049      	lsls	r1, r1, #1
 8007472:	fbb2 f3f1 	udiv	r3, r2, r1
 8007476:	fb01 2213 	mls	r2, r1, r3, r2
 800747a:	b112      	cbz	r2, 8007482 <i2cSafeRawHardwareControl+0x126>
 800747c:	f7fd faa2 	bl	80049c4 <vTaskEndScheduler>
 8007480:	e7fe      	b.n	8007480 <i2cSafeRawHardwareControl+0x124>
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8007482:	b29b      	uxth	r3, r3
    osalDbgAssert(clock_div >= 0x04,
 8007484:	2b03      	cmp	r3, #3
 8007486:	d802      	bhi.n	800748e <i2cSafeRawHardwareControl+0x132>
 8007488:	f7fd fa9c 	bl	80049c4 <vTaskEndScheduler>
 800748c:	e7fe      	b.n	800748c <i2cSafeRawHardwareControl+0x130>
    dp->TRISE = I2C_CLK_FREQ + 1;
 800748e:	2225      	movs	r2, #37	; 0x25
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007490:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    dp->TRISE = I2C_CLK_FREQ + 1;
 8007494:	6202      	str	r2, [r0, #32]
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007496:	d24b      	bcs.n	8007530 <i2cSafeRawHardwareControl+0x1d4>
  dp->CCR = regCCR;
 8007498:	61c3      	str	r3, [r0, #28]
  i2copmode_t opmode = i2cp->config->op_mode;
 800749a:	783a      	ldrb	r2, [r7, #0]
  regCR1 = dp->CR1;
 800749c:	6803      	ldr	r3, [r0, #0]
  switch (opmode) {
 800749e:	2a02      	cmp	r2, #2
  regCR1 = dp->CR1;
 80074a0:	b29b      	uxth	r3, r3
  switch (opmode) {
 80074a2:	d048      	beq.n	8007536 <i2cSafeRawHardwareControl+0x1da>
 80074a4:	2a03      	cmp	r2, #3
 80074a6:	d04c      	beq.n	8007542 <i2cSafeRawHardwareControl+0x1e6>
 80074a8:	2a01      	cmp	r2, #1
 80074aa:	d102      	bne.n	80074b2 <i2cSafeRawHardwareControl+0x156>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80074ac:	f023 030a 	bic.w	r3, r3, #10
 80074b0:	b29b      	uxth	r3, r3
  dp->CR1 = regCR1;
 80074b2:	6003      	str	r3, [r0, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 80074b4:	6833      	ldr	r3, [r6, #0]
 80074b6:	f043 0301 	orr.w	r3, r3, #1
 80074ba:	6033      	str	r3, [r6, #0]
  i2cp->state = I2C_READY;
 80074bc:	2302      	movs	r3, #2
 80074be:	7023      	strb	r3, [r4, #0]
  osalSysUnlock();
 80074c0:	f7fd fc94 	bl	8004dec <osalSysUnlock.lto_priv.0>
    gpioSetPinMode(config->sclPin, config->peripheralMode);
 80074c4:	7c29      	ldrb	r1, [r5, #16]
 80074c6:	89a8      	ldrh	r0, [r5, #12]
 80074c8:	f7ff ff24 	bl	8007314 <gpioSetPinMode.isra.0>
    gpioSetPinMode(config->sdaPin, config->peripheralMode);
 80074cc:	7c29      	ldrb	r1, [r5, #16]
 80074ce:	89e8      	ldrh	r0, [r5, #14]
}
 80074d0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    gpioSetPinMode(config->sdaPin, config->peripheralMode);
 80074d4:	f7ff bf1e 	b.w	8007314 <gpioSetPinMode.isra.0>
  else if (clock_speed <= 400000) {
 80074d8:	f8df c08c 	ldr.w	ip, [pc, #140]	; 8007568 <i2cSafeRawHardwareControl+0x20c>
 80074dc:	4561      	cmp	r1, ip
 80074de:	dcdb      	bgt.n	8007498 <i2cSafeRawHardwareControl+0x13c>
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 80074e0:	1e93      	subs	r3, r2, #2
 80074e2:	2b01      	cmp	r3, #1
 80074e4:	d902      	bls.n	80074ec <i2cSafeRawHardwareControl+0x190>
 80074e6:	f7fd fa6d 	bl	80049c4 <vTaskEndScheduler>
 80074ea:	e7fe      	b.n	80074ea <i2cSafeRawHardwareControl+0x18e>
    if (duty == FAST_DUTY_CYCLE_2) {
 80074ec:	2a02      	cmp	r2, #2
 80074ee:	4b1d      	ldr	r3, [pc, #116]	; (8007564 <i2cSafeRawHardwareControl+0x208>)
 80074f0:	d110      	bne.n	8007514 <i2cSafeRawHardwareControl+0x1b8>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 80074f2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80074f6:	fbb3 f2f1 	udiv	r2, r3, r1
 80074fa:	fb01 3312 	mls	r3, r1, r2, r3
 80074fe:	b113      	cbz	r3, 8007506 <i2cSafeRawHardwareControl+0x1aa>
 8007500:	f7fd fa60 	bl	80049c4 <vTaskEndScheduler>
 8007504:	e7fe      	b.n	8007504 <i2cSafeRawHardwareControl+0x1a8>
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8007506:	b292      	uxth	r2, r2
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 8007508:	4313      	orrs	r3, r2
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 800750a:	220b      	movs	r2, #11
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 800750c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8007510:	6202      	str	r2, [r0, #32]
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007512:	e7c1      	b.n	8007498 <i2cSafeRawHardwareControl+0x13c>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 8007514:	2219      	movs	r2, #25
 8007516:	4351      	muls	r1, r2
 8007518:	fbb3 f2f1 	udiv	r2, r3, r1
 800751c:	fb01 3312 	mls	r3, r1, r2, r3
 8007520:	b113      	cbz	r3, 8007528 <i2cSafeRawHardwareControl+0x1cc>
 8007522:	f7fd fa4f 	bl	80049c4 <vTaskEndScheduler>
 8007526:	e7fe      	b.n	8007526 <i2cSafeRawHardwareControl+0x1ca>
      regCCR |= I2C_CCR_DUTY;
 8007528:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 800752c:	b292      	uxth	r2, r2
      regCCR |= I2C_CCR_DUTY;
 800752e:	e7eb      	b.n	8007508 <i2cSafeRawHardwareControl+0x1ac>
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007530:	f7fd fa48 	bl	80049c4 <vTaskEndScheduler>
 8007534:	e7fe      	b.n	8007534 <i2cSafeRawHardwareControl+0x1d8>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8007536:	f023 0308 	bic.w	r3, r3, #8
 800753a:	b29b      	uxth	r3, r3
 800753c:	f043 0302 	orr.w	r3, r3, #2
    break;
 8007540:	e7b7      	b.n	80074b2 <i2cSafeRawHardwareControl+0x156>
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8007542:	f043 030a 	orr.w	r3, r3, #10
    break;
 8007546:	e7b4      	b.n	80074b2 <i2cSafeRawHardwareControl+0x156>
 8007548:	20000934 	.word	0x20000934
 800754c:	40021000 	.word	0x40021000
 8007550:	08007019 	.word	0x08007019
 8007554:	08004c89 	.word	0x08004c89
 8007558:	e000e100 	.word	0xe000e100
 800755c:	003d08ff 	.word	0x003d08ff
 8007560:	000186a0 	.word	0x000186a0
 8007564:	02255100 	.word	0x02255100
 8007568:	00061a80 	.word	0x00061a80

0800756c <gpioSetPin.isra.0>:
bool gpioSetPin(uint16_t pin, bool on)
 800756c:	b510      	push	{r4, lr}
 800756e:	4604      	mov	r4, r0
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 8007570:	0a00      	lsrs	r0, r0, #8
 8007572:	f7fc ff21 	bl	80043b8 <gpioGetPortDriver>
    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
 8007576:	b2e4      	uxtb	r4, r4
 8007578:	fa01 f204 	lsl.w	r2, r1, r4
 800757c:	2101      	movs	r1, #1
 800757e:	6883      	ldr	r3, [r0, #8]
 8007580:	40a1      	lsls	r1, r4
 8007582:	689b      	ldr	r3, [r3, #8]
}
 8007584:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
 8007588:	4718      	bx	r3
	...

0800758c <converterSetGpio>:
{
 800758c:	b570      	push	{r4, r5, r6, lr}
    gpioValues |= bandSpecificGpioSettings[converter->activeBand];
 800758e:	4b3d      	ldr	r3, [pc, #244]	; (8007684 <converterSetGpio+0xf8>)
 8007590:	7e02      	ldrb	r2, [r0, #24]
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 8007592:	2001      	movs	r0, #1
 8007594:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8007598:	f7fc ff0e 	bl	80043b8 <gpioGetPortDriver>
 800759c:	430c      	orrs	r4, r1
    return port->functions->setValue(port, ~0, value);
 800759e:	6883      	ldr	r3, [r0, #8]
 80075a0:	f424 6260 	bic.w	r2, r4, #3584	; 0xe00
 80075a4:	689b      	ldr	r3, [r3, #8]
 80075a6:	f022 020e 	bic.w	r2, r2, #14
 80075aa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80075ae:	4798      	blx	r3
    gpioSetPin(GPIO_LOWBAND, (gpioValues & _BV(CONVERTER_IO_PIN_LOWBAND)) == 0);
 80075b0:	f084 0104 	eor.w	r1, r4, #4
 80075b4:	2002      	movs	r0, #2
 80075b6:	f3c1 0180 	ubfx	r1, r1, #2, #1
 80075ba:	f7ff ffd7 	bl	800756c <gpioSetPin.isra.0>
    gpioSetPin(GPIO_MIX_SW_EN, (gpioValues & _BV(CONVERTER_IO_PIN_MIX_SW_EN)) == 0);
 80075be:	f484 7180 	eor.w	r1, r4, #256	; 0x100
 80075c2:	f44f 7084 	mov.w	r0, #264	; 0x108
 80075c6:	f3c1 2100 	ubfx	r1, r1, #8, #1
 80075ca:	f7ff ffcf 	bl	800756c <gpioSetPin.isra.0>
    systemEnableMCO((gpioValues & _BV(CONVERTER_IO_PIN_MIX_SW_LO)) > 0);
 80075ce:	f3c4 2040 	ubfx	r0, r4, #9, #1
 80075d2:	f7ff feab 	bl	800732c <systemEnableMCO>
    mixBlinkDelay += (gpioValues & _BV(CONVERTER_IO_PIN_LED1))? 100:0;
 80075d6:	f414 6380 	ands.w	r3, r4, #1024	; 0x400
 80075da:	bf18      	it	ne
 80075dc:	2364      	movne	r3, #100	; 0x64
    mixBlinkDelay += (gpioValues & _BV(CONVERTER_IO_PIN_LED2))? 200:0;
 80075de:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
 80075e2:	bf18      	it	ne
 80075e4:	24c8      	movne	r4, #200	; 0xc8
 80075e6:	441c      	add	r4, r3
    mixLedDelay = mixBlinkDelay;
 80075e8:	4b27      	ldr	r3, [pc, #156]	; (8007688 <converterSetGpio+0xfc>)
 80075ea:	601c      	str	r4, [r3, #0]
    vTaskResume(mixLedTaskHandle);
 80075ec:	4b27      	ldr	r3, [pc, #156]	; (800768c <converterSetGpio+0x100>)
 80075ee:	681c      	ldr	r4, [r3, #0]
		configASSERT( xTaskToResume );
 80075f0:	b904      	cbnz	r4, 80075f4 <converterSetGpio+0x68>
 80075f2:	e7fe      	b.n	80075f2 <converterSetGpio+0x66>
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 80075f4:	4d26      	ldr	r5, [pc, #152]	; (8007690 <converterSetGpio+0x104>)
 80075f6:	682b      	ldr	r3, [r5, #0]
 80075f8:	429c      	cmp	r4, r3
 80075fa:	d042      	beq.n	8007682 <converterSetGpio+0xf6>
			taskENTER_CRITICAL();
 80075fc:	f7fd f9d2 	bl	80049a4 <vPortEnterCritical>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8007600:	6962      	ldr	r2, [r4, #20]
 8007602:	4b24      	ldr	r3, [pc, #144]	; (8007694 <converterSetGpio+0x108>)
 8007604:	429a      	cmp	r2, r3
 8007606:	d138      	bne.n	800767a <converterSetGpio+0xee>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8007608:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800760a:	4a23      	ldr	r2, [pc, #140]	; (8007698 <converterSetGpio+0x10c>)
 800760c:	4293      	cmp	r3, r2
 800760e:	d034      	beq.n	800767a <converterSetGpio+0xee>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 8007610:	bb9b      	cbnz	r3, 800767a <converterSetGpio+0xee>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 8007612:	1d26      	adds	r6, r4, #4
 8007614:	4630      	mov	r0, r6
 8007616:	f7fd f848 	bl	80046aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800761a:	2301      	movs	r3, #1
 800761c:	491f      	ldr	r1, [pc, #124]	; (800769c <converterSetGpio+0x110>)
 800761e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007620:	6808      	ldr	r0, [r1, #0]
 8007622:	4093      	lsls	r3, r2
 8007624:	4303      	orrs	r3, r0
 8007626:	2014      	movs	r0, #20
 8007628:	600b      	str	r3, [r1, #0]
 800762a:	4b1d      	ldr	r3, [pc, #116]	; (80076a0 <converterSetGpio+0x114>)
 800762c:	4631      	mov	r1, r6
 800762e:	fb00 3002 	mla	r0, r0, r2, r3
 8007632:	f7fd f817 	bl	8004664 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8007636:	682b      	ldr	r3, [r5, #0]
 8007638:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800763a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800763c:	429a      	cmp	r2, r3
 800763e:	d31c      	bcc.n	800767a <converterSetGpio+0xee>
						taskYIELD_IF_USING_PREEMPTION();
 8007640:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8007644:	4a17      	ldr	r2, [pc, #92]	; (80076a4 <converterSetGpio+0x118>)
 8007646:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800764a:	6011      	str	r1, [r2, #0]
 800764c:	4a16      	ldr	r2, [pc, #88]	; (80076a8 <converterSetGpio+0x11c>)
 800764e:	6812      	ldr	r2, [r2, #0]
 8007650:	b14a      	cbz	r2, 8007666 <converterSetGpio+0xda>
 8007652:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8007656:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800765a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800765e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8007662:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8007666:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800766a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800766e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8007672:	f3bf 8f4f 	dsb	sy
 8007676:	f3bf 8f6f 	isb	sy
}
 800767a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 800767e:	f7fd bba9 	b.w	8004dd4 <vPortExitCritical>
 8007682:	bd70      	pop	{r4, r5, r6, pc}
 8007684:	0800c8a8 	.word	0x0800c8a8
 8007688:	20001198 	.word	0x20001198
 800768c:	2000119c 	.word	0x2000119c
 8007690:	200011a8 	.word	0x200011a8
 8007694:	20001620 	.word	0x20001620
 8007698:	20001600 	.word	0x20001600
 800769c:	20001374 	.word	0x20001374
 80076a0:	200011b8 	.word	0x200011b8
 80076a4:	2000134c 	.word	0x2000134c
 80076a8:	20001358 	.word	0x20001358

080076ac <usbShellTerminated>:
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
}

static volatile bool usbShellIsUp = false;
static void usbShellTerminated(void* param)
{
 80076ac:	b508      	push	{r3, lr}
    (void)param;

    gpioSetPin(GPIO_LED_USB, true);
 80076ae:	2101      	movs	r1, #1
 80076b0:	f240 1003 	movw	r0, #259	; 0x103
 80076b4:	f7ff ff5a 	bl	800756c <gpioSetPin.isra.0>
    osalThreadSleepSeconds(1);
 80076b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80076bc:	f7fd fe64 	bl	8005388 <vTaskDelay>
    usbShellIsUp = false;
 80076c0:	2200      	movs	r2, #0
 80076c2:	4b01      	ldr	r3, [pc, #4]	; (80076c8 <usbShellTerminated+0x1c>)
 80076c4:	701a      	strb	r2, [r3, #0]
}
 80076c6:	bd08      	pop	{r3, pc}
 80076c8:	20001355 	.word	0x20001355

080076cc <mac2870LockCallback>:
    if(locked) {
 80076cc:	b120      	cbz	r0, 80076d8 <mac2870LockCallback+0xc>
        gpioSetPin(GPIO_LED_LOCK, false);
 80076ce:	2100      	movs	r1, #0
        gpioSetPin(GPIO_LED_LOCK, true);
 80076d0:	f44f 7082 	mov.w	r0, #260	; 0x104
 80076d4:	f7ff bf4a 	b.w	800756c <gpioSetPin.isra.0>
 80076d8:	2101      	movs	r1, #1
 80076da:	e7f9      	b.n	80076d0 <mac2870LockCallback+0x4>

080076dc <i2cSafeClockGoHigh>:
{
 80076dc:	b538      	push	{r3, r4, r5, lr}
    gpioSetPin(config->sclPin, level);
 80076de:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
{
 80076e0:	4605      	mov	r5, r0
    gpioSetPin(config->sclPin, level);
 80076e2:	2101      	movs	r1, #1
 80076e4:	8998      	ldrh	r0, [r3, #12]
 80076e6:	f7ff ff41 	bl	800756c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 80076ea:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80076ee:	f7fe fc33 	bl	8005f58 <vPortBusyDelay>
    for(j=5; !i2cSafeRawGetClock(i2c); j--) {
 80076f2:	2406      	movs	r4, #6
    return gpioGetPin(config->sclPin);
 80076f4:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 80076f6:	8998      	ldrh	r0, [r3, #12]
 80076f8:	f7fc fe6c 	bl	80043d4 <gpioGetPin>
    for(j=5; !i2cSafeRawGetClock(i2c); j--) {
 80076fc:	b108      	cbz	r0, 8007702 <i2cSafeClockGoHigh+0x26>
    return I2C_BUS_OK;
 80076fe:	2000      	movs	r0, #0
}
 8007700:	bd38      	pop	{r3, r4, r5, pc}
        osalThreadSleepMilliseconds(1);
 8007702:	2001      	movs	r0, #1
        if(j == 0) {
 8007704:	3c01      	subs	r4, #1
        osalThreadSleepMilliseconds(1);
 8007706:	f7fd fe3f 	bl	8005388 <vTaskDelay>
        if(j == 0) {
 800770a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 800770e:	d1f1      	bne.n	80076f4 <i2cSafeClockGoHigh+0x18>
            return I2C_BUS_STUCK_SCL_PULLED_LOW;
 8007710:	2001      	movs	r0, #1
 8007712:	e7f5      	b.n	8007700 <i2cSafeClockGoHigh+0x24>

08007714 <i2cSafeClockGoLow>:
{
 8007714:	b510      	push	{r4, lr}
 8007716:	4604      	mov	r4, r0
    gpioSetPin(config->sclPin, level);
 8007718:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 800771a:	2100      	movs	r1, #0
 800771c:	8998      	ldrh	r0, [r3, #12]
 800771e:	f7ff ff25 	bl	800756c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 8007722:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8007726:	f7fe fc17 	bl	8005f58 <vPortBusyDelay>
    return gpioGetPin(config->sclPin);
 800772a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 800772c:	8998      	ldrh	r0, [r3, #12]
 800772e:	f7fc fe51 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SCL_PULLED_HIGH;
 8007732:	2800      	cmp	r0, #0
}
 8007734:	bf14      	ite	ne
 8007736:	2003      	movne	r0, #3
 8007738:	2000      	moveq	r0, #0
 800773a:	bd10      	pop	{r4, pc}

0800773c <i2cSafeDataGoHigh>:
{
 800773c:	b510      	push	{r4, lr}
 800773e:	4604      	mov	r4, r0
    gpioSetPin(config->sdaPin, level);
 8007740:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8007742:	2101      	movs	r1, #1
 8007744:	89d8      	ldrh	r0, [r3, #14]
 8007746:	f7ff ff11 	bl	800756c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 800774a:	f44f 70c8 	mov.w	r0, #400	; 0x190
 800774e:	f7fe fc03 	bl	8005f58 <vPortBusyDelay>
    return gpioGetPin(config->sdaPin);
 8007752:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8007754:	89d8      	ldrh	r0, [r3, #14]
 8007756:	f7fc fe3d 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SDA_PULLED_LOW;
 800775a:	2800      	cmp	r0, #0
}
 800775c:	bf0c      	ite	eq
 800775e:	2002      	moveq	r0, #2
 8007760:	2000      	movne	r0, #0
 8007762:	bd10      	pop	{r4, pc}

08007764 <i2cSafeDataGoLow>:
{
 8007764:	b510      	push	{r4, lr}
 8007766:	4604      	mov	r4, r0
    gpioSetPin(config->sdaPin, level);
 8007768:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 800776a:	2100      	movs	r1, #0
 800776c:	89d8      	ldrh	r0, [r3, #14]
 800776e:	f7ff fefd 	bl	800756c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 8007772:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8007776:	f7fe fbef 	bl	8005f58 <vPortBusyDelay>
    return gpioGetPin(config->sdaPin);
 800777a:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 800777c:	89d8      	ldrh	r0, [r3, #14]
 800777e:	f7fc fe29 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SDA_PULLED_HIGH;
 8007782:	2800      	cmp	r0, #0
}
 8007784:	bf14      	ite	ne
 8007786:	2004      	movne	r0, #4
 8007788:	2000      	moveq	r0, #0
 800778a:	bd10      	pop	{r4, pc}

0800778c <sdu_start_receive.isra.0>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 800778c:	b510      	push	{r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800778e:	f8d0 1498 	ldr.w	r1, [r0, #1176]	; 0x498
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8007792:	4603      	mov	r3, r0
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8007794:	6808      	ldr	r0, [r1, #0]
 8007796:	7802      	ldrb	r2, [r0, #0]
 8007798:	2a04      	cmp	r2, #4
 800779a:	d11c      	bne.n	80077d6 <sdu_start_receive.isra.0+0x4a>
 800779c:	7d1a      	ldrb	r2, [r3, #20]
 800779e:	2a02      	cmp	r2, #2
 80077a0:	d119      	bne.n	80077d6 <sdu_start_receive.isra.0+0x4a>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80077a2:	2201      	movs	r2, #1
 80077a4:	790c      	ldrb	r4, [r1, #4]
 80077a6:	40a2      	lsls	r2, r4
 80077a8:	8944      	ldrh	r4, [r0, #10]
 80077aa:	4222      	tst	r2, r4
 80077ac:	d113      	bne.n	80077d6 <sdu_start_receive.isra.0+0x4a>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80077ae:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80077b2:	b16a      	cbz	r2, 80077d0 <sdu_start_receive.isra.0+0x44>
  if (ibqIsFullI(ibqp)) {
 80077b4:	e9d3 240a 	ldrd	r2, r4, [r3, #40]	; 0x28
 80077b8:	42a2      	cmp	r2, r4
 80077ba:	d101      	bne.n	80077c0 <sdu_start_receive.isra.0+0x34>
 80077bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80077be:	b953      	cbnz	r3, 80077d6 <sdu_start_receive.isra.0+0x4a>
}
 80077c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 80077c4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80077c8:	7949      	ldrb	r1, [r1, #5]
 80077ca:	3204      	adds	r2, #4
 80077cc:	f7fd b988 	b.w	8004ae0 <usbStartReceiveI>
  osalDbgCheckClassI();
 80077d0:	f7fd f8f8 	bl	80049c4 <vTaskEndScheduler>
 80077d4:	e7fe      	b.n	80077d4 <sdu_start_receive.isra.0+0x48>
}
 80077d6:	bd10      	pop	{r4, pc}

080077d8 <ibnotify>:
  (void) sdu_start_receive(sdup);
 80077d8:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80077da:	f7ff bfd7 	b.w	800778c <sdu_start_receive.isra.0>

080077de <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80077de:	3111      	adds	r1, #17
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80077e0:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80077e2:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 80077e6:	2c00      	cmp	r4, #0
 80077e8:	d03d      	beq.n	8007866 <sduDataReceived+0x88>
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 80077ea:	2104      	movs	r1, #4
  osalSysLockFromISR();
 80077ec:	f7fe f824 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 80077f0:	1860      	adds	r0, r4, r1
 80077f2:	f7ff fb77 	bl	8006ee4 <osalEventBroadcastFlagsI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80077f6:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80077fa:	b163      	cbz	r3, 8007816 <sduDataReceived+0x38>
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80077fc:	f8d4 2498 	ldr.w	r2, [r4, #1176]	; 0x498
 8007800:	6813      	ldr	r3, [r2, #0]
 8007802:	7952      	ldrb	r2, [r2, #5]
 8007804:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8007808:	68db      	ldr	r3, [r3, #12]
  ibqPostFullBufferI(&sdup->ibqueue,
 800780a:	699b      	ldr	r3, [r3, #24]
 800780c:	685a      	ldr	r2, [r3, #4]
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 800780e:	b92a      	cbnz	r2, 800781c <sduDataReceived+0x3e>
 8007810:	f7fd f8d8 	bl	80049c4 <vTaskEndScheduler>
 8007814:	e7fe      	b.n	8007814 <sduDataReceived+0x36>
  osalDbgCheckClassI();
 8007816:	f7fd f8d5 	bl	80049c4 <vTaskEndScheduler>
 800781a:	e7fe      	b.n	800781a <sduDataReceived+0x3c>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 800781c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800781e:	3b04      	subs	r3, #4
 8007820:	429a      	cmp	r2, r3
 8007822:	d8f5      	bhi.n	8007810 <sduDataReceived+0x32>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8007824:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
 8007828:	428b      	cmp	r3, r1
 800782a:	d104      	bne.n	8007836 <sduDataReceived+0x58>
 800782c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800782e:	b111      	cbz	r1, 8007836 <sduDataReceived+0x58>
 8007830:	f7fd f8c8 	bl	80049c4 <vTaskEndScheduler>
 8007834:	e7fe      	b.n	8007834 <sduDataReceived+0x56>
  *((size_t *)ibqp->bwrptr) = size;
 8007836:	601a      	str	r2, [r3, #0]
  ibqp->bcounter++;
 8007838:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800783a:	3201      	adds	r2, #1
 800783c:	6262      	str	r2, [r4, #36]	; 0x24
  ibqp->bwrptr += ibqp->bsize;
 800783e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8007840:	4413      	add	r3, r2
  if (ibqp->bwrptr >= ibqp->btop) {
 8007842:	6b22      	ldr	r2, [r4, #48]	; 0x30
  ibqp->bwrptr += ibqp->bsize;
 8007844:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->bwrptr >= ibqp->btop) {
 8007846:	4293      	cmp	r3, r2
 8007848:	d20a      	bcs.n	8007860 <sduDataReceived+0x82>
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 800784a:	f104 0018 	add.w	r0, r4, #24
 800784e:	f7ff fb25 	bl	8006e9c <osalThreadDequeueNextI.constprop.0>
  (void) sdu_start_receive(sdup);
 8007852:	4620      	mov	r0, r4
 8007854:	f7ff ff9a 	bl	800778c <sdu_start_receive.isra.0>
}
 8007858:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlockFromISR();
 800785c:	f7fe b800 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
    ibqp->bwrptr = ibqp->buffers;
 8007860:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8007862:	62a3      	str	r3, [r4, #40]	; 0x28
 8007864:	e7f1      	b.n	800784a <sduDataReceived+0x6c>
}
 8007866:	bd10      	pop	{r4, pc}

08007868 <ibqReadTimeout.part.0>:
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
 8007868:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800786c:	461f      	mov	r7, r3
 800786e:	4604      	mov	r4, r0
  size_t r = 0;
 8007870:	2600      	movs	r6, #0
		xReturn = xTickCount;
 8007872:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8007920 <ibqReadTimeout.part.0+0xb8>
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
 8007876:	4690      	mov	r8, r2
 8007878:	460d      	mov	r5, r1
  osalSysLock();
 800787a:	f7fd f893 	bl	80049a4 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800787e:	f7fe fb4d 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8007882:	f8da 3000 	ldr.w	r3, [sl]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8007886:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 800788a:	eb07 0903 	add.w	r9, r7, r3
    if (ibqp->ptr == NULL) {
 800788e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007890:	b93b      	cbnz	r3, 80078a2 <ibqReadTimeout.part.0+0x3a>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8007892:	f11b 0f03 	cmn.w	fp, #3
 8007896:	d92a      	bls.n	80078ee <ibqReadTimeout.part.0+0x86>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8007898:	4639      	mov	r1, r7
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800789a:	4620      	mov	r0, r4
 800789c:	f7fe ff40 	bl	8006720 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 80078a0:	bb68      	cbnz	r0, 80078fe <ibqReadTimeout.part.0+0x96>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 80078a2:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
    if (size > (n - r)) {
 80078a6:	eba8 0306 	sub.w	r3, r8, r6
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 80078aa:	1a52      	subs	r2, r2, r1
    if (size > (n - r)) {
 80078ac:	429a      	cmp	r2, r3
 80078ae:	bf28      	it	cs
 80078b0:	461a      	movcs	r2, r3
    if (size > 64U) {
 80078b2:	2a40      	cmp	r2, #64	; 0x40
 80078b4:	d929      	bls.n	800790a <ibqReadTimeout.part.0+0xa2>
      memcpy(bp, ibqp->ptr, 64U);
 80078b6:	462b      	mov	r3, r5
 80078b8:	f101 0240 	add.w	r2, r1, #64	; 0x40
 80078bc:	f851 0b04 	ldr.w	r0, [r1], #4
 80078c0:	4291      	cmp	r1, r2
 80078c2:	f843 0b04 	str.w	r0, [r3], #4
 80078c6:	d1f9      	bne.n	80078bc <ibqReadTimeout.part.0+0x54>
      ibqp->ptr += 64U;
 80078c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += 64U;
 80078ca:	3540      	adds	r5, #64	; 0x40
      ibqp->ptr += 64U;
 80078cc:	3340      	adds	r3, #64	; 0x40
 80078ce:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += 64U;
 80078d0:	3640      	adds	r6, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
 80078d2:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 80078d6:	429a      	cmp	r2, r3
 80078d8:	d302      	bcc.n	80078e0 <ibqReadTimeout.part.0+0x78>
      ibqReleaseEmptyBufferS(ibqp);
 80078da:	4620      	mov	r0, r4
 80078dc:	f7fd f87e 	bl	80049dc <ibqReleaseEmptyBufferS>
    osalSysUnlock();
 80078e0:	f7fd fa84 	bl	8004dec <osalSysUnlock.lto_priv.0>
    if (r >= n) {
 80078e4:	45b0      	cmp	r8, r6
 80078e6:	d90c      	bls.n	8007902 <ibqReadTimeout.part.0+0x9a>
    osalSysLock();
 80078e8:	f7fd f85c 	bl	80049a4 <vPortEnterCritical>
  while (true) {
 80078ec:	e7cf      	b.n	800788e <ibqReadTimeout.part.0+0x26>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80078ee:	f7fe fb15 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80078f2:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80078f6:	eba9 0101 	sub.w	r1, r9, r1
        if (next_timeout > timeout) {
 80078fa:	428f      	cmp	r7, r1
 80078fc:	d2cd      	bcs.n	800789a <ibqReadTimeout.part.0+0x32>
        osalSysUnlock();
 80078fe:	f7fd fa75 	bl	8004dec <osalSysUnlock.lto_priv.0>
}
 8007902:	4630      	mov	r0, r6
 8007904:	b003      	add	sp, #12
 8007906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      memcpy(bp, ibqp->ptr, size);
 800790a:	4628      	mov	r0, r5
 800790c:	9201      	str	r2, [sp, #4]
 800790e:	f7fc f8e1 	bl	8003ad4 <memcpy>
      bp        += size;
 8007912:	9a01      	ldr	r2, [sp, #4]
      ibqp->ptr += size;
 8007914:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
 8007916:	4415      	add	r5, r2
      ibqp->ptr += size;
 8007918:	4413      	add	r3, r2
 800791a:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
 800791c:	4416      	add	r6, r2
 800791e:	e7d8      	b.n	80078d2 <ibqReadTimeout.part.0+0x6a>
 8007920:	20001648 	.word	0x20001648

08007924 <_read.lto_priv.1>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8007924:	b510      	push	{r4, lr}
  osalDbgCheck(n > 0U);
 8007926:	b912      	cbnz	r2, 800792e <_read.lto_priv.1+0xa>
 8007928:	f7fd f84c 	bl	80049c4 <vTaskEndScheduler>
 800792c:	e7fe      	b.n	800792c <_read.lto_priv.1+0x8>
 800792e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8007932:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8007936:	3018      	adds	r0, #24
 8007938:	f7ff bf96 	b.w	8007868 <ibqReadTimeout.part.0>

0800793c <_readt.lto_priv.1>:
static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 800793c:	b510      	push	{r4, lr}
 800793e:	b912      	cbnz	r2, 8007946 <_readt.lto_priv.1+0xa>
 8007940:	f7fd f840 	bl	80049c4 <vTaskEndScheduler>
 8007944:	e7fe      	b.n	8007944 <_readt.lto_priv.1+0x8>
 8007946:	3018      	adds	r0, #24
}
 8007948:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800794c:	f7ff bf8c 	b.w	8007868 <ibqReadTimeout.part.0>

08007950 <obqWriteTimeout.part.0>:
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
 8007950:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007954:	461f      	mov	r7, r3
 8007956:	4604      	mov	r4, r0
  size_t w = 0;
 8007958:	2600      	movs	r6, #0
 800795a:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8007a08 <obqWriteTimeout.part.0+0xb8>
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
 800795e:	4690      	mov	r8, r2
 8007960:	460d      	mov	r5, r1
  osalSysLock();
 8007962:	f7fd f81f 	bl	80049a4 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007966:	f7fe fad9 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800796a:	f8da 3000 	ldr.w	r3, [sl]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800796e:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 8007972:	eb07 0903 	add.w	r9, r7, r3
    if (obqp->ptr == NULL) {
 8007976:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007978:	b93b      	cbnz	r3, 800798a <obqWriteTimeout.part.0+0x3a>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800797a:	f11b 0f03 	cmn.w	fp, #3
 800797e:	d92a      	bls.n	80079d6 <obqWriteTimeout.part.0+0x86>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8007980:	4639      	mov	r1, r7
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 8007982:	4620      	mov	r0, r4
 8007984:	f7fe ff19 	bl	80067ba <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 8007988:	bb68      	cbnz	r0, 80079e6 <obqWriteTimeout.part.0+0x96>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800798a:	e9d4 020a 	ldrd	r0, r2, [r4, #40]	; 0x28
    if (size > (n - w)) {
 800798e:	eba8 0306 	sub.w	r3, r8, r6
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8007992:	1a12      	subs	r2, r2, r0
    if (size > (n - w)) {
 8007994:	429a      	cmp	r2, r3
 8007996:	bf28      	it	cs
 8007998:	461a      	movcs	r2, r3
    if (size > 64U) {
 800799a:	2a40      	cmp	r2, #64	; 0x40
 800799c:	d929      	bls.n	80079f2 <obqWriteTimeout.part.0+0xa2>
      memcpy(obqp->ptr, bp, 64U);
 800799e:	f105 0340 	add.w	r3, r5, #64	; 0x40
 80079a2:	f855 2b04 	ldr.w	r2, [r5], #4
 80079a6:	429d      	cmp	r5, r3
 80079a8:	f840 2b04 	str.w	r2, [r0], #4
 80079ac:	d1f9      	bne.n	80079a2 <obqWriteTimeout.part.0+0x52>
      obqp->ptr += 64U;
 80079ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      w         += 64U;
 80079b0:	3640      	adds	r6, #64	; 0x40
      obqp->ptr += 64U;
 80079b2:	3340      	adds	r3, #64	; 0x40
 80079b4:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 80079b6:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 80079ba:	429a      	cmp	r2, r3
 80079bc:	d304      	bcc.n	80079c8 <obqWriteTimeout.part.0+0x78>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80079be:	69e1      	ldr	r1, [r4, #28]
 80079c0:	4620      	mov	r0, r4
 80079c2:	3904      	subs	r1, #4
 80079c4:	f7fd f844 	bl	8004a50 <obqPostFullBufferS>
    osalSysUnlock();
 80079c8:	f7fd fa10 	bl	8004dec <osalSysUnlock.lto_priv.0>
    if (w >= n) {
 80079cc:	45b0      	cmp	r8, r6
 80079ce:	d90c      	bls.n	80079ea <obqWriteTimeout.part.0+0x9a>
    osalSysLock();
 80079d0:	f7fc ffe8 	bl	80049a4 <vPortEnterCritical>
  while (true) {
 80079d4:	e7cf      	b.n	8007976 <obqWriteTimeout.part.0+0x26>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80079d6:	f7fe faa1 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80079da:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80079de:	eba9 0101 	sub.w	r1, r9, r1
        if (next_timeout > timeout) {
 80079e2:	428f      	cmp	r7, r1
 80079e4:	d2cd      	bcs.n	8007982 <obqWriteTimeout.part.0+0x32>
        osalSysUnlock();
 80079e6:	f7fd fa01 	bl	8004dec <osalSysUnlock.lto_priv.0>
}
 80079ea:	4630      	mov	r0, r6
 80079ec:	b003      	add	sp, #12
 80079ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      memcpy(obqp->ptr, bp, size);
 80079f2:	4629      	mov	r1, r5
 80079f4:	9201      	str	r2, [sp, #4]
 80079f6:	f7fc f86d 	bl	8003ad4 <memcpy>
      bp        += size;
 80079fa:	9a01      	ldr	r2, [sp, #4]
      obqp->ptr += size;
 80079fc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
 80079fe:	4415      	add	r5, r2
      obqp->ptr += size;
 8007a00:	4413      	add	r3, r2
 8007a02:	62a3      	str	r3, [r4, #40]	; 0x28
      w         += size;
 8007a04:	4416      	add	r6, r2
 8007a06:	e7d6      	b.n	80079b6 <obqWriteTimeout.part.0+0x66>
 8007a08:	20001648 	.word	0x20001648

08007a0c <_writet.lto_priv.1>:
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007a0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007a10:	4615      	mov	r5, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a12:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007a16:	461f      	mov	r7, r3
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a18:	6893      	ldr	r3, [r2, #8]
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007a1a:	4604      	mov	r4, r0
 8007a1c:	460e      	mov	r6, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a1e:	b113      	cbz	r3, 8007a26 <_writet.lto_priv.1+0x1a>
 8007a20:	2101      	movs	r1, #1
 8007a22:	6810      	ldr	r0, [r2, #0]
 8007a24:	4798      	blx	r3
  osalDbgCheck(n > 0U);
 8007a26:	b915      	cbnz	r5, 8007a2e <_writet.lto_priv.1+0x22>
 8007a28:	f7fc ffcc 	bl	80049c4 <vTaskEndScheduler>
 8007a2c:	e7fe      	b.n	8007a2c <_writet.lto_priv.1+0x20>
 8007a2e:	463b      	mov	r3, r7
 8007a30:	462a      	mov	r2, r5
 8007a32:	4631      	mov	r1, r6
 8007a34:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8007a38:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8007a3c:	f7ff bf88 	b.w	8007950 <obqWriteTimeout.part.0>

08007a40 <_write.lto_priv.1>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a40:	b570      	push	{r4, r5, r6, lr}
 8007a42:	4615      	mov	r5, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a44:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a48:	4604      	mov	r4, r0
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a4a:	6893      	ldr	r3, [r2, #8]
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a4c:	460e      	mov	r6, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a4e:	b113      	cbz	r3, 8007a56 <_write.lto_priv.1+0x16>
 8007a50:	2101      	movs	r1, #1
 8007a52:	6810      	ldr	r0, [r2, #0]
 8007a54:	4798      	blx	r3
 8007a56:	b915      	cbnz	r5, 8007a5e <_write.lto_priv.1+0x1e>
 8007a58:	f7fc ffb4 	bl	80049c4 <vTaskEndScheduler>
 8007a5c:	e7fe      	b.n	8007a5c <_write.lto_priv.1+0x1c>
 8007a5e:	462a      	mov	r2, r5
 8007a60:	4631      	mov	r1, r6
 8007a62:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8007a66:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8007a6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8007a6e:	f7ff bf6f 	b.w	8007950 <obqWriteTimeout.part.0>

08007a72 <_writes>:
static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 8007a72:	b538      	push	{r3, r4, r5, lr}
 8007a74:	4605      	mov	r5, r0
  if (msp->size - msp->eos < n)
 8007a76:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8007a7a:	1a1c      	subs	r4, r3, r0
 8007a7c:	4294      	cmp	r4, r2
 8007a7e:	bf28      	it	cs
 8007a80:	4614      	movcs	r4, r2
  memcpy(msp->buffer + msp->eos, bp, n);
 8007a82:	686b      	ldr	r3, [r5, #4]
 8007a84:	4622      	mov	r2, r4
 8007a86:	4418      	add	r0, r3
 8007a88:	f7fc f824 	bl	8003ad4 <memcpy>
  msp->eos += n;
 8007a8c:	68eb      	ldr	r3, [r5, #12]
}
 8007a8e:	4620      	mov	r0, r4
  msp->eos += n;
 8007a90:	4423      	add	r3, r4
 8007a92:	60eb      	str	r3, [r5, #12]
}
 8007a94:	bd38      	pop	{r3, r4, r5, pc}

08007a96 <_reads>:
static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8007a96:	b538      	push	{r3, r4, r5, lr}
 8007a98:	4605      	mov	r5, r0
 8007a9a:	4608      	mov	r0, r1
  if (msp->eos - msp->offset < n)
 8007a9c:	e9d5 3103 	ldrd	r3, r1, [r5, #12]
 8007aa0:	1a5c      	subs	r4, r3, r1
 8007aa2:	4294      	cmp	r4, r2
 8007aa4:	bf28      	it	cs
 8007aa6:	4614      	movcs	r4, r2
  memcpy(bp, msp->buffer + msp->offset, n);
 8007aa8:	686b      	ldr	r3, [r5, #4]
 8007aaa:	4622      	mov	r2, r4
 8007aac:	4419      	add	r1, r3
 8007aae:	f7fc f811 	bl	8003ad4 <memcpy>
  msp->offset += n;
 8007ab2:	692b      	ldr	r3, [r5, #16]
}
 8007ab4:	4620      	mov	r0, r4
  msp->offset += n;
 8007ab6:	4423      	add	r3, r4
 8007ab8:	612b      	str	r3, [r5, #16]
}
 8007aba:	bd38      	pop	{r3, r4, r5, pc}

08007abc <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8007abc:	b570      	push	{r4, r5, r6, lr}
 8007abe:	4604      	mov	r4, r0
 8007ac0:	460e      	mov	r6, r1
 8007ac2:	4615      	mov	r5, r2
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007ac4:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007ac8:	b11b      	cbz	r3, 8007ad2 <usbInitEndpointI+0x16>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8007aca:	b928      	cbnz	r0, 8007ad8 <usbInitEndpointI+0x1c>
 8007acc:	f7fc ff7a 	bl	80049c4 <vTaskEndScheduler>
 8007ad0:	e7fe      	b.n	8007ad0 <usbInitEndpointI+0x14>
  osalDbgCheckClassI();
 8007ad2:	f7fc ff77 	bl	80049c4 <vTaskEndScheduler>
 8007ad6:	e7fe      	b.n	8007ad6 <usbInitEndpointI+0x1a>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8007ad8:	7803      	ldrb	r3, [r0, #0]
 8007ada:	2b04      	cmp	r3, #4
 8007adc:	d002      	beq.n	8007ae4 <usbInitEndpointI+0x28>
 8007ade:	f7fc ff71 	bl	80049c4 <vTaskEndScheduler>
 8007ae2:	e7fe      	b.n	8007ae2 <usbInitEndpointI+0x26>
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8007ae4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8007ae8:	68d9      	ldr	r1, [r3, #12]
 8007aea:	b111      	cbz	r1, 8007af2 <usbInitEndpointI+0x36>
 8007aec:	f7fc ff6a 	bl	80049c4 <vTaskEndScheduler>
 8007af0:	e7fe      	b.n	8007af0 <usbInitEndpointI+0x34>
  if (epcp->in_state != NULL) {
 8007af2:	6950      	ldr	r0, [r2, #20]
  usbp->epc[ep] = epcp;
 8007af4:	60da      	str	r2, [r3, #12]
  if (epcp->in_state != NULL) {
 8007af6:	b110      	cbz	r0, 8007afe <usbInitEndpointI+0x42>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8007af8:	2210      	movs	r2, #16
 8007afa:	f003 fe5f 	bl	800b7bc <memset>
  if (epcp->out_state != NULL) {
 8007afe:	69a8      	ldr	r0, [r5, #24]
 8007b00:	b118      	cbz	r0, 8007b0a <usbInitEndpointI+0x4e>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8007b02:	2210      	movs	r2, #16
 8007b04:	2100      	movs	r1, #0
 8007b06:	f003 fe59 	bl	800b7bc <memset>
  usb_lld_init_endpoint(usbp, ep);
 8007b0a:	4631      	mov	r1, r6
 8007b0c:	4620      	mov	r0, r4
}
 8007b0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_init_endpoint(usbp, ep);
 8007b12:	f7fd b8d7 	b.w	8004cc4 <usb_lld_init_endpoint>

08007b16 <get_history>:
    shp->sh_end -= shp->sh_size;
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
 8007b16:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
 8007b1a:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
static int get_history(ShellHistory *shp, char *line, int dir) {
 8007b1e:	4604      	mov	r4, r0
 8007b20:	4688      	mov	r8, r1
  int idx = shp->sh_beg;
 8007b22:	4628      	mov	r0, r5
  int count=0;
 8007b24:	2100      	movs	r1, #0
  while (idx != shp->sh_end) {
 8007b26:	4286      	cmp	r6, r0
 8007b28:	d12a      	bne.n	8007b80 <get_history+0x6a>
    if (idx >= shp->sh_size)
      idx -= shp->sh_size;
    count++;
  }

  if (dir == SHELL_HIST_DIR_FW) {
 8007b2a:	2a01      	cmp	r2, #1
 8007b2c:	d104      	bne.n	8007b38 <get_history+0x22>
    if (shp->sh_cur > 0)
 8007b2e:	6923      	ldr	r3, [r4, #16]
 8007b30:	2b00      	cmp	r3, #0
 8007b32:	dd48      	ble.n	8007bc6 <get_history+0xb0>
      shp->sh_cur -= 2;
 8007b34:	3b02      	subs	r3, #2
 8007b36:	6123      	str	r3, [r4, #16]
    else
      return 0;
  }

  if (count >= shp->sh_cur) {
 8007b38:	6923      	ldr	r3, [r4, #16]
 8007b3a:	428b      	cmp	r3, r1
 8007b3c:	dc45      	bgt.n	8007bca <get_history+0xb4>
    idx += *(shp->sh_buffer + idx) + 1;
 8007b3e:	f8d4 c000 	ldr.w	ip, [r4]
 8007b42:	3901      	subs	r1, #1
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
      idx += *(shp->sh_buffer + idx) + 1;
 8007b44:	f81c 7005 	ldrb.w	r7, [ip, r5]
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8007b48:	42a8      	cmp	r0, r5
      idx += *(shp->sh_buffer + idx) + 1;
 8007b4a:	463e      	mov	r6, r7
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8007b4c:	d001      	beq.n	8007b52 <get_history+0x3c>
 8007b4e:	428b      	cmp	r3, r1
 8007b50:	d120      	bne.n	8007b94 <get_history+0x7e>
      i++;
    }

    int length = *(shp->sh_buffer + idx);

    if (length > 0) {
 8007b52:	b39f      	cbz	r7, 8007bbc <get_history+0xa6>
      shp->sh_cur++;
 8007b54:	3301      	adds	r3, #1

      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8007b56:	2240      	movs	r2, #64	; 0x40
 8007b58:	2100      	movs	r1, #0
      shp->sh_cur++;
 8007b5a:	6123      	str	r3, [r4, #16]
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8007b5c:	4640      	mov	r0, r8
 8007b5e:	f003 fe2d 	bl	800b7bc <memset>
      if ((idx + length) < shp->sh_size) {
 8007b62:	6863      	ldr	r3, [r4, #4]
 8007b64:	19ea      	adds	r2, r5, r7
 8007b66:	429a      	cmp	r2, r3
 8007b68:	6820      	ldr	r0, [r4, #0]
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8007b6a:	f105 0101 	add.w	r1, r5, #1
      if ((idx + length) < shp->sh_size) {
 8007b6e:	da19      	bge.n	8007ba4 <get_history+0x8e>
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8007b70:	4401      	add	r1, r0
 8007b72:	463a      	mov	r2, r7
 8007b74:	4640      	mov	r0, r8
         * Since the saved line was split at the end of the buffer,
         * get the line in two parts.
         */
        int part_len = shp->sh_size - idx - 1;
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8007b76:	f7fb ffad 	bl	8003ad4 <memcpy>
      shp->sh_cur++;
      return 0;
    }
  }
  return -1;
}
 8007b7a:	4630      	mov	r0, r6
 8007b7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    idx += *(shp->sh_buffer + idx) + 1;
 8007b80:	6823      	ldr	r3, [r4, #0]
    count++;
 8007b82:	3101      	adds	r1, #1
    idx += *(shp->sh_buffer + idx) + 1;
 8007b84:	5c1b      	ldrb	r3, [r3, r0]
 8007b86:	3301      	adds	r3, #1
 8007b88:	4418      	add	r0, r3
    if (idx >= shp->sh_size)
 8007b8a:	6863      	ldr	r3, [r4, #4]
 8007b8c:	4283      	cmp	r3, r0
      idx -= shp->sh_size;
 8007b8e:	bfd8      	it	le
 8007b90:	1ac0      	suble	r0, r0, r3
    count++;
 8007b92:	e7c8      	b.n	8007b26 <get_history+0x10>
      if (idx >= shp->sh_size)
 8007b94:	6866      	ldr	r6, [r4, #4]
      idx += *(shp->sh_buffer + idx) + 1;
 8007b96:	3701      	adds	r7, #1
 8007b98:	443d      	add	r5, r7
      if (idx >= shp->sh_size)
 8007b9a:	42ae      	cmp	r6, r5
        idx -= shp->sh_size;
 8007b9c:	bfd8      	it	le
 8007b9e:	1bad      	suble	r5, r5, r6
      i++;
 8007ba0:	3901      	subs	r1, #1
 8007ba2:	e7cf      	b.n	8007b44 <get_history+0x2e>
        int part_len = shp->sh_size - idx - 1;
 8007ba4:	1b5d      	subs	r5, r3, r5
 8007ba6:	3d01      	subs	r5, #1
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8007ba8:	4401      	add	r1, r0
 8007baa:	462a      	mov	r2, r5
 8007bac:	4640      	mov	r0, r8
 8007bae:	f7fb ff91 	bl	8003ad4 <memcpy>
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8007bb2:	6821      	ldr	r1, [r4, #0]
 8007bb4:	1b7a      	subs	r2, r7, r5
 8007bb6:	eb08 0005 	add.w	r0, r8, r5
 8007bba:	e7dc      	b.n	8007b76 <get_history+0x60>
    else if (dir == SHELL_HIST_DIR_FW) {
 8007bbc:	2a01      	cmp	r2, #1
 8007bbe:	d104      	bne.n	8007bca <get_history+0xb4>
      shp->sh_cur++;
 8007bc0:	3301      	adds	r3, #1
 8007bc2:	6123      	str	r3, [r4, #16]
      return 0;
 8007bc4:	e7d9      	b.n	8007b7a <get_history+0x64>
      return 0;
 8007bc6:	2600      	movs	r6, #0
 8007bc8:	e7d7      	b.n	8007b7a <get_history+0x64>
  return -1;
 8007bca:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8007bce:	e7d4      	b.n	8007b7a <get_history+0x64>

08007bd0 <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007bd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007bd4:	460d      	mov	r5, r1
 8007bd6:	e9dd 9808 	ldrd	r9, r8, [sp, #32]
 8007bda:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007bdc:	0096      	lsls	r6, r2, #2
 8007bde:	4632      	mov	r2, r6
 8007be0:	21a5      	movs	r1, #165	; 0xa5
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007be2:	4607      	mov	r7, r0
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007be4:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007be6:	469a      	mov	sl, r3
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007be8:	f003 fde8 	bl	800b7bc <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8007bec:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007bee:	3e04      	subs	r6, #4
 8007bf0:	4432      	add	r2, r6
 8007bf2:	1e6b      	subs	r3, r5, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8007bf4:	f022 0207 	bic.w	r2, r2, #7
 8007bf8:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8007bfc:	350f      	adds	r5, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007bfe:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8007c02:	f801 0b01 	strb.w	r0, [r1], #1
		if( pcName[ x ] == 0x00 )
 8007c06:	b108      	cbz	r0, 8007c0c <prvInitialiseNewTask.constprop.0+0x3c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8007c08:	42ab      	cmp	r3, r5
 8007c0a:	d1f8      	bne.n	8007bfe <prvInitialiseNewTask.constprop.0+0x2e>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c0c:	f1c9 0305 	rsb	r3, r9, #5
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007c10:	2100      	movs	r1, #0
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c12:	61a3      	str	r3, [r4, #24]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8007c14:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
		pxNewTCB->ulNotifiedValue = 0;
 8007c18:	6621      	str	r1, [r4, #96]	; 0x60
		pxNewTCB->uxMutexesHeld = 0;
 8007c1a:	e9c4 9113 	strd	r9, r1, [r4, #76]	; 0x4c
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 8007c1e:	e9c4 1115 	strd	r1, r1, [r4, #84]	; 0x54
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007c22:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
 8007c26:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
	pxItem->pvContainer = NULL;
 8007c2a:	6161      	str	r1, [r4, #20]
 8007c2c:	62a1      	str	r1, [r4, #40]	; 0x28
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007c2e:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007c30:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 8007c32:	65e1      	str	r1, [r4, #92]	; 0x5c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007c34:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
 8007c38:	f842 3c04 	str.w	r3, [r2, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007c3c:	4b0a      	ldr	r3, [pc, #40]	; (8007c68 <prvInitialiseNewTask.constprop.0+0x98>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8007c3e:	f027 0701 	bic.w	r7, r7, #1
 8007c42:	f842 7c08 	str.w	r7, [r2, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007c46:	f842 3c0c 	str.w	r3, [r2, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8007c4a:	f842 ac20 	str.w	sl, [r2, #-32]
	*pxTopOfStack = 0;
 8007c4e:	f842 1c44 	str.w	r1, [r2, #-68]
	*pxTopOfStack = 0;
 8007c52:	f842 1d48 	str.w	r1, [r2, #-72]!
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007c56:	6022      	str	r2, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8007c58:	f1b8 0f00 	cmp.w	r8, #0
 8007c5c:	d001      	beq.n	8007c62 <prvInitialiseNewTask.constprop.0+0x92>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007c5e:	f8c8 4000 	str.w	r4, [r8]
}
 8007c62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007c66:	bf00      	nop
 8007c68:	08004dbd 	.word	0x08004dbd

08007c6c <xTaskCreate.isra.0>:
	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 8007c6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007c70:	4606      	mov	r6, r0
 8007c72:	b085      	sub	sp, #20
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c74:	0090      	lsls	r0, r2, #2
	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 8007c76:	460f      	mov	r7, r1
 8007c78:	e9dd 9a0e 	ldrd	r9, sl, [sp, #56]	; 0x38
 8007c7c:	4693      	mov	fp, r2
 8007c7e:	4698      	mov	r8, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c80:	f7fd fac8 	bl	8005214 <pvPortMalloc>
			if( pxStack != NULL )
 8007c84:	4605      	mov	r5, r0
 8007c86:	b1f0      	cbz	r0, 8007cc6 <xTaskCreate.isra.0+0x5a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8007c88:	2068      	movs	r0, #104	; 0x68
 8007c8a:	f7fd fac3 	bl	8005214 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007c8e:	4604      	mov	r4, r0
 8007c90:	b198      	cbz	r0, 8007cba <xTaskCreate.isra.0+0x4e>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8007c92:	2300      	movs	r3, #0
					pxNewTCB->pxStack = pxStack;
 8007c94:	6305      	str	r5, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8007c96:	f880 3065 	strb.w	r3, [r0, #101]	; 0x65
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8007c9a:	465a      	mov	r2, fp
 8007c9c:	e9cd a001 	strd	sl, r0, [sp, #4]
 8007ca0:	4643      	mov	r3, r8
 8007ca2:	4630      	mov	r0, r6
 8007ca4:	4639      	mov	r1, r7
 8007ca6:	f8cd 9000 	str.w	r9, [sp]
 8007caa:	f7ff ff91 	bl	8007bd0 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 8007cae:	4620      	mov	r0, r4
	}
 8007cb0:	b005      	add	sp, #20
 8007cb2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			prvAddNewTaskToReadyList( pxNewTCB );
 8007cb6:	f7fd b975 	b.w	8004fa4 <prvAddNewTaskToReadyList>
					vPortFree( pxStack );
 8007cba:	4628      	mov	r0, r5
	}
 8007cbc:	b005      	add	sp, #20
 8007cbe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					vPortFree( pxStack );
 8007cc2:	f7fd bb27 	b.w	8005314 <vPortFree>
	}
 8007cc6:	b005      	add	sp, #20
 8007cc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08007ccc <shellStart.constprop.0>:
    syslog("Shell 0x%08x started (%s).", activeShell, activeShell->taskName);

    shellThread(&activeShell->shellCfg);
}

bool shellStart(BaseSequentialStream* stream,
 8007ccc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007cce:	4606      	mov	r6, r0
                unsigned int histSize, const char* taskName,
                void(*terminateCallback)(void* param), void* param)
{
    ActiveShell* activeShell = pvPortMalloc(sizeof(ActiveShell));
 8007cd0:	2020      	movs	r0, #32
bool shellStart(BaseSequentialStream* stream,
 8007cd2:	460d      	mov	r5, r1
 8007cd4:	4617      	mov	r7, r2
    ActiveShell* activeShell = pvPortMalloc(sizeof(ActiveShell));
 8007cd6:	f7fd fa9d 	bl	8005214 <pvPortMalloc>
    if(!activeShell) {
 8007cda:	4604      	mov	r4, r0
 8007cdc:	b300      	cbz	r0, 8007d20 <shellStart.constprop.0+0x54>
        return false;
    }

    memset(activeShell, 0, sizeof(*activeShell));
 8007cde:	2220      	movs	r2, #32
 8007ce0:	2100      	movs	r1, #0
 8007ce2:	f003 fd6b 	bl	800b7bc <memset>

    activeShell->param = param;
    activeShell->terminateCallback = terminateCallback;

    activeShell->shellCfg.sc_channel = stream;
    activeShell->shellCfg.sc_commands = shellCommands;
 8007ce6:	4b0f      	ldr	r3, [pc, #60]	; (8007d24 <shellStart.constprop.0+0x58>)

    if(histSize) {
        activeShell->shellCfg.sc_histbuf = pvPortMalloc(histSize);
 8007ce8:	2080      	movs	r0, #128	; 0x80
    activeShell->terminateCallback = terminateCallback;
 8007cea:	61a7      	str	r7, [r4, #24]
    activeShell->shellCfg.sc_channel = stream;
 8007cec:	6066      	str	r6, [r4, #4]
    activeShell->shellCfg.sc_commands = shellCommands;
 8007cee:	60a3      	str	r3, [r4, #8]
        activeShell->shellCfg.sc_histbuf = pvPortMalloc(histSize);
 8007cf0:	f7fd fa90 	bl	8005214 <pvPortMalloc>
 8007cf4:	60e0      	str	r0, [r4, #12]
        if(activeShell->shellCfg.sc_histbuf) {
 8007cf6:	b128      	cbz	r0, 8007d04 <shellStart.constprop.0+0x38>
            memset(activeShell->shellCfg.sc_histbuf, 0, histSize);
 8007cf8:	2780      	movs	r7, #128	; 0x80
 8007cfa:	2100      	movs	r1, #0
 8007cfc:	463a      	mov	r2, r7
 8007cfe:	f003 fd5d 	bl	800b7bc <memset>
            activeShell->shellCfg.sc_histsize = histSize;
 8007d02:	6127      	str	r7, [r4, #16]
        }
    }

    activeShell->stream = stream;
    activeShell->taskName = taskName;
    xTaskCreate(shellStartThread, taskName, 256, activeShell, 2, NULL);
 8007d04:	2302      	movs	r3, #2
 8007d06:	2200      	movs	r2, #0
 8007d08:	4807      	ldr	r0, [pc, #28]	; (8007d28 <shellStart.constprop.0+0x5c>)
    activeShell->stream = stream;
 8007d0a:	6166      	str	r6, [r4, #20]
    activeShell->taskName = taskName;
 8007d0c:	6025      	str	r5, [r4, #0]
    xTaskCreate(shellStartThread, taskName, 256, activeShell, 2, NULL);
 8007d0e:	4629      	mov	r1, r5
 8007d10:	e9cd 3200 	strd	r3, r2, [sp]
 8007d14:	4623      	mov	r3, r4
 8007d16:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d1a:	f7ff ffa7 	bl	8007c6c <xTaskCreate.isra.0>

    return true;
 8007d1e:	2001      	movs	r0, #1
}
 8007d20:	b003      	add	sp, #12
 8007d22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007d24:	2000085c 	.word	0x2000085c
 8007d28:	08009b6d 	.word	0x08009b6d

08007d2c <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8007d2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8007d30:	4c62      	ldr	r4, [pc, #392]	; (8007ebc <VectorDC+0x190>)
 8007d32:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
  uint16_t cr1 = u->CR1;
 8007d36:	68f7      	ldr	r7, [r6, #12]
  uint16_t sr = u->SR;
 8007d38:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 8007d3a:	05da      	lsls	r2, r3, #23
  uint16_t sr = u->SR;
 8007d3c:	b29d      	uxth	r5, r3
  if (sr & USART_SR_LBD) {
 8007d3e:	d50b      	bpl.n	8007d58 <VectorDC+0x2c>
    osalSysLockFromISR();
 8007d40:	f7fd fd7a 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8007d44:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007d48:	1d20      	adds	r0, r4, #4
 8007d4a:	f7ff f8cb 	bl	8006ee4 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8007d4e:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8007d52:	6033      	str	r3, [r6, #0]
    osalSysUnlockFromISR();
 8007d54:	f7fd fd84 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
  osalSysLockFromISR();
 8007d58:	f7fd fd6e 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdp, sts);
 8007d5c:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8007ec0 <VectorDC+0x194>
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007d60:	f108 0914 	add.w	r9, r8, #20
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8007d64:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 8007d68:	d124      	bne.n	8007db4 <VectorDC+0x88>
  osalSysUnlockFromISR();
 8007d6a:	f7fd fd79 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8007d6e:	0639      	lsls	r1, r7, #24
 8007d70:	d57b      	bpl.n	8007e6a <VectorDC+0x13e>
 8007d72:	062a      	lsls	r2, r5, #24
 8007d74:	d579      	bpl.n	8007e6a <VectorDC+0x13e>
    osalSysLockFromISR();
 8007d76:	f7fd fd5f 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007d7a:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007d7e:	2b00      	cmp	r3, #0
 8007d80:	f000 8097 	beq.w	8007eb2 <VectorDC+0x186>
  if (oqIsEmptyI(oqp)) {
 8007d84:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8007d88:	429a      	cmp	r2, r3
 8007d8a:	d102      	bne.n	8007d92 <VectorDC+0x66>
 8007d8c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007d8e:	2a00      	cmp	r2, #0
 8007d90:	d15f      	bne.n	8007e52 <VectorDC+0x126>
  oqp->q_counter++;
 8007d92:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007d94:	3201      	adds	r2, #1
 8007d96:	6462      	str	r2, [r4, #68]	; 0x44
  b = *oqp->q_rdptr++;
 8007d98:	1c5a      	adds	r2, r3, #1
 8007d9a:	6562      	str	r2, [r4, #84]	; 0x54
 8007d9c:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 8007da0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8007da2:	429a      	cmp	r2, r3
 8007da4:	f080 8082 	bcs.w	8007eac <VectorDC+0x180>
  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8007da8:	4846      	ldr	r0, [pc, #280]	; (8007ec4 <VectorDC+0x198>)
 8007daa:	f7ff f877 	bl	8006e9c <osalThreadDequeueNextI.constprop.0>
      u->DR = b;
 8007dae:	f8c6 8004 	str.w	r8, [r6, #4]
 8007db2:	e058      	b.n	8007e66 <VectorDC+0x13a>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8007db4:	072b      	lsls	r3, r5, #28
 8007db6:	d013      	beq.n	8007de0 <VectorDC+0xb4>
    sts |= SD_OVERRUN_ERROR;
 8007db8:	f015 0f08 	tst.w	r5, #8
 8007dbc:	bf0c      	ite	eq
 8007dbe:	2100      	moveq	r1, #0
 8007dc0:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8007dc2:	07e8      	lsls	r0, r5, #31
    sts |= SD_PARITY_ERROR;
 8007dc4:	bf48      	it	mi
 8007dc6:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8007dca:	07aa      	lsls	r2, r5, #30
    sts |= SD_FRAMING_ERROR;
 8007dcc:	bf48      	it	mi
 8007dce:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8007dd2:	076b      	lsls	r3, r5, #29
  chnAddFlagsI(sdp, sts);
 8007dd4:	4640      	mov	r0, r8
    sts |= SD_NOISE_ERROR;
 8007dd6:	bf48      	it	mi
 8007dd8:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
  chnAddFlagsI(sdp, sts);
 8007ddc:	f7ff f882 	bl	8006ee4 <osalEventBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 8007de0:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 8007de2:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 8007de6:	d51b      	bpl.n	8007e20 <VectorDC+0xf4>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007de8:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007dec:	b913      	cbnz	r3, 8007df4 <VectorDC+0xc8>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8007dee:	f7fc fde9 	bl	80049c4 <vTaskEndScheduler>
 8007df2:	e7fe      	b.n	8007df2 <VectorDC+0xc6>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8007df4:	6a23      	ldr	r3, [r4, #32]
    b = (uint8_t)u->DR & sdp->rxmask;
 8007df6:	f894 5084 	ldrb.w	r5, [r4, #132]	; 0x84
 8007dfa:	b91b      	cbnz	r3, 8007e04 <VectorDC+0xd8>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8007dfc:	2104      	movs	r1, #4
 8007dfe:	4640      	mov	r0, r8
 8007e00:	f7ff f870 	bl	8006ee4 <osalEventBroadcastFlagsI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007e04:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007e08:	b303      	cbz	r3, 8007e4c <VectorDC+0x120>
  if (iqIsFullI(iqp)) {
 8007e0a:	e9d4 320b 	ldrd	r3, r2, [r4, #44]	; 0x2c
 8007e0e:	4293      	cmp	r3, r2
 8007e10:	d109      	bne.n	8007e26 <VectorDC+0xfa>
 8007e12:	6a22      	ldr	r2, [r4, #32]
 8007e14:	b13a      	cbz	r2, 8007e26 <VectorDC+0xfa>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8007e16:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8007e1a:	4640      	mov	r0, r8
 8007e1c:	f7ff f862 	bl	8006ee4 <osalEventBroadcastFlagsI>
    sr = u->SR;
 8007e20:	6835      	ldr	r5, [r6, #0]
 8007e22:	b2ad      	uxth	r5, r5
 8007e24:	e79e      	b.n	8007d64 <VectorDC+0x38>
  iqp->q_counter++;
 8007e26:	6a22      	ldr	r2, [r4, #32]
    b = (uint8_t)u->DR & sdp->rxmask;
 8007e28:	ea05 050a 	and.w	r5, r5, sl
 8007e2c:	3201      	adds	r2, #1
 8007e2e:	6222      	str	r2, [r4, #32]
  *iqp->q_wrptr++ = b;
 8007e30:	1c5a      	adds	r2, r3, #1
 8007e32:	62e2      	str	r2, [r4, #44]	; 0x2c
 8007e34:	701d      	strb	r5, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8007e36:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
 8007e3a:	429a      	cmp	r2, r3
    iqp->q_wrptr = iqp->q_buffer;
 8007e3c:	bf28      	it	cs
 8007e3e:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007e40:	4648      	mov	r0, r9
    iqp->q_wrptr = iqp->q_buffer;
 8007e42:	bf28      	it	cs
 8007e44:	62e3      	strcs	r3, [r4, #44]	; 0x2c
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007e46:	f7ff f829 	bl	8006e9c <osalThreadDequeueNextI.constprop.0>
 8007e4a:	e7e9      	b.n	8007e20 <VectorDC+0xf4>
  osalDbgCheckClassI();
 8007e4c:	f7fc fdba 	bl	80049c4 <vTaskEndScheduler>
 8007e50:	e7fe      	b.n	8007e50 <VectorDC+0x124>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8007e52:	2108      	movs	r1, #8
 8007e54:	481a      	ldr	r0, [pc, #104]	; (8007ec0 <VectorDC+0x194>)
 8007e56:	f7ff f845 	bl	8006ee4 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8007e5a:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8007e5e:	403b      	ands	r3, r7
 8007e60:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007e64:	60f3      	str	r3, [r6, #12]
    osalSysUnlockFromISR();
 8007e66:	f7fd fcfb 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
  if (sr & USART_SR_TC) {
 8007e6a:	066b      	lsls	r3, r5, #25
 8007e6c:	d515      	bpl.n	8007e9a <VectorDC+0x16e>
    osalSysLockFromISR();
 8007e6e:	f7fd fce3 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
    if (oqIsEmptyI(&sdp->oqueue))
 8007e72:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8007e76:	429a      	cmp	r2, r3
 8007e78:	d105      	bne.n	8007e86 <VectorDC+0x15a>
 8007e7a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007e7c:	b11b      	cbz	r3, 8007e86 <VectorDC+0x15a>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8007e7e:	2110      	movs	r1, #16
 8007e80:	480f      	ldr	r0, [pc, #60]	; (8007ec0 <VectorDC+0x194>)
 8007e82:	f7ff f82f 	bl	8006ee4 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_TC;
 8007e86:	f06f 0340 	mvn.w	r3, #64	; 0x40
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8007e8a:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 8007e8e:	043f      	lsls	r7, r7, #16
 8007e90:	0c3f      	lsrs	r7, r7, #16
 8007e92:	60f7      	str	r7, [r6, #12]
    u->SR = ~USART_SR_TC;
 8007e94:	6033      	str	r3, [r6, #0]
    osalSysUnlockFromISR();
 8007e96:	f7fd fce3 	bl	8005860 <osalSysUnlockFromISR.lto_priv.0>
 8007e9a:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8007e9c:	4b0a      	ldr	r3, [pc, #40]	; (8007ec8 <VectorDC+0x19c>)
 8007e9e:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8007ea0:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8007ea2:	b14a      	cbz	r2, 8007eb8 <VectorDC+0x18c>
}
 8007ea4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007ea8:	f7fb bf68 	b.w	8003d7c <Vector6C.part.0>
    oqp->q_rdptr = oqp->q_buffer;
 8007eac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007eae:	6563      	str	r3, [r4, #84]	; 0x54
 8007eb0:	e77a      	b.n	8007da8 <VectorDC+0x7c>
  osalDbgCheckClassI();
 8007eb2:	f7fc fd87 	bl	80049c4 <vTaskEndScheduler>
 8007eb6:	e7fe      	b.n	8007eb6 <VectorDC+0x18a>
 8007eb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007ebc:	200009bc 	.word	0x200009bc
 8007ec0:	200009c0 	.word	0x200009c0
 8007ec4:	200009f8 	.word	0x200009f8
 8007ec8:	2000164c 	.word	0x2000164c

08007ecc <sanityRebootMonitorTask>:
{
 8007ecc:	b508      	push	{r3, lr}
    uint32_t numberOfSeconds = sanityRebootSeconds;
 8007ece:	4b14      	ldr	r3, [pc, #80]	; (8007f20 <sanityRebootMonitorTask+0x54>)
 8007ed0:	6819      	ldr	r1, [r3, #0]
    if(numberOfSeconds &&
 8007ed2:	b199      	cbz	r1, 8007efc <sanityRebootMonitorTask+0x30>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007ed4:	f7fe f822 	bl	8005f1c <vPortValidateInterruptPriority>
            osalOsGetSystemTimeX() >= OSAL_S2ST(numberOfSeconds)) {
 8007ed8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		xReturn = xTickCount;
 8007edc:	4b11      	ldr	r3, [pc, #68]	; (8007f24 <sanityRebootMonitorTask+0x58>)
 8007ede:	4351      	muls	r1, r2
 8007ee0:	681b      	ldr	r3, [r3, #0]
    if(numberOfSeconds &&
 8007ee2:	4299      	cmp	r1, r3
 8007ee4:	d80a      	bhi.n	8007efc <sanityRebootMonitorTask+0x30>
        RCC->APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8007ee6:	4a10      	ldr	r2, [pc, #64]	; (8007f28 <sanityRebootMonitorTask+0x5c>)
 8007ee8:	69d3      	ldr	r3, [r2, #28]
 8007eea:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8007eee:	61d3      	str	r3, [r2, #28]
        BKP->DR10 = 0x424D;
 8007ef0:	f244 224d 	movw	r2, #16973	; 0x424d
 8007ef4:	4b0d      	ldr	r3, [pc, #52]	; (8007f2c <sanityRebootMonitorTask+0x60>)
 8007ef6:	629a      	str	r2, [r3, #40]	; 0x28
        NVIC_SystemReset();
 8007ef8:	f7fc f99a 	bl	8004230 <NVIC_SystemReset.lto_priv.0>
 */
void wdgReset(WDGDriver *wdgp) {

  osalDbgCheck(wdgp != NULL);

  osalSysLock();
 8007efc:	f7fc fd52 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 8007f00:	4b0b      	ldr	r3, [pc, #44]	; (8007f30 <sanityRebootMonitorTask+0x64>)
 8007f02:	781a      	ldrb	r2, [r3, #0]
 8007f04:	2a02      	cmp	r2, #2
 8007f06:	d002      	beq.n	8007f0e <sanityRebootMonitorTask+0x42>
 8007f08:	f7fc fd5c 	bl	80049c4 <vTaskEndScheduler>
 8007f0c:	e7fe      	b.n	8007f0c <sanityRebootMonitorTask+0x40>
 *
 * @notapi
 */
void wdg_lld_reset(WDGDriver * wdgp) {

  wdgp->wdg->KR = KR_KEY_RELOAD;
 8007f0e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8007f12:	689b      	ldr	r3, [r3, #8]
}
 8007f14:	2001      	movs	r0, #1
 8007f16:	601a      	str	r2, [r3, #0]
  wdgResetI(wdgp);
  osalSysUnlock();
 8007f18:	f7fc ff68 	bl	8004dec <osalSysUnlock.lto_priv.0>
 8007f1c:	bd08      	pop	{r3, pc}
 8007f1e:	bf00      	nop
 8007f20:	20000858 	.word	0x20000858
 8007f24:	20001648 	.word	0x20001648
 8007f28:	40021000 	.word	0x40021000
 8007f2c:	40006c00 	.word	0x40006c00
 8007f30:	20000fdc 	.word	0x20000fdc

08007f34 <i2cSafeRawUnclogBus>:
{
 8007f34:	b570      	push	{r4, r5, r6, lr}
 8007f36:	4605      	mov	r5, r0
    gpioSetPin(config->sclPin, level);
 8007f38:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8007f3a:	2101      	movs	r1, #1
 8007f3c:	8998      	ldrh	r0, [r3, #12]
 8007f3e:	f7ff fb15 	bl	800756c <gpioSetPin.isra.0>
    gpioSetPin(config->sdaPin, level);
 8007f42:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007f44:	2101      	movs	r1, #1
 8007f46:	89d8      	ldrh	r0, [r3, #14]
 8007f48:	f7ff fb10 	bl	800756c <gpioSetPin.isra.0>
    i2cSafeConfig* config = (i2cSafeConfig*)i2c->i2cSafeConfig;
 8007f4c:	6fec      	ldr	r4, [r5, #124]	; 0x7c
    gpioSetPinMode(config->sdaPin, PAL_MODE_OUTPUT_OPENDRAIN);
 8007f4e:	2107      	movs	r1, #7
 8007f50:	89e0      	ldrh	r0, [r4, #14]
 8007f52:	f7ff f9df 	bl	8007314 <gpioSetPinMode.isra.0>
    gpioSetPinMode(config->sclPin, PAL_MODE_OUTPUT_OPENDRAIN);
 8007f56:	2107      	movs	r1, #7
 8007f58:	89a0      	ldrh	r0, [r4, #12]
 8007f5a:	f7ff f9db 	bl	8007314 <gpioSetPinMode.isra.0>
  osalSysLock();
 8007f5e:	f7fc fd21 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8007f62:	782b      	ldrb	r3, [r5, #0]
 8007f64:	1e5a      	subs	r2, r3, #1
 8007f66:	2a01      	cmp	r2, #1
 8007f68:	d904      	bls.n	8007f74 <i2cSafeRawUnclogBus+0x40>
 8007f6a:	2b05      	cmp	r3, #5
 8007f6c:	d004      	beq.n	8007f78 <i2cSafeRawUnclogBus+0x44>
 8007f6e:	f7fc fd29 	bl	80049c4 <vTaskEndScheduler>
 8007f72:	e7fe      	b.n	8007f72 <i2cSafeRawUnclogBus+0x3e>
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8007f74:	2b01      	cmp	r3, #1
 8007f76:	d036      	beq.n	8007fe6 <i2cSafeRawUnclogBus+0xb2>
  dp->CR1 = I2C_CR1_SWRST;
 8007f78:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  dp->CR1 = 0;
 8007f7c:	2400      	movs	r4, #0
  I2C_TypeDef *dp = i2cp->i2c;
 8007f7e:	6fab      	ldr	r3, [r5, #120]	; 0x78
  dmaStreamDisable(i2cp->dmatx);
 8007f80:	6f68      	ldr	r0, [r5, #116]	; 0x74
  dp->CR1 = I2C_CR1_SWRST;
 8007f82:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmatx);
 8007f84:	6842      	ldr	r2, [r0, #4]
  dp->CR1 = 0;
 8007f86:	601c      	str	r4, [r3, #0]
  dp->CR2 = 0;
 8007f88:	605c      	str	r4, [r3, #4]
  dp->SR1 = 0;
 8007f8a:	615c      	str	r4, [r3, #20]
  dmaStreamDisable(i2cp->dmatx);
 8007f8c:	6813      	ldr	r3, [r2, #0]
 8007f8e:	6801      	ldr	r1, [r0, #0]
 8007f90:	f023 030f 	bic.w	r3, r3, #15
 8007f94:	6013      	str	r3, [r2, #0]
 8007f96:	230e      	movs	r3, #14
 8007f98:	7c02      	ldrb	r2, [r0, #16]
 8007f9a:	fa03 f202 	lsl.w	r2, r3, r2
 8007f9e:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(i2cp->dmarx);
 8007fa0:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8007fa2:	6856      	ldr	r6, [r2, #4]
 8007fa4:	6831      	ldr	r1, [r6, #0]
 8007fa6:	f021 010f 	bic.w	r1, r1, #15
 8007faa:	6031      	str	r1, [r6, #0]
 8007fac:	6811      	ldr	r1, [r2, #0]
 8007fae:	7c12      	ldrb	r2, [r2, #16]
 8007fb0:	4093      	lsls	r3, r2
 8007fb2:	604b      	str	r3, [r1, #4]

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 8007fb4:	f7fc fe2e 	bl	8004c14 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 8007fb8:	6f28      	ldr	r0, [r5, #112]	; 0x70
 8007fba:	f7fc fe2b 	bl	8004c14 <dmaStreamRelease>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8007fbe:	4b3a      	ldr	r3, [pc, #232]	; (80080a8 <i2cSafeRawUnclogBus+0x174>)
 8007fc0:	429d      	cmp	r5, r3
 8007fc2:	d110      	bne.n	8007fe6 <i2cSafeRawUnclogBus+0xb2>
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8007fc4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8007fc8:	4b38      	ldr	r3, [pc, #224]	; (80080ac <i2cSafeRawUnclogBus+0x178>)
 8007fca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8007fce:	2201      	movs	r2, #1
  NVIC->IP[n] = 0U;
 8007fd0:	f883 431f 	strb.w	r4, [r3, #799]	; 0x31f
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8007fd4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      nvicDisableVector(I2C1_EV_IRQn);
      nvicDisableVector(I2C1_ER_IRQn);
      rccDisableI2C1(FALSE);
 8007fd8:	4a35      	ldr	r2, [pc, #212]	; (80080b0 <i2cSafeRawUnclogBus+0x17c>)
  NVIC->IP[n] = 0U;
 8007fda:	f883 4320 	strb.w	r4, [r3, #800]	; 0x320
 8007fde:	69d3      	ldr	r3, [r2, #28]
 8007fe0:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8007fe4:	61d3      	str	r3, [r2, #28]
  i2cp->config = NULL;
 8007fe6:	2300      	movs	r3, #0
 8007fe8:	606b      	str	r3, [r5, #4]
  i2cp->state  = I2C_STOP;
 8007fea:	2301      	movs	r3, #1
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 8007fec:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8007ff0:	702b      	strb	r3, [r5, #0]
  osalSysUnlock();
 8007ff2:	f7fc fefb 	bl	8004dec <osalSysUnlock.lto_priv.0>
 8007ff6:	f7fd ffaf 	bl	8005f58 <vPortBusyDelay>
    i2cSafeDataGoHigh(i2c);
 8007ffa:	4628      	mov	r0, r5
 8007ffc:	f7ff fb9e 	bl	800773c <i2cSafeDataGoHigh>
 8008000:	2648      	movs	r6, #72	; 0x48
        if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008002:	4628      	mov	r0, r5
 8008004:	f7ff fb6a 	bl	80076dc <i2cSafeClockGoHigh>
 8008008:	4604      	mov	r4, r0
 800800a:	2800      	cmp	r0, #0
 800800c:	d142      	bne.n	8008094 <i2cSafeRawUnclogBus+0x160>
        if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;
 800800e:	4628      	mov	r0, r5
 8008010:	f7ff fb80 	bl	8007714 <i2cSafeClockGoLow>
 8008014:	4604      	mov	r4, r0
 8008016:	2800      	cmp	r0, #0
 8008018:	d13c      	bne.n	8008094 <i2cSafeRawUnclogBus+0x160>
    for(i=0; i<clocks; i++) {
 800801a:	3e01      	subs	r6, #1
 800801c:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8008020:	d1ef      	bne.n	8008002 <i2cSafeRawUnclogBus+0xce>
    if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008022:	4628      	mov	r0, r5
 8008024:	f7ff fb5a 	bl	80076dc <i2cSafeClockGoHigh>
 8008028:	4604      	mov	r4, r0
 800802a:	bb98      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    return gpioGetPin(config->sdaPin);
 800802c:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800802e:	89d8      	ldrh	r0, [r3, #14]
 8008030:	f7fc f9d0 	bl	80043d4 <gpioGetPin>
    if(!i2cSafeRawGetData(i2c)){
 8008034:	b398      	cbz	r0, 800809e <i2cSafeRawUnclogBus+0x16a>
    if((retVal = i2cSafeDataGoLow(i2c)) != I2C_BUS_OK) goto done;        
 8008036:	4628      	mov	r0, r5
 8008038:	f7ff fb94 	bl	8007764 <i2cSafeDataGoLow>
 800803c:	4604      	mov	r4, r0
 800803e:	bb48      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;        
 8008040:	4628      	mov	r0, r5
 8008042:	f7ff fb67 	bl	8007714 <i2cSafeClockGoLow>
 8008046:	4604      	mov	r4, r0
 8008048:	bb20      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    i2cSafeDataGoHigh(i2c);
 800804a:	4628      	mov	r0, r5
 800804c:	f7ff fb76 	bl	800773c <i2cSafeDataGoHigh>
 8008050:	2609      	movs	r6, #9
        if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008052:	4628      	mov	r0, r5
 8008054:	f7ff fb42 	bl	80076dc <i2cSafeClockGoHigh>
 8008058:	4604      	mov	r4, r0
 800805a:	b9d8      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
        if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;
 800805c:	4628      	mov	r0, r5
 800805e:	f7ff fb59 	bl	8007714 <i2cSafeClockGoLow>
 8008062:	4604      	mov	r4, r0
 8008064:	b9b0      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    return gpioGetPin(config->sdaPin);
 8008066:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8008068:	89d8      	ldrh	r0, [r3, #14]
 800806a:	f7fc f9b3 	bl	80043d4 <gpioGetPin>
        if(checkData && !i2cSafeRawGetData(i2c)){
 800806e:	b1c0      	cbz	r0, 80080a2 <i2cSafeRawUnclogBus+0x16e>
    for(i=0; i<clocks; i++) {
 8008070:	3e01      	subs	r6, #1
 8008072:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8008076:	d1ec      	bne.n	8008052 <i2cSafeRawUnclogBus+0x11e>
    if((retVal = i2cSafeDataGoLow(i2c)) != I2C_BUS_OK) goto done;        
 8008078:	4628      	mov	r0, r5
 800807a:	f7ff fb73 	bl	8007764 <i2cSafeDataGoLow>
 800807e:	4604      	mov	r4, r0
 8008080:	b940      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008082:	4628      	mov	r0, r5
 8008084:	f7ff fb2a 	bl	80076dc <i2cSafeClockGoHigh>
 8008088:	4604      	mov	r4, r0
 800808a:	b918      	cbnz	r0, 8008094 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeDataGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 800808c:	4628      	mov	r0, r5
 800808e:	f7ff fb55 	bl	800773c <i2cSafeDataGoHigh>
 8008092:	4604      	mov	r4, r0
    i2cSafeRawHardwareControl(i2c);
 8008094:	4628      	mov	r0, r5
 8008096:	f7ff f961 	bl	800735c <i2cSafeRawHardwareControl>
}
 800809a:	4620      	mov	r0, r4
 800809c:	bd70      	pop	{r4, r5, r6, pc}
        retVal = I2C_BUS_STUCK_SDA_PULLED_LOW;
 800809e:	2402      	movs	r4, #2
 80080a0:	e7f8      	b.n	8008094 <i2cSafeRawUnclogBus+0x160>
            return I2C_BUS_STUCK_SHORTED_TOGETHER;
 80080a2:	2405      	movs	r4, #5
 80080a4:	e7f6      	b.n	8008094 <i2cSafeRawUnclogBus+0x160>
 80080a6:	bf00      	nop
 80080a8:	20000934 	.word	0x20000934
 80080ac:	e000e100 	.word	0xe000e100
 80080b0:	40021000 	.word	0x40021000

080080b4 <max2870SpiState.constprop.0>:
static void max2870SetMUXOut(MAX2870Driver* driver, uint8_t muxOut);

static void max2870SpiState(MAX2870Driver* driver, bool enable)
{
    if(enable) {
        spiAcquireBus(driver->config->spiPort);
 80080b4:	6803      	ldr	r3, [r0, #0]
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 80080b6:	b510      	push	{r4, lr}
        spiAcquireBus(driver->config->spiPort);
 80080b8:	681b      	ldr	r3, [r3, #0]
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 80080ba:	4604      	mov	r4, r0
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 80080bc:	b913      	cbnz	r3, 80080c4 <max2870SpiState.constprop.0+0x10>
 80080be:	f7fc fc81 	bl	80049c4 <vTaskEndScheduler>
 80080c2:	e7fe      	b.n	80080c2 <max2870SpiState.constprop.0+0xe>
    xSemaphoreTake(mutex->handle, portMAX_DELAY);
 80080c4:	68d8      	ldr	r0, [r3, #12]
 80080c6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80080ca:	f7fd f9b9 	bl	8005440 <xQueueSemaphoreTake>
        spiStart(driver->config->spiPort, driver->config->spiConfig);
 80080ce:	6823      	ldr	r3, [r4, #0]
 80080d0:	681c      	ldr	r4, [r3, #0]
  osalDbgCheck((spip != NULL) && (config != NULL));
 80080d2:	b10c      	cbz	r4, 80080d8 <max2870SpiState.constprop.0+0x24>
 80080d4:	6858      	ldr	r0, [r3, #4]
 80080d6:	b910      	cbnz	r0, 80080de <max2870SpiState.constprop.0+0x2a>
 80080d8:	f7fc fc74 	bl	80049c4 <vTaskEndScheduler>
 80080dc:	e7fe      	b.n	80080dc <max2870SpiState.constprop.0+0x28>
  osalSysLock();
 80080de:	f7fc fc61 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 80080e2:	7823      	ldrb	r3, [r4, #0]
 80080e4:	1e5a      	subs	r2, r3, #1
 80080e6:	2a01      	cmp	r2, #1
 80080e8:	d902      	bls.n	80080f0 <max2870SpiState.constprop.0+0x3c>
 80080ea:	f7fc fc6b 	bl	80049c4 <vTaskEndScheduler>
 80080ee:	e7fe      	b.n	80080ee <max2870SpiState.constprop.0+0x3a>
  if (spip->state == SPI_STOP) {
 80080f0:	2b01      	cmp	r3, #1
  spip->config = config;
 80080f2:	6060      	str	r0, [r4, #4]
 80080f4:	d121      	bne.n	800813a <max2870SpiState.constprop.0+0x86>
    if (&SPID1 == spip) {
 80080f6:	4b25      	ldr	r3, [pc, #148]	; (800818c <max2870SpiState.constprop.0+0xd8>)
 80080f8:	429c      	cmp	r4, r3
 80080fa:	d116      	bne.n	800812a <max2870SpiState.constprop.0+0x76>
      b = dmaStreamAllocate(spip->dmarx,
 80080fc:	4622      	mov	r2, r4
 80080fe:	4924      	ldr	r1, [pc, #144]	; (8008190 <max2870SpiState.constprop.0+0xdc>)
 8008100:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8008102:	f7fe f9a3 	bl	800644c <dmaStreamAllocate.constprop.0>
      osalDbgAssert(!b, "stream already allocated");
 8008106:	b110      	cbz	r0, 800810e <max2870SpiState.constprop.0+0x5a>
 8008108:	f7fc fc5c 	bl	80049c4 <vTaskEndScheduler>
 800810c:	e7fe      	b.n	800810c <max2870SpiState.constprop.0+0x58>
      b = dmaStreamAllocate(spip->dmatx,
 800810e:	4622      	mov	r2, r4
 8008110:	4920      	ldr	r1, [pc, #128]	; (8008194 <max2870SpiState.constprop.0+0xe0>)
 8008112:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8008114:	f7fe f99a 	bl	800644c <dmaStreamAllocate.constprop.0>
      osalDbgAssert(!b, "stream already allocated");
 8008118:	b110      	cbz	r0, 8008120 <max2870SpiState.constprop.0+0x6c>
 800811a:	f7fc fc53 	bl	80049c4 <vTaskEndScheduler>
 800811e:	e7fe      	b.n	800811e <max2870SpiState.constprop.0+0x6a>
      rccEnableSPI1(FALSE);
 8008120:	4a1d      	ldr	r2, [pc, #116]	; (8008198 <max2870SpiState.constprop.0+0xe4>)
 8008122:	6993      	ldr	r3, [r2, #24]
 8008124:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8008128:	6193      	str	r3, [r2, #24]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800812a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800812c:	685a      	ldr	r2, [r3, #4]
 800812e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008130:	330c      	adds	r3, #12
 8008132:	6093      	str	r3, [r2, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8008134:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8008136:	6852      	ldr	r2, [r2, #4]
 8008138:	6093      	str	r3, [r2, #8]
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800813a:	6860      	ldr	r0, [r4, #4]
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800813c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800813e:	8941      	ldrh	r1, [r0, #10]
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8008140:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8008144:	f411 6f00 	tst.w	r1, #2048	; 0x800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8008148:	bf16      	itet	ne
 800814a:	f442 62a0 	orrne.w	r2, r2, #1280	; 0x500
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800814e:	66e2      	streq	r2, [r4, #108]	; 0x6c
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8008150:	66e2      	strne	r2, [r4, #108]	; 0x6c
  spip->spi->CR1  = 0;
 8008152:	f04f 0200 	mov.w	r2, #0
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8008156:	6f23      	ldr	r3, [r4, #112]	; 0x70
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 8008158:	f441 7141 	orr.w	r1, r1, #772	; 0x304
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800815c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8008160:	bf18      	it	ne
 8008162:	f443 63a0 	orrne.w	r3, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8008166:	6723      	str	r3, [r4, #112]	; 0x70
  spip->spi->CR1  = 0;
 8008168:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800816a:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800816c:	8982      	ldrh	r2, [r0, #12]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800816e:	6019      	str	r1, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 8008170:	f042 0207 	orr.w	r2, r2, #7
 8008174:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 8008176:	681a      	ldr	r2, [r3, #0]
 8008178:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800817c:	601a      	str	r2, [r3, #0]
  spip->state = SPI_READY;
 800817e:	2302      	movs	r3, #2
 8008180:	7023      	strb	r3, [r4, #0]
        /* Update monitor state */
        monitorKick(&driver->pllMon, driver->enabled);

        spiReleaseBus(driver->config->spiPort);
    }
}
 8008182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlock();
 8008186:	f7fc be31 	b.w	8004dec <osalSysUnlock.lto_priv.0>
 800818a:	bf00      	nop
 800818c:	20000ee0 	.word	0x20000ee0
 8008190:	0800729d 	.word	0x0800729d
 8008194:	08004cb7 	.word	0x08004cb7
 8008198:	40021000 	.word	0x40021000

0800819c <spiUnselect.constprop.0>:
void spiUnselect(SPIDriver *spip) {
 800819c:	b508      	push	{r3, lr}
  osalSysLock();
 800819e:	f7fc fc01 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80081a2:	4b08      	ldr	r3, [pc, #32]	; (80081c4 <spiUnselect.constprop.0+0x28>)
 80081a4:	781a      	ldrb	r2, [r3, #0]
 80081a6:	2a02      	cmp	r2, #2
 80081a8:	d002      	beq.n	80081b0 <spiUnselect.constprop.0+0x14>
 80081aa:	f7fc fc0b 	bl	80049c4 <vTaskEndScheduler>
 80081ae:	e7fe      	b.n	80081ae <spiUnselect.constprop.0+0x12>
  palSetPad(spip->config->ssport, spip->config->sspad);
 80081b0:	685b      	ldr	r3, [r3, #4]
 80081b2:	8919      	ldrh	r1, [r3, #8]
 80081b4:	685a      	ldr	r2, [r3, #4]
 80081b6:	2301      	movs	r3, #1
 80081b8:	408b      	lsls	r3, r1
 80081ba:	6113      	str	r3, [r2, #16]
}
 80081bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osalSysUnlock();
 80081c0:	f7fc be14 	b.w	8004dec <osalSysUnlock.lto_priv.0>
 80081c4:	20000ee0 	.word	0x20000ee0

080081c8 <spiSelect.constprop.0>:
void spiSelect(SPIDriver *spip) {
 80081c8:	b508      	push	{r3, lr}
  osalSysLock();
 80081ca:	f7fc fbeb 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80081ce:	4b08      	ldr	r3, [pc, #32]	; (80081f0 <spiSelect.constprop.0+0x28>)
 80081d0:	781a      	ldrb	r2, [r3, #0]
 80081d2:	2a02      	cmp	r2, #2
 80081d4:	d002      	beq.n	80081dc <spiSelect.constprop.0+0x14>
 80081d6:	f7fc fbf5 	bl	80049c4 <vTaskEndScheduler>
 80081da:	e7fe      	b.n	80081da <spiSelect.constprop.0+0x12>
  palClearPad(spip->config->ssport, spip->config->sspad);
 80081dc:	685b      	ldr	r3, [r3, #4]
 80081de:	8919      	ldrh	r1, [r3, #8]
 80081e0:	685a      	ldr	r2, [r3, #4]
 80081e2:	2301      	movs	r3, #1
 80081e4:	408b      	lsls	r3, r1
 80081e6:	6153      	str	r3, [r2, #20]
}
 80081e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osalSysUnlock();
 80081ec:	f7fc bdfe 	b.w	8004dec <osalSysUnlock.lto_priv.0>
 80081f0:	20000ee0 	.word	0x20000ee0

080081f4 <spiSend.part.0.constprop.0>:
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80081f4:	b510      	push	{r4, lr}
  osalSysLock();
 80081f6:	f7fc fbd5 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80081fa:	4b18      	ldr	r3, [pc, #96]	; (800825c <spiSend.part.0.constprop.0+0x68>)
 80081fc:	781a      	ldrb	r2, [r3, #0]
 80081fe:	2a02      	cmp	r2, #2
 8008200:	d002      	beq.n	8008208 <spiSend.part.0.constprop.0+0x14>
 8008202:	f7fc fbdf 	bl	80049c4 <vTaskEndScheduler>
 8008206:	e7fe      	b.n	8008206 <spiSend.part.0.constprop.0+0x12>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8008208:	685a      	ldr	r2, [r3, #4]
 800820a:	6812      	ldr	r2, [r2, #0]
 800820c:	b112      	cbz	r2, 8008214 <spiSend.part.0.constprop.0+0x20>
 800820e:	f7fc fbd9 	bl	80049c4 <vTaskEndScheduler>
 8008212:	e7fe      	b.n	8008212 <spiSend.part.0.constprop.0+0x1e>
  spiStartSendI(spip, n, txbuf);
 8008214:	2203      	movs	r2, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8008216:	2404      	movs	r4, #4
 8008218:	701a      	strb	r2, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800821a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800821c:	6851      	ldr	r1, [r2, #4]
 800821e:	4a10      	ldr	r2, [pc, #64]	; (8008260 <spiSend.part.0.constprop.0+0x6c>)
 8008220:	60ca      	str	r2, [r1, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8008222:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8008224:	604c      	str	r4, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8008226:	600a      	str	r2, [r1, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8008228:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800822a:	6852      	ldr	r2, [r2, #4]
 800822c:	60d0      	str	r0, [r2, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800822e:	6f18      	ldr	r0, [r3, #112]	; 0x70
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8008230:	6054      	str	r4, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8008232:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8008236:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(spip->dmarx);
 8008238:	6808      	ldr	r0, [r1, #0]
 800823a:	f040 0001 	orr.w	r0, r0, #1
 800823e:	6008      	str	r0, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 8008240:	6811      	ldr	r1, [r2, #0]
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
 8008242:	f103 0008 	add.w	r0, r3, #8
 8008246:	f041 0101 	orr.w	r1, r1, #1
 800824a:	6011      	str	r1, [r2, #0]
 800824c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008250:	f7fe f9bc 	bl	80065cc <osalThreadSuspendTimeoutS>
}
 8008254:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlock();
 8008258:	f7fc bdc8 	b.w	8004dec <osalSysUnlock.lto_priv.0>
 800825c:	20000ee0 	.word	0x20000ee0
 8008260:	20001048 	.word	0x20001048

08008264 <max2870WriteRegister>:

static bool max2870WriteRegister(MAX2870Driver* driver, const uint32_t addr, uint32_t value, bool force)
{
 8008264:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008266:	4604      	mov	r4, r0
 8008268:	4618      	mov	r0, r3
    osalDbgCheck(addr < 0x6);
    osalDbgCheck((value & 0x7) == 0);
 800826a:	0753      	lsls	r3, r2, #29
 800826c:	d002      	beq.n	8008274 <max2870WriteRegister+0x10>
 800826e:	f7fc fba9 	bl	80049c4 <vTaskEndScheduler>
 8008272:	e7fe      	b.n	8008272 <max2870WriteRegister+0xe>

    if(!force && driver->registers[addr] == value) {
 8008274:	f101 0332 	add.w	r3, r1, #50	; 0x32
 8008278:	b918      	cbnz	r0, 8008282 <max2870WriteRegister+0x1e>
 800827a:	f854 5023 	ldr.w	r5, [r4, r3, lsl #2]
 800827e:	42aa      	cmp	r2, r5
 8008280:	d018      	beq.n	80082b4 <max2870WriteRegister+0x50>
        return false;
    }
    driver->registers[addr] = value;
 8008282:	f844 2023 	str.w	r2, [r4, r3, lsl #2]

    value |= addr;
 8008286:	430a      	orrs	r2, r1

    uint8_t data[4] = {value>>24, (value >> 16) & 0xFF, (value >> 8) & 0xFF,  (value >> 0) & 0xFF};
 8008288:	0e13      	lsrs	r3, r2, #24
 800828a:	f88d 3004 	strb.w	r3, [sp, #4]
 800828e:	0c13      	lsrs	r3, r2, #16
 8008290:	f88d 3005 	strb.w	r3, [sp, #5]
 8008294:	a801      	add	r0, sp, #4
 8008296:	0a13      	lsrs	r3, r2, #8
 8008298:	f88d 3006 	strb.w	r3, [sp, #6]
 800829c:	f88d 2007 	strb.w	r2, [sp, #7]


    spiSelect(&SPID1);
 80082a0:	f7ff ff92 	bl	80081c8 <spiSelect.constprop.0>
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 80082a4:	f7ff ffa6 	bl	80081f4 <spiSend.part.0.constprop.0>
    }
}

static inline void osalSysPolledDelayX(rtcnt_t cycles)
{
    vPortBusyDelay(cycles);
 80082a8:	2032      	movs	r0, #50	; 0x32
    spiSend(&SPID1, 4, data);
    spiUnselect(&SPID1);
 80082aa:	f7ff ff77 	bl	800819c <spiUnselect.constprop.0>
 80082ae:	f7fd fe53 	bl	8005f58 <vPortBusyDelay>
    osalSysPolledDelayX(50);


    return true;
 80082b2:	2001      	movs	r0, #1
}
 80082b4:	b003      	add	sp, #12
 80082b6:	bd30      	pop	{r4, r5, pc}

080082b8 <max2870SetMUXOut>:

    return true;
}

static void max2870SetMUXOut(MAX2870Driver* driver, uint8_t muxOut)
{
 80082b8:	b570      	push	{r4, r5, r6, lr}
    uint32_t register2 = driver->registers[2] & ~ (0x7 <<  MAX2870_REG2_MUX_OFFSET);
 80082ba:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
    register2 |= (muxOut & 0x7) << MAX2870_REG2_MUX_OFFSET;
    uint32_t register5 = driver->registers[5] & ~ _BV(MAX2870_REG5_MUX_OFFSET);
 80082be:	f8d0 20dc 	ldr.w	r2, [r0, #220]	; 0xdc
    uint32_t register2 = driver->registers[2] & ~ (0x7 <<  MAX2870_REG2_MUX_OFFSET);
 80082c2:	f025 53e0 	bic.w	r3, r5, #469762048	; 0x1c000000
    register2 |= (muxOut & 0x7) << MAX2870_REG2_MUX_OFFSET;
 80082c6:	068d      	lsls	r5, r1, #26
 80082c8:	f005 55e0 	and.w	r5, r5, #469762048	; 0x1c000000
 80082cc:	431d      	orrs	r5, r3
    uint32_t register5 = driver->registers[5] & ~ _BV(MAX2870_REG5_MUX_OFFSET);
 80082ce:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    if(muxOut & 0x8) {
 80082d2:	070b      	lsls	r3, r1, #28
        register5 |= _BV(MAX2870_REG5_MUX_OFFSET);
 80082d4:	bf48      	it	mi
 80082d6:	f442 2280 	orrmi.w	r2, r2, #262144	; 0x40000
    }

    /* It seems reg 5 should be written before reg 2 to update the MUX value */
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 80082da:	2300      	movs	r3, #0
 80082dc:	2105      	movs	r1, #5
{
 80082de:	4604      	mov	r4, r0
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 80082e0:	f7ff ffc0 	bl	8008264 <max2870WriteRegister>
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 80082e4:	462a      	mov	r2, r5
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 80082e6:	4603      	mov	r3, r0
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 80082e8:	2102      	movs	r1, #2
 80082ea:	4620      	mov	r0, r4
}
 80082ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 80082f0:	f7ff bfb8 	b.w	8008264 <max2870WriteRegister>

080082f4 <max2870ReadRegister6>:

static uint32_t max2870ReadRegister6(MAX2870Driver* driver)
{
 80082f4:	b513      	push	{r0, r1, r4, lr}
    /* Step 1: Set MUX OUT to readback mode */
    max2870SetMUXOut(driver, 0xC);
 80082f6:	210c      	movs	r1, #12
{
 80082f8:	4604      	mov	r4, r0
    max2870SetMUXOut(driver, 0xC);
 80082fa:	f7ff ffdd 	bl	80082b8 <max2870SetMUXOut>

    /* Step 2: Ask to read the register */
    uint8_t data[5]= {0, 0, 0, 0x6};
 80082fe:	4b25      	ldr	r3, [pc, #148]	; (8008394 <max2870ReadRegister6+0xa0>)
 8008300:	6818      	ldr	r0, [r3, #0]
 8008302:	791b      	ldrb	r3, [r3, #4]
 8008304:	9000      	str	r0, [sp, #0]
 8008306:	4668      	mov	r0, sp
 8008308:	f88d 3004 	strb.w	r3, [sp, #4]
    spiSelect(&SPID1);
 800830c:	f7ff ff5c 	bl	80081c8 <spiSelect.constprop.0>
 8008310:	f7ff ff70 	bl	80081f4 <spiSend.part.0.constprop.0>
    spiSend(&SPID1, 4, data);
    spiUnselect(&SPID1);
 8008314:	f7ff ff42 	bl	800819c <spiUnselect.constprop.0>

    /* Step 3: Read in the data, note that the device should be unselected(!) */
    data[3] = 0;
 8008318:	2300      	movs	r3, #0
 800831a:	f88d 3003 	strb.w	r3, [sp, #3]
  osalSysLock();
 800831e:	f7fc fb41 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8008322:	4b1d      	ldr	r3, [pc, #116]	; (8008398 <max2870ReadRegister6+0xa4>)
 8008324:	781a      	ldrb	r2, [r3, #0]
 8008326:	2a02      	cmp	r2, #2
 8008328:	d002      	beq.n	8008330 <max2870ReadRegister6+0x3c>
 800832a:	f7fc fb4b 	bl	80049c4 <vTaskEndScheduler>
 800832e:	e7fe      	b.n	800832e <max2870ReadRegister6+0x3a>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8008330:	685a      	ldr	r2, [r3, #4]
 8008332:	6812      	ldr	r2, [r2, #0]
 8008334:	b112      	cbz	r2, 800833c <max2870ReadRegister6+0x48>
 8008336:	f7fc fb45 	bl	80049c4 <vTaskEndScheduler>
 800833a:	e7fe      	b.n	800833a <max2870ReadRegister6+0x46>
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 800833c:	2203      	movs	r2, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800833e:	2004      	movs	r0, #4
 8008340:	701a      	strb	r2, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8008342:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8008344:	6851      	ldr	r1, [r2, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8008346:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8008348:	f8c1 d00c 	str.w	sp, [r1, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 800834c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8008350:	6048      	str	r0, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8008352:	600a      	str	r2, [r1, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8008354:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8008356:	6852      	ldr	r2, [r2, #4]
 8008358:	f8c2 d00c 	str.w	sp, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800835c:	6050      	str	r0, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800835e:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8008360:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8008364:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(spip->dmarx);
 8008366:	6808      	ldr	r0, [r1, #0]
 8008368:	f040 0001 	orr.w	r0, r0, #1
 800836c:	6008      	str	r0, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 800836e:	6811      	ldr	r1, [r2, #0]
 8008370:	f103 0008 	add.w	r0, r3, #8
 8008374:	f041 0101 	orr.w	r1, r1, #1
 8008378:	6011      	str	r1, [r2, #0]
 800837a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800837e:	f7fe f925 	bl	80065cc <osalThreadSuspendTimeoutS>
  osalSysUnlock();
 8008382:	f7fc fd33 	bl	8004dec <osalSysUnlock.lto_priv.0>
    spiExchange(&SPID1, 4, data, data);

    driver->registers[6] = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
 8008386:	9800      	ldr	r0, [sp, #0]
 8008388:	ba00      	rev	r0, r0
 800838a:	f8c4 00e0 	str.w	r0, [r4, #224]	; 0xe0
    return driver->registers[6];
}
 800838e:	b002      	add	sp, #8
 8008390:	bd10      	pop	{r4, pc}
 8008392:	bf00      	nop
 8008394:	0800b9f4 	.word	0x0800b9f4
 8008398:	20000ee0 	.word	0x20000ee0

0800839c <max2870Disable>:

static void max2870Disable(MAX2870Driver* driver)
{
    if(driver->config->gpioChipEnable != 0xffff) {
 800839c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80083a0:	6803      	ldr	r3, [r0, #0]
{
 80083a2:	b510      	push	{r4, lr}
    if(driver->config->gpioChipEnable != 0xffff) {
 80083a4:	891b      	ldrh	r3, [r3, #8]
{
 80083a6:	4604      	mov	r4, r0
    if(driver->config->gpioChipEnable != 0xffff) {
 80083a8:	4293      	cmp	r3, r2
 80083aa:	d00b      	beq.n	80083c4 <max2870Disable+0x28>
        gpioSetPin(driver->config->gpioChipEnable, false);
 80083ac:	2100      	movs	r1, #0
 80083ae:	4618      	mov	r0, r3
 80083b0:	f7ff f8dc 	bl	800756c <gpioSetPin.isra.0>
    } else {
        max2870WriteRegister(driver, 2, _BV(MAX2870_REG2_SHDN_OFFSET), true);
    }

    if(driver->config->lockStatus) {
 80083b4:	6823      	ldr	r3, [r4, #0]
 80083b6:	69db      	ldr	r3, [r3, #28]
 80083b8:	b10b      	cbz	r3, 80083be <max2870Disable+0x22>
        driver->config->lockStatus(false);
 80083ba:	2000      	movs	r0, #0
 80083bc:	4798      	blx	r3
    }
    driver->enabled = false;
 80083be:	2300      	movs	r3, #0
 80083c0:	7123      	strb	r3, [r4, #4]
}
 80083c2:	bd10      	pop	{r4, pc}
        max2870WriteRegister(driver, 2, _BV(MAX2870_REG2_SHDN_OFFSET), true);
 80083c4:	2301      	movs	r3, #1
 80083c6:	2220      	movs	r2, #32
 80083c8:	2102      	movs	r1, #2
 80083ca:	f7ff ff4b 	bl	8008264 <max2870WriteRegister>
 80083ce:	e7f1      	b.n	80083b4 <max2870Disable+0x18>

080083d0 <max2870WriteAllRegisters.isra.0>:
static bool max2870WriteAllRegisters(MAX2870Driver* driver, uint32_t* registers, bool force)
 80083d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80083d4:	4606      	mov	r6, r0
 80083d6:	460f      	mov	r7, r1
 80083d8:	4690      	mov	r8, r2
    bool anyChanged = false;
 80083da:	2500      	movs	r5, #0
    for(int i = 5; i>=0; i--) {
 80083dc:	2405      	movs	r4, #5
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 80083de:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
 80083e2:	f1b8 0f00 	cmp.w	r8, #0
 80083e6:	d110      	bne.n	800840a <max2870WriteAllRegisters.isra.0+0x3a>
 80083e8:	2c00      	cmp	r4, #0
 80083ea:	bf0c      	ite	eq
 80083ec:	462b      	moveq	r3, r5
 80083ee:	2300      	movne	r3, #0
 80083f0:	4621      	mov	r1, r4
 80083f2:	4630      	mov	r0, r6
 80083f4:	f003 0301 	and.w	r3, r3, #1
 80083f8:	f7ff ff34 	bl	8008264 <max2870WriteRegister>
    for(int i = 5; i>=0; i--) {
 80083fc:	3c01      	subs	r4, #1
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 80083fe:	ea45 0500 	orr.w	r5, r5, r0
 8008402:	b2ed      	uxtb	r5, r5
    for(int i = 5; i>=0; i--) {
 8008404:	d2eb      	bcs.n	80083de <max2870WriteAllRegisters.isra.0+0xe>
}
 8008406:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 800840a:	2301      	movs	r3, #1
 800840c:	e7f0      	b.n	80083f0 <max2870WriteAllRegisters.isra.0+0x20>
	...

08008410 <xQueueGenericSend.constprop.0>:
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
 8008410:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8008414:	2300      	movs	r3, #0
	configASSERT( pxQueue );
 8008416:	4604      	mov	r4, r0
 8008418:	9301      	str	r3, [sp, #4]
 800841a:	b900      	cbnz	r0, 800841e <xQueueGenericSend.constprop.0+0xe>
 800841c:	e7fe      	b.n	800841c <xQueueGenericSend.constprop.0+0xc>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800841e:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8008420:	b105      	cbz	r5, 8008424 <xQueueGenericSend.constprop.0+0x14>
 8008422:	e7fe      	b.n	8008422 <xQueueGenericSend.constprop.0+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8008424:	4e7e      	ldr	r6, [pc, #504]	; (8008620 <xQueueGenericSend.constprop.0+0x210>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 8008426:	4f7f      	ldr	r7, [pc, #508]	; (8008624 <xQueueGenericSend.constprop.0+0x214>)
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8008428:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 8008628 <xQueueGenericSend.constprop.0+0x218>
 800842c:	e0bb      	b.n	80085a6 <xQueueGenericSend.constprop.0+0x196>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 800842e:	6865      	ldr	r5, [r4, #4]
		if( pxMutexHolder != NULL )
 8008430:	bb5d      	cbnz	r5, 800848a <xQueueGenericSend.constprop.0+0x7a>
	BaseType_t xReturn = pdFALSE;
 8008432:	2500      	movs	r5, #0
				pxQueue->pxMutexHolder = NULL;
 8008434:	2200      	movs	r2, #0
 8008436:	6062      	str	r2, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8008438:	3601      	adds	r6, #1
 800843a:	63a6      	str	r6, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800843c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800843e:	2a00      	cmp	r2, #0
 8008440:	d068      	beq.n	8008514 <xQueueGenericSend.constprop.0+0x104>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008442:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8008446:	f7fc fa03 	bl	8004850 <xTaskRemoveFromEventList>
 800844a:	2800      	cmp	r0, #0
 800844c:	d064      	beq.n	8008518 <xQueueGenericSend.constprop.0+0x108>
						queueYIELD_IF_USING_PREEMPTION();
 800844e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8008452:	4a76      	ldr	r2, [pc, #472]	; (800862c <xQueueGenericSend.constprop.0+0x21c>)
 8008454:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8008458:	6011      	str	r1, [r2, #0]
 800845a:	4a75      	ldr	r2, [pc, #468]	; (8008630 <xQueueGenericSend.constprop.0+0x220>)
 800845c:	6812      	ldr	r2, [r2, #0]
 800845e:	b14a      	cbz	r2, 8008474 <xQueueGenericSend.constprop.0+0x64>
 8008460:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8008464:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8008468:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800846c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8008470:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8008474:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8008478:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800847c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8008480:	f3bf 8f4f 	dsb	sy
 8008484:	f3bf 8f6f 	isb	sy
 8008488:	e046      	b.n	8008518 <xQueueGenericSend.constprop.0+0x108>
			configASSERT( pxTCB == pxCurrentTCB );
 800848a:	4b67      	ldr	r3, [pc, #412]	; (8008628 <xQueueGenericSend.constprop.0+0x218>)
 800848c:	681b      	ldr	r3, [r3, #0]
 800848e:	429d      	cmp	r5, r3
 8008490:	d000      	beq.n	8008494 <xQueueGenericSend.constprop.0+0x84>
 8008492:	e7fe      	b.n	8008492 <xQueueGenericSend.constprop.0+0x82>
			configASSERT( pxTCB->uxMutexesHeld );
 8008494:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8008496:	b903      	cbnz	r3, 800849a <xQueueGenericSend.constprop.0+0x8a>
 8008498:	e7fe      	b.n	8008498 <xQueueGenericSend.constprop.0+0x88>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800849a:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 800849c:	6cea      	ldr	r2, [r5, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 800849e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80084a0:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 80084a2:	652b      	str	r3, [r5, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80084a4:	d0c5      	beq.n	8008432 <xQueueGenericSend.constprop.0+0x22>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80084a6:	2b00      	cmp	r3, #0
 80084a8:	d1c3      	bne.n	8008432 <xQueueGenericSend.constprop.0+0x22>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80084aa:	f105 0804 	add.w	r8, r5, #4
 80084ae:	4640      	mov	r0, r8
 80084b0:	f7fc f8fb 	bl	80046aa <uxListRemove>
 80084b4:	f8df c17c 	ldr.w	ip, [pc, #380]	; 8008634 <xQueueGenericSend.constprop.0+0x224>
 80084b8:	4a5f      	ldr	r2, [pc, #380]	; (8008638 <xQueueGenericSend.constprop.0+0x228>)
 80084ba:	b958      	cbnz	r0, 80084d4 <xQueueGenericSend.constprop.0+0xc4>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80084bc:	2014      	movs	r0, #20
 80084be:	6aef      	ldr	r7, [r5, #44]	; 0x2c
 80084c0:	4378      	muls	r0, r7
 80084c2:	f85c 3000 	ldr.w	r3, [ip, r0]
 80084c6:	b92b      	cbnz	r3, 80084d4 <xQueueGenericSend.constprop.0+0xc4>
 80084c8:	2101      	movs	r1, #1
 80084ca:	6813      	ldr	r3, [r2, #0]
 80084cc:	40b9      	lsls	r1, r7
 80084ce:	ea23 0301 	bic.w	r3, r3, r1
 80084d2:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80084d4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
					prvAddTaskToReadyList( pxTCB );
 80084d6:	2014      	movs	r0, #20
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80084d8:	f1c3 0105 	rsb	r1, r3, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80084dc:	62eb      	str	r3, [r5, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80084de:	61a9      	str	r1, [r5, #24]
					prvAddTaskToReadyList( pxTCB );
 80084e0:	2501      	movs	r5, #1
 80084e2:	6811      	ldr	r1, [r2, #0]
 80084e4:	fa05 f703 	lsl.w	r7, r5, r3
 80084e8:	430f      	orrs	r7, r1
 80084ea:	fb00 c003 	mla	r0, r0, r3, ip
 80084ee:	4641      	mov	r1, r8
 80084f0:	6017      	str	r7, [r2, #0]
 80084f2:	f7fc f8b7 	bl	8004664 <vListInsertEnd>
 80084f6:	e79d      	b.n	8008434 <xQueueGenericSend.constprop.0+0x24>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 80084f8:	2100      	movs	r1, #0
 80084fa:	68a0      	ldr	r0, [r4, #8]
 80084fc:	f7fb faea 	bl	8003ad4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8008500:	68a3      	ldr	r3, [r4, #8]
 8008502:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008504:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8008506:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8008508:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800850a:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800850c:	bf24      	itt	cs
 800850e:	6823      	ldrcs	r3, [r4, #0]
 8008510:	60a3      	strcs	r3, [r4, #8]
 8008512:	e056      	b.n	80085c2 <xQueueGenericSend.constprop.0+0x1b2>
					else if( xYieldRequired != pdFALSE )
 8008514:	2d00      	cmp	r5, #0
 8008516:	d19a      	bne.n	800844e <xQueueGenericSend.constprop.0+0x3e>
				taskEXIT_CRITICAL();
 8008518:	f7fc fc5c 	bl	8004dd4 <vPortExitCritical>
				return pdPASS;
 800851c:	2001      	movs	r0, #1
}
 800851e:	b004      	add	sp, #16
 8008520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 8008524:	9801      	ldr	r0, [sp, #4]
 8008526:	b910      	cbnz	r0, 800852e <xQueueGenericSend.constprop.0+0x11e>
					taskEXIT_CRITICAL();
 8008528:	f7fc fc54 	bl	8004dd4 <vPortExitCritical>
					return errQUEUE_FULL;
 800852c:	e7f7      	b.n	800851e <xQueueGenericSend.constprop.0+0x10e>
				else if( xEntryTimeSet == pdFALSE )
 800852e:	b91d      	cbnz	r5, 8008538 <xQueueGenericSend.constprop.0+0x128>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8008530:	6833      	ldr	r3, [r6, #0]
 8008532:	9302      	str	r3, [sp, #8]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8008534:	683b      	ldr	r3, [r7, #0]
 8008536:	9303      	str	r3, [sp, #12]
		taskEXIT_CRITICAL();
 8008538:	f7fc fc4c 	bl	8004dd4 <vPortExitCritical>
		vTaskSuspendAll();
 800853c:	f7fc f8c6 	bl	80046cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8008540:	f7fc fa30 	bl	80049a4 <vPortEnterCritical>
 8008544:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008548:	a901      	add	r1, sp, #4
		prvLockQueue( pxQueue );
 800854a:	2bff      	cmp	r3, #255	; 0xff
 800854c:	bf04      	itt	eq
 800854e:	2300      	moveq	r3, #0
 8008550:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8008554:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008558:	a802      	add	r0, sp, #8
		prvLockQueue( pxQueue );
 800855a:	2bff      	cmp	r3, #255	; 0xff
 800855c:	bf04      	itt	eq
 800855e:	2300      	moveq	r3, #0
 8008560:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8008564:	f7fc fc36 	bl	8004dd4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8008568:	f7fc ff42 	bl	80053f0 <xTaskCheckForTimeOut>
 800856c:	2800      	cmp	r0, #0
 800856e:	d150      	bne.n	8008612 <xQueueGenericSend.constprop.0+0x202>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8008570:	f7fc fa18 	bl	80049a4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8008574:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8008576:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008578:	429a      	cmp	r2, r3
 800857a:	d124      	bne.n	80085c6 <xQueueGenericSend.constprop.0+0x1b6>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800857c:	f7fc fc2a 	bl	8004dd4 <vPortExitCritical>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8008580:	f8d8 1000 	ldr.w	r1, [r8]
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8008584:	9d01      	ldr	r5, [sp, #4]
 8008586:	3118      	adds	r1, #24
 8008588:	f104 0010 	add.w	r0, r4, #16
 800858c:	f7fc f876 	bl	800467c <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8008590:	2101      	movs	r1, #1
 8008592:	4628      	mov	r0, r5
 8008594:	f7fc f998 	bl	80048c8 <prvAddCurrentTaskToDelayedList>
				prvUnlockQueue( pxQueue );
 8008598:	4620      	mov	r0, r4
 800859a:	f7fc fcc1 	bl	8004f20 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800859e:	f7fc fdb5 	bl	800510c <xTaskResumeAll>
 80085a2:	b1c0      	cbz	r0, 80085d6 <xQueueGenericSend.constprop.0+0x1c6>
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
 80085a4:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
 80085a6:	f7fc f9fd 	bl	80049a4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80085aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80085ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80085ae:	429a      	cmp	r2, r3
 80085b0:	d2b8      	bcs.n	8008524 <xQueueGenericSend.constprop.0+0x114>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80085b2:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80085b4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80085b6:	2a00      	cmp	r2, #0
 80085b8:	d19e      	bne.n	80084f8 <xQueueGenericSend.constprop.0+0xe8>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80085ba:	6823      	ldr	r3, [r4, #0]
 80085bc:	2b00      	cmp	r3, #0
 80085be:	f43f af36 	beq.w	800842e <xQueueGenericSend.constprop.0+0x1e>
BaseType_t xReturn = pdFALSE;
 80085c2:	2500      	movs	r5, #0
 80085c4:	e738      	b.n	8008438 <xQueueGenericSend.constprop.0+0x28>
				prvUnlockQueue( pxQueue );
 80085c6:	4620      	mov	r0, r4
	taskEXIT_CRITICAL();
 80085c8:	f7fc fc04 	bl	8004dd4 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 80085cc:	f7fc fca8 	bl	8004f20 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80085d0:	f7fc fd9c 	bl	800510c <xTaskResumeAll>
 80085d4:	e7e6      	b.n	80085a4 <xQueueGenericSend.constprop.0+0x194>
					portYIELD_WITHIN_API();
 80085d6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80085da:	4a14      	ldr	r2, [pc, #80]	; (800862c <xQueueGenericSend.constprop.0+0x21c>)
 80085dc:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80085e0:	6011      	str	r1, [r2, #0]
 80085e2:	4a13      	ldr	r2, [pc, #76]	; (8008630 <xQueueGenericSend.constprop.0+0x220>)
 80085e4:	6812      	ldr	r2, [r2, #0]
 80085e6:	b14a      	cbz	r2, 80085fc <xQueueGenericSend.constprop.0+0x1ec>
 80085e8:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80085ec:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80085f0:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80085f4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80085f8:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80085fc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8008600:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008604:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8008608:	f3bf 8f4f 	dsb	sy
 800860c:	f3bf 8f6f 	isb	sy
 8008610:	e7c8      	b.n	80085a4 <xQueueGenericSend.constprop.0+0x194>
			prvUnlockQueue( pxQueue );
 8008612:	4620      	mov	r0, r4
 8008614:	f7fc fc84 	bl	8004f20 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8008618:	f7fc fd78 	bl	800510c <xTaskResumeAll>
			return errQUEUE_FULL;
 800861c:	2000      	movs	r0, #0
 800861e:	e77e      	b.n	800851e <xQueueGenericSend.constprop.0+0x10e>
 8008620:	200015fc 	.word	0x200015fc
 8008624:	20001648 	.word	0x20001648
 8008628:	200011a8 	.word	0x200011a8
 800862c:	2000134c 	.word	0x2000134c
 8008630:	20001358 	.word	0x20001358
 8008634:	200011b8 	.word	0x200011b8
 8008638:	20001374 	.word	0x20001374

0800863c <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
 800863c:	b508      	push	{r3, lr}

  osalDbgCheck(i2cp != NULL);
 800863e:	b910      	cbnz	r0, 8008646 <i2cReleaseBus+0xa>
 8008640:	f7fc f9c0 	bl	80049c4 <vTaskEndScheduler>
 8008644:	e7fe      	b.n	8008644 <i2cReleaseBus+0x8>
    xSemaphoreGive(mutex->handle);
 8008646:	68c0      	ldr	r0, [r0, #12]

  osalMutexUnlock(&i2cp->mutex);
}
 8008648:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800864c:	f7ff bee0 	b.w	8008410 <xQueueGenericSend.constprop.0>

08008650 <max2870SpiState.part.0>:
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 8008650:	b510      	push	{r4, lr}
 8008652:	4604      	mov	r4, r0
        max2870SetMUXOut(driver, 0x0);
 8008654:	2100      	movs	r1, #0
 8008656:	f7ff fe2f 	bl	80082b8 <max2870SetMUXOut>
        monitorKick(&driver->pllMon, driver->enabled);
 800865a:	7921      	ldrb	r1, [r4, #4]
 800865c:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
 8008660:	f7fc fbfc 	bl	8004e5c <monitorKick>
        spiReleaseBus(driver->config->spiPort);
 8008664:	6823      	ldr	r3, [r4, #0]
 8008666:	681b      	ldr	r3, [r3, #0]
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 8008668:	b913      	cbnz	r3, 8008670 <max2870SpiState.part.0+0x20>
 800866a:	f7fc f9ab 	bl	80049c4 <vTaskEndScheduler>
 800866e:	e7fe      	b.n	800866e <max2870SpiState.part.0+0x1e>
 8008670:	68d8      	ldr	r0, [r3, #12]
}
 8008672:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8008676:	f7ff becb 	b.w	8008410 <xQueueGenericSend.constprop.0>

0800867a <prvInitialiseMutex.part.0>:
			pxNewQueue->pxMutexHolder = NULL;
 800867a:	2200      	movs	r2, #0
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800867c:	e9c0 2200 	strd	r2, r2, [r0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 8008680:	60c2      	str	r2, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8008682:	f7ff bec5 	b.w	8008410 <xQueueGenericSend.constprop.0>

08008686 <xQueueGenericReset.constprop.0.isra.0>:
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 8008686:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 8008688:	b900      	cbnz	r0, 800868c <xQueueGenericReset.constprop.0.isra.0+0x6>
 800868a:	e7fe      	b.n	800868a <xQueueGenericReset.constprop.0.isra.0+0x4>
	taskENTER_CRITICAL();
 800868c:	f7fc f98a 	bl	80049a4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8008690:	e9d0 340f 	ldrd	r3, r4, [r0, #60]	; 0x3c
 8008694:	4363      	muls	r3, r4
 8008696:	6802      	ldr	r2, [r0, #0]
 8008698:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800869a:	1b1b      	subs	r3, r3, r4
 800869c:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800869e:	6041      	str	r1, [r0, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80086a0:	60c3      	str	r3, [r0, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80086a2:	2100      	movs	r1, #0
}
 80086a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		pxQueue->cRxLock = queueUNLOCKED;
 80086a8:	23ff      	movs	r3, #255	; 0xff
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80086aa:	6082      	str	r2, [r0, #8]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80086ac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80086b0:	6381      	str	r1, [r0, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 80086b2:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80086b6:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086ba:	f100 0318 	add.w	r3, r0, #24
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086be:	e9c0 2306 	strd	r2, r3, [r0, #24]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086c2:	6143      	str	r3, [r0, #20]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086c4:	6203      	str	r3, [r0, #32]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086c6:	f100 032c 	add.w	r3, r0, #44	; 0x2c
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80086ca:	6101      	str	r1, [r0, #16]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80086cc:	e9c0 320a 	strd	r3, r2, [r0, #40]	; 0x28
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80086d0:	e9c0 330c 	strd	r3, r3, [r0, #48]	; 0x30
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80086d4:	6241      	str	r1, [r0, #36]	; 0x24
	taskEXIT_CRITICAL();
 80086d6:	f7fc bb7d 	b.w	8004dd4 <vPortExitCritical>

080086da <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80086da:	b40e      	push	{r1, r2, r3}
 80086dc:	b503      	push	{r0, r1, lr}
 80086de:	aa03      	add	r2, sp, #12
 80086e0:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80086e4:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80086e6:	f7fe fa09 	bl	8006afc <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80086ea:	b002      	add	sp, #8
 80086ec:	f85d eb04 	ldr.w	lr, [sp], #4
 80086f0:	b003      	add	sp, #12
 80086f2:	4770      	bx	lr

080086f4 <cmd_exit>:
#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)user;
  (void)argv;
  if (argc > 0) {
 80086f4:	2a00      	cmp	r2, #0
static void cmd_exit(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 80086f6:	4608      	mov	r0, r1
 80086f8:	b508      	push	{r3, lr}
  if (argc > 0) {
 80086fa:	dd05      	ble.n	8008708 <cmd_exit+0x14>
    shellUsage(chp, "exit");
    return;
  }

  shellExit(MSG_OK);
}
 80086fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shellUsage(chp, "exit");
 8008700:	4a06      	ldr	r2, [pc, #24]	; (800871c <cmd_exit+0x28>)
 8008702:	4907      	ldr	r1, [pc, #28]	; (8008720 <cmd_exit+0x2c>)
 8008704:	f7ff bfe9 	b.w	80086da <chprintf>
 */
void shellExit(msg_t msg) {

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8008708:	f7fc f94c 	bl	80049a4 <vPortEnterCritical>
}
static inline void chEvtBroadcast(event_source_t* event_source){
    osalEventBroadcastFlags(event_source, 1);
}
static inline void chEvtBroadcastI(event_source_t* event_source){
    osalEventBroadcastFlagsI(event_source, 1);
 800870c:	4805      	ldr	r0, [pc, #20]	; (8008724 <cmd_exit+0x30>)
 800870e:	2101      	movs	r1, #1
 8008710:	f7fe fbe8 	bl	8006ee4 <osalEventBroadcastFlagsI>
}
 8008714:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vTaskDelete(NULL);
 8008718:	f7fd bcb2 	b.w	8006080 <vTaskDelete.constprop.0>
 800871c:	0800ba75 	.word	0x0800ba75
 8008720:	0800ba7a 	.word	0x0800ba7a
 8008724:	200012b8 	.word	0x200012b8

08008728 <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)user;
  (void)argv;
  if (argc > 0) {
 8008728:	2a00      	cmp	r2, #0
static void cmd_info(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 800872a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800872c:	460c      	mov	r4, r1
  if (argc > 0) {
 800872e:	dd07      	ble.n	8008740 <cmd_info+0x18>
    shellUsage(chp, "info");
 8008730:	4620      	mov	r0, r4
 8008732:	4a1d      	ldr	r2, [pc, #116]	; (80087a8 <cmd_info+0x80>)
 8008734:	491d      	ldr	r1, [pc, #116]	; (80087ac <cmd_info+0x84>)
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
    chprintf(chp, "%02x", *i);
  }
  chprintf(chp, SHELL_NEWLINE_STR);
#endif
}
 8008736:	b003      	add	sp, #12
 8008738:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    shellUsage(chp, "info");
 800873c:	f7ff bfcd 	b.w	80086da <chprintf>
  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8008740:	4a1b      	ldr	r2, [pc, #108]	; (80087b0 <cmd_info+0x88>)
 8008742:	491c      	ldr	r1, [pc, #112]	; (80087b4 <cmd_info+0x8c>)
 8008744:	4620      	mov	r0, r4
 8008746:	f7ff ffc8 	bl	80086da <chprintf>
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 800874a:	4a1b      	ldr	r2, [pc, #108]	; (80087b8 <cmd_info+0x90>)
 800874c:	491b      	ldr	r1, [pc, #108]	; (80087bc <cmd_info+0x94>)
 800874e:	4620      	mov	r0, r4
 8008750:	f7ff ffc3 	bl	80086da <chprintf>
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
 8008754:	4a1a      	ldr	r2, [pc, #104]	; (80087c0 <cmd_info+0x98>)
 8008756:	491b      	ldr	r1, [pc, #108]	; (80087c4 <cmd_info+0x9c>)
 8008758:	4620      	mov	r0, r4
 800875a:	f7ff ffbe 	bl	80086da <chprintf>
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
 800875e:	4a1a      	ldr	r2, [pc, #104]	; (80087c8 <cmd_info+0xa0>)
 8008760:	491a      	ldr	r1, [pc, #104]	; (80087cc <cmd_info+0xa4>)
 8008762:	4620      	mov	r0, r4
 8008764:	f7ff ffb9 	bl	80086da <chprintf>
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8008768:	4b19      	ldr	r3, [pc, #100]	; (80087d0 <cmd_info+0xa8>)
 800876a:	4a1a      	ldr	r2, [pc, #104]	; (80087d4 <cmd_info+0xac>)
 800876c:	491a      	ldr	r1, [pc, #104]	; (80087d8 <cmd_info+0xb0>)
 800876e:	9300      	str	r3, [sp, #0]
 8008770:	4620      	mov	r0, r4
 8008772:	4b1a      	ldr	r3, [pc, #104]	; (80087dc <cmd_info+0xb4>)
 8008774:	f7ff ffb1 	bl	80086da <chprintf>
  chprintf(chp, "Build ID:     ");
 8008778:	4620      	mov	r0, r4
 800877a:	4919      	ldr	r1, [pc, #100]	; (80087e0 <cmd_info+0xb8>)
 800877c:	f7ff ffad 	bl	80086da <chprintf>
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 8008780:	4d18      	ldr	r5, [pc, #96]	; (80087e4 <cmd_info+0xbc>)
 8008782:	4e19      	ldr	r6, [pc, #100]	; (80087e8 <cmd_info+0xc0>)
    chprintf(chp, "%02x", *i);
 8008784:	4f19      	ldr	r7, [pc, #100]	; (80087ec <cmd_info+0xc4>)
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 8008786:	42b5      	cmp	r5, r6
 8008788:	d306      	bcc.n	8008798 <cmd_info+0x70>
  chprintf(chp, SHELL_NEWLINE_STR);
 800878a:	4620      	mov	r0, r4
 800878c:	4918      	ldr	r1, [pc, #96]	; (80087f0 <cmd_info+0xc8>)
}
 800878e:	b003      	add	sp, #12
 8008790:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chprintf(chp, SHELL_NEWLINE_STR);
 8008794:	f7ff bfa1 	b.w	80086da <chprintf>
    chprintf(chp, "%02x", *i);
 8008798:	4639      	mov	r1, r7
 800879a:	4620      	mov	r0, r4
 800879c:	f815 2b01 	ldrb.w	r2, [r5], #1
 80087a0:	f7ff ff9b 	bl	80086da <chprintf>
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 80087a4:	e7ef      	b.n	8008786 <cmd_info+0x5e>
 80087a6:	bf00      	nop
 80087a8:	0800ba86 	.word	0x0800ba86
 80087ac:	0800ba7a 	.word	0x0800ba7a
 80087b0:	0800ba8b 	.word	0x0800ba8b
 80087b4:	0800ba98 	.word	0x0800ba98
 80087b8:	0800baab 	.word	0x0800baab
 80087bc:	0800bab8 	.word	0x0800bab8
 80087c0:	0800bacb 	.word	0x0800bacb
 80087c4:	0800baf5 	.word	0x0800baf5
 80087c8:	0800bb08 	.word	0x0800bb08
 80087cc:	0800bb2e 	.word	0x0800bb2e
 80087d0:	0800bb68 	.word	0x0800bb68
 80087d4:	0800bb45 	.word	0x0800bb45
 80087d8:	0800bb51 	.word	0x0800bb51
 80087dc:	0800bb41 	.word	0x0800bb41
 80087e0:	0800bb71 	.word	0x0800bb71
 80087e4:	0800cd2c 	.word	0x0800cd2c
 80087e8:	0800cd40 	.word	0x0800cd40
 80087ec:	0800bb80 	.word	0x0800bb80
 80087f0:	0800be0f 	.word	0x0800be0f

080087f4 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;
  (void)user;
  if (argc != 1) {
 80087f4:	2a01      	cmp	r2, #1
static void cmd_echo(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 80087f6:	4608      	mov	r0, r1
    shellUsage(chp, "echo \"message\"");
 80087f8:	bf19      	ittee	ne
 80087fa:	4a03      	ldrne	r2, [pc, #12]	; (8008808 <cmd_echo+0x14>)
 80087fc:	4903      	ldrne	r1, [pc, #12]	; (800880c <cmd_echo+0x18>)
    return;
  }
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
 80087fe:	681a      	ldreq	r2, [r3, #0]
 8008800:	4903      	ldreq	r1, [pc, #12]	; (8008810 <cmd_echo+0x1c>)
 8008802:	f7ff bf6a 	b.w	80086da <chprintf>
 8008806:	bf00      	nop
 8008808:	0800bb85 	.word	0x0800bb85
 800880c:	0800ba7a 	.word	0x0800ba7a
 8008810:	0800bb3c 	.word	0x0800bb3c

08008814 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;
  (void)user;
  if (argc > 0) {
 8008814:	2a00      	cmp	r2, #0
static void cmd_systime(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 8008816:	4608      	mov	r0, r1
 8008818:	b508      	push	{r3, lr}
  if (argc > 0) {
 800881a:	dd05      	ble.n	8008828 <cmd_systime+0x14>
    shellUsage(chp, "systime");
 800881c:	4a05      	ldr	r2, [pc, #20]	; (8008834 <cmd_systime+0x20>)
 800881e:	4906      	ldr	r1, [pc, #24]	; (8008838 <cmd_systime+0x24>)
    return;
  }
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
 8008820:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8008824:	f7ff bf59 	b.w	80086da <chprintf>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8008828:	f7fd fb78 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800882c:	4b03      	ldr	r3, [pc, #12]	; (800883c <cmd_systime+0x28>)
 800882e:	4904      	ldr	r1, [pc, #16]	; (8008840 <cmd_systime+0x2c>)
 8008830:	681a      	ldr	r2, [r3, #0]
 8008832:	e7f5      	b.n	8008820 <cmd_systime+0xc>
 8008834:	0800bb94 	.word	0x0800bb94
 8008838:	0800ba7a 	.word	0x0800ba7a
 800883c:	20001648 	.word	0x20001648
 8008840:	0800bb9c 	.word	0x0800bb9c

08008844 <cmd_mem>:
#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, total, largest;
  (void)argv;
  (void)user;
  if (argc > 0) {
 8008844:	2a00      	cmp	r2, #0
static void cmd_mem(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 8008846:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008848:	460c      	mov	r4, r1
  if (argc > 0) {
 800884a:	dd06      	ble.n	800885a <cmd_mem+0x16>
    shellUsage(chp, "mem");
 800884c:	4a14      	ldr	r2, [pc, #80]	; (80088a0 <cmd_mem+0x5c>)
 800884e:	4915      	ldr	r1, [pc, #84]	; (80088a4 <cmd_mem+0x60>)
  }
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 8008850:	4620      	mov	r0, r4
}
 8008852:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 8008856:	f7ff bf40 	b.w	80086da <chprintf>

/* ChibiOS style memory info function */
size_t chHeapStatus  (void* ignore, size_t* memFree, size_t* largestBlock){
    size_t blocks = 0;
    *memFree = xFreeBytesRemaining;
    *largestBlock = 0;
 800885a:	2500      	movs	r5, #0
    size_t blocks = 0;
 800885c:	462e      	mov	r6, r5
    *memFree = xFreeBytesRemaining;
 800885e:	4b12      	ldr	r3, [pc, #72]	; (80088a8 <cmd_mem+0x64>)
 8008860:	681f      	ldr	r7, [r3, #0]

    /* Count blocks */
    BlockLink_t *pxIterator;
    for(pxIterator = xStart.pxNextFreeBlock; pxIterator->pxNextFreeBlock; pxIterator = pxIterator->pxNextFreeBlock ){
 8008862:	4b12      	ldr	r3, [pc, #72]	; (80088ac <cmd_mem+0x68>)
 8008864:	681b      	ldr	r3, [r3, #0]
 8008866:	681a      	ldr	r2, [r3, #0]
 8008868:	b98a      	cbnz	r2, 800888e <cmd_mem+0x4a>
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 800886a:	463a      	mov	r2, r7
 800886c:	4910      	ldr	r1, [pc, #64]	; (80088b0 <cmd_mem+0x6c>)
 800886e:	4620      	mov	r0, r4
 8008870:	f7ff ff33 	bl	80086da <chprintf>
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
 8008874:	4632      	mov	r2, r6
 8008876:	490f      	ldr	r1, [pc, #60]	; (80088b4 <cmd_mem+0x70>)
 8008878:	4620      	mov	r0, r4
 800887a:	f7ff ff2e 	bl	80086da <chprintf>
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
 800887e:	463a      	mov	r2, r7
 8008880:	490d      	ldr	r1, [pc, #52]	; (80088b8 <cmd_mem+0x74>)
 8008882:	4620      	mov	r0, r4
 8008884:	f7ff ff29 	bl	80086da <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 8008888:	462a      	mov	r2, r5
 800888a:	490c      	ldr	r1, [pc, #48]	; (80088bc <cmd_mem+0x78>)
 800888c:	e7e0      	b.n	8008850 <cmd_mem+0xc>
        if(pxIterator->xBlockSize){
 800888e:	685b      	ldr	r3, [r3, #4]
 8008890:	b103      	cbz	r3, 8008894 <cmd_mem+0x50>
            blocks++;
 8008892:	3601      	adds	r6, #1
 8008894:	429d      	cmp	r5, r3
 8008896:	bf38      	it	cc
 8008898:	461d      	movcc	r5, r3
 800889a:	4613      	mov	r3, r2
 800889c:	e7e3      	b.n	8008866 <cmd_mem+0x22>
 800889e:	bf00      	nop
 80088a0:	0800bba2 	.word	0x0800bba2
 80088a4:	0800ba7a 	.word	0x0800ba7a
 80088a8:	200013a4 	.word	0x200013a4
 80088ac:	20001618 	.word	0x20001618
 80088b0:	0800bba6 	.word	0x0800bba6
 80088b4:	0800bbc4 	.word	0x0800bbc4
 80088b8:	0800bbdc 	.word	0x0800bbdc
 80088bc:	0800bbfa 	.word	0x0800bbfa

080088c0 <cmdMco>:
    if(argc != 1) {
 80088c0:	2a01      	cmp	r2, #1
{
 80088c2:	b510      	push	{r4, lr}
 80088c4:	460c      	mov	r4, r1
    if(argc != 1) {
 80088c6:	d009      	beq.n	80088dc <cmdMco+0x1c>
        chprintf(chp,"Usage:"SHELL_NEWLINE_STR);
 80088c8:	4620      	mov	r0, r4
 80088ca:	4909      	ldr	r1, [pc, #36]	; (80088f0 <cmdMco+0x30>)
 80088cc:	f7ff ff05 	bl	80086da <chprintf>
        chprintf(chp,"\t mco [1/0]"SHELL_NEWLINE_STR);
 80088d0:	4620      	mov	r0, r4
}
 80088d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        chprintf(chp,"\t mco [1/0]"SHELL_NEWLINE_STR);
 80088d6:	4907      	ldr	r1, [pc, #28]	; (80088f4 <cmdMco+0x34>)
 80088d8:	f7ff beff 	b.w	80086da <chprintf>
        systemEnableMCO(argv[0][0] == '1');
 80088dc:	681b      	ldr	r3, [r3, #0]
}
 80088de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        systemEnableMCO(argv[0][0] == '1');
 80088e2:	7818      	ldrb	r0, [r3, #0]
 80088e4:	f1a0 0331 	sub.w	r3, r0, #49	; 0x31
 80088e8:	4258      	negs	r0, r3
 80088ea:	4158      	adcs	r0, r3
 80088ec:	f7fe bd1e 	b.w	800732c <systemEnableMCO>
 80088f0:	0800bc18 	.word	0x0800bc18
 80088f4:	0800bc21 	.word	0x0800bc21

080088f8 <cmdLicense>:
{
 80088f8:	4608      	mov	r0, r1
    chprintf(chp,"%s", &_binary_data_license_bin_start);
 80088fa:	4a02      	ldr	r2, [pc, #8]	; (8008904 <cmdLicense+0xc>)
 80088fc:	4902      	ldr	r1, [pc, #8]	; (8008908 <cmdLicense+0x10>)
 80088fe:	f7ff beec 	b.w	80086da <chprintf>
 8008902:	bf00      	nop
 8008904:	08002234 	.word	0x08002234
 8008908:	0800bc2f 	.word	0x0800bc2f

0800890c <cmdMaxUsage>:
#include <string.h>
#include <stdlib.h>


static void cmdMaxUsage(BaseSequentialStream* chp)
{
 800890c:	b510      	push	{r4, lr}
 800890e:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 8008910:	490e      	ldr	r1, [pc, #56]	; (800894c <cmdMaxUsage+0x40>)
 8008912:	f7ff fee2 	bl	80086da <chprintf>
    chprintf(chp, "\tmax tune [freqkHz] [power] [forceVAS]"SHELL_NEWLINE_STR);
 8008916:	4620      	mov	r0, r4
 8008918:	490d      	ldr	r1, [pc, #52]	; (8008950 <cmdMaxUsage+0x44>)
 800891a:	f7ff fede 	bl	80086da <chprintf>
    chprintf(chp, "\tmax status"SHELL_NEWLINE_STR);
 800891e:	4620      	mov	r0, r4
 8008920:	490c      	ldr	r1, [pc, #48]	; (8008954 <cmdMaxUsage+0x48>)
 8008922:	f7ff feda 	bl	80086da <chprintf>
    chprintf(chp, "\tmax vcocache"SHELL_NEWLINE_STR);
 8008926:	4620      	mov	r0, r4
 8008928:	490b      	ldr	r1, [pc, #44]	; (8008958 <cmdMaxUsage+0x4c>)
 800892a:	f7ff fed6 	bl	80086da <chprintf>
    chprintf(chp, "\tmax vcocache calibrate"SHELL_NEWLINE_STR);
 800892e:	4620      	mov	r0, r4
 8008930:	490a      	ldr	r1, [pc, #40]	; (800895c <cmdMaxUsage+0x50>)
 8008932:	f7ff fed2 	bl	80086da <chprintf>
    chprintf(chp, "\tmax vcocache set index value"SHELL_NEWLINE_STR);
 8008936:	4620      	mov	r0, r4
 8008938:	4909      	ldr	r1, [pc, #36]	; (8008960 <cmdMaxUsage+0x54>)
 800893a:	f7ff fece 	bl	80086da <chprintf>
    chprintf(chp, "\tmax dld"SHELL_NEWLINE_STR);
 800893e:	4620      	mov	r0, r4
}
 8008940:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\tmax dld"SHELL_NEWLINE_STR);
 8008944:	4907      	ldr	r1, [pc, #28]	; (8008964 <cmdMaxUsage+0x58>)
 8008946:	f7ff bec8 	b.w	80086da <chprintf>
 800894a:	bf00      	nop
 800894c:	0800bc18 	.word	0x0800bc18
 8008950:	0800bc32 	.word	0x0800bc32
 8008954:	0800bc5b 	.word	0x0800bc5b
 8008958:	0800bc69 	.word	0x0800bc69
 800895c:	0800bc79 	.word	0x0800bc79
 8008960:	0800bc93 	.word	0x0800bc93
 8008964:	0800bcb3 	.word	0x0800bcb3

08008968 <cmdI2CUsage>:

#include <string.h>
#include <stdlib.h>

static void cmdI2CUsage(BaseSequentialStream *chp)
{
 8008968:	b510      	push	{r4, lr}
 800896a:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 800896c:	490c      	ldr	r1, [pc, #48]	; (80089a0 <cmdI2CUsage+0x38>)
 800896e:	f7ff feb4 	bl	80086da <chprintf>
    chprintf(chp, "\ti2c test"SHELL_NEWLINE_STR);
 8008972:	4620      	mov	r0, r4
 8008974:	490b      	ldr	r1, [pc, #44]	; (80089a4 <cmdI2CUsage+0x3c>)
 8008976:	f7ff feb0 	bl	80086da <chprintf>
    chprintf(chp, "\ti2c scan"SHELL_NEWLINE_STR);
 800897a:	4620      	mov	r0, r4
 800897c:	490a      	ldr	r1, [pc, #40]	; (80089a8 <cmdI2CUsage+0x40>)
 800897e:	f7ff feac 	bl	80086da <chprintf>
    chprintf(chp, "\ti2c errors"SHELL_NEWLINE_STR);
 8008982:	4620      	mov	r0, r4
 8008984:	4909      	ldr	r1, [pc, #36]	; (80089ac <cmdI2CUsage+0x44>)
 8008986:	f7ff fea8 	bl	80086da <chprintf>
    chprintf(chp, "\ti2c get devAddr regAddr [stress]"SHELL_NEWLINE_STR);
 800898a:	4620      	mov	r0, r4
 800898c:	4908      	ldr	r1, [pc, #32]	; (80089b0 <cmdI2CUsage+0x48>)
 800898e:	f7ff fea4 	bl	80086da <chprintf>
    chprintf(chp, "\ti2c set devAddr regAddr regValue [stress]"SHELL_NEWLINE_STR);
 8008992:	4620      	mov	r0, r4
}
 8008994:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\ti2c set devAddr regAddr regValue [stress]"SHELL_NEWLINE_STR);
 8008998:	4906      	ldr	r1, [pc, #24]	; (80089b4 <cmdI2CUsage+0x4c>)
 800899a:	f7ff be9e 	b.w	80086da <chprintf>
 800899e:	bf00      	nop
 80089a0:	0800bc18 	.word	0x0800bc18
 80089a4:	0800bcbe 	.word	0x0800bcbe
 80089a8:	0800bcca 	.word	0x0800bcca
 80089ac:	0800bcd6 	.word	0x0800bcd6
 80089b0:	0800bce4 	.word	0x0800bce4
 80089b4:	0800bd08 	.word	0x0800bd08

080089b8 <cmdGPIOUsage>:

#include <string.h>
#include <stdlib.h>

static void cmdGPIOUsage(BaseSequentialStream *chp)
{
 80089b8:	b510      	push	{r4, lr}
 80089ba:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 80089bc:	4910      	ldr	r1, [pc, #64]	; (8008a00 <cmdGPIOUsage+0x48>)
 80089be:	f7ff fe8c 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio status"SHELL_NEWLINE_STR);
 80089c2:	4620      	mov	r0, r4
 80089c4:	490f      	ldr	r1, [pc, #60]	; (8008a04 <cmdGPIOUsage+0x4c>)
 80089c6:	f7ff fe88 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] [pin] output"SHELL_NEWLINE_STR);
 80089ca:	4620      	mov	r0, r4
 80089cc:	490e      	ldr	r1, [pc, #56]	; (8008a08 <cmdGPIOUsage+0x50>)
 80089ce:	f7ff fe84 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] [pin] input"SHELL_NEWLINE_STR);
 80089d2:	4620      	mov	r0, r4
 80089d4:	490d      	ldr	r1, [pc, #52]	; (8008a0c <cmdGPIOUsage+0x54>)
 80089d6:	f7ff fe80 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] [pin] set"SHELL_NEWLINE_STR);
 80089da:	4620      	mov	r0, r4
 80089dc:	490c      	ldr	r1, [pc, #48]	; (8008a10 <cmdGPIOUsage+0x58>)
 80089de:	f7ff fe7c 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] [pin] clear"SHELL_NEWLINE_STR);
 80089e2:	4620      	mov	r0, r4
 80089e4:	490b      	ldr	r1, [pc, #44]	; (8008a14 <cmdGPIOUsage+0x5c>)
 80089e6:	f7ff fe78 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] [pin] get"SHELL_NEWLINE_STR);
 80089ea:	4620      	mov	r0, r4
 80089ec:	490a      	ldr	r1, [pc, #40]	; (8008a18 <cmdGPIOUsage+0x60>)
 80089ee:	f7ff fe74 	bl	80086da <chprintf>
    chprintf(chp, "\tgpio [port] bus [on/off]"SHELL_NEWLINE_STR);
 80089f2:	4620      	mov	r0, r4

}
 80089f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\tgpio [port] bus [on/off]"SHELL_NEWLINE_STR);
 80089f8:	4908      	ldr	r1, [pc, #32]	; (8008a1c <cmdGPIOUsage+0x64>)
 80089fa:	f7ff be6e 	b.w	80086da <chprintf>
 80089fe:	bf00      	nop
 8008a00:	0800bc18 	.word	0x0800bc18
 8008a04:	0800bd35 	.word	0x0800bd35
 8008a08:	0800bd44 	.word	0x0800bd44
 8008a0c:	0800bd60 	.word	0x0800bd60
 8008a10:	0800bd7b 	.word	0x0800bd7b
 8008a14:	0800bd94 	.word	0x0800bd94
 8008a18:	0800bdaf 	.word	0x0800bdaf
 8008a1c:	0800bdc8 	.word	0x0800bdc8

08008a20 <gpioDummyStatus>:

    return false;
}

void gpioDummyStatus(const GPIOPort* driver, BaseSequentialStream* chp)
{
 8008a20:	4608      	mov	r0, r1
    (void)driver;

    chprintf(chp, "\tDriver: Dummy"SHELL_NEWLINE_STR);
 8008a22:	4901      	ldr	r1, [pc, #4]	; (8008a28 <gpioDummyStatus+0x8>)
 8008a24:	f7ff be59 	b.w	80086da <chprintf>
 8008a28:	0800bde4 	.word	0x0800bde4

08008a2c <printfFixed>:
{
 8008a2c:	b40c      	push	{r2, r3}
 8008a2e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8008a32:	aa08      	add	r2, sp, #32
 8008a34:	460d      	mov	r5, r1
 8008a36:	f852 1b04 	ldr.w	r1, [r2], #4
 8008a3a:	4606      	mov	r6, r0
    va_start(args, format);
 8008a3c:	9201      	str	r2, [sp, #4]
    int result = chvprintf(chn, format, args);
 8008a3e:	f7fe f85d 	bl	8006afc <chvprintf>
 8008a42:	4604      	mov	r4, r0
 8008a44:	4607      	mov	r7, r0
        chnWrite(chn, (unsigned char*)" ", 1);
 8008a46:	f8df 802c 	ldr.w	r8, [pc, #44]	; 8008a74 <printfFixed+0x48>
    for(; result<minLength; result++) {
 8008a4a:	42af      	cmp	r7, r5
 8008a4c:	db09      	blt.n	8008a62 <printfFixed+0x36>
 8008a4e:	1b28      	subs	r0, r5, r4
 8008a50:	42ac      	cmp	r4, r5
 8008a52:	bfc8      	it	gt
 8008a54:	2000      	movgt	r0, #0
}
 8008a56:	4420      	add	r0, r4
 8008a58:	b002      	add	sp, #8
 8008a5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8008a5e:	b002      	add	sp, #8
 8008a60:	4770      	bx	lr
        chnWrite(chn, (unsigned char*)" ", 1);
 8008a62:	6833      	ldr	r3, [r6, #0]
 8008a64:	2201      	movs	r2, #1
 8008a66:	4641      	mov	r1, r8
 8008a68:	4630      	mov	r0, r6
 8008a6a:	681b      	ldr	r3, [r3, #0]
 8008a6c:	4798      	blx	r3
    for(; result<minLength; result++) {
 8008a6e:	3701      	adds	r7, #1
 8008a70:	e7eb      	b.n	8008a4a <printfFixed+0x1e>
 8008a72:	bf00      	nop
 8008a74:	0800bb7e 	.word	0x0800bb7e

08008a78 <max2870StatusPrint>:

    return allGood;
}

void max2870StatusPrint(MAX2870Driver* driver, BaseSequentialStream* stdout)
{
 8008a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008a7c:	4605      	mov	r5, r0
 8008a7e:	460c      	mov	r4, r1
    max2870SpiState(driver, true);
 8008a80:	f7ff fb18 	bl	80080b4 <max2870SpiState.constprop.0>
    for(int i=0; i<7; i++) {
        chprintf(stdout, "\t%u: %08x"SHELL_NEWLINE_STR, i, driver->registers[i]);
    }
    */

    if(driver->enabled) {
 8008a84:	792b      	ldrb	r3, [r5, #4]
 8008a86:	2b00      	cmp	r3, #0
 8008a88:	f000 80c8 	beq.w	8008c1c <max2870StatusPrint+0x1a4>
        if(driver->currentTune.isLocked) {
 8008a8c:	7f2b      	ldrb	r3, [r5, #28]
 8008a8e:	2b00      	cmp	r3, #0
 8008a90:	f000 8092 	beq.w	8008bb8 <max2870StatusPrint+0x140>
            chprintf(stdout, "PLL Locked"SHELL_NEWLINE_STR);
 8008a94:	4964      	ldr	r1, [pc, #400]	; (8008c28 <max2870StatusPrint+0x1b0>)
        } else {
            chprintf(stdout, "PLL UNLOCK!!!"SHELL_NEWLINE_STR);
 8008a96:	4620      	mov	r0, r4
 8008a98:	f7ff fe1f 	bl	80086da <chprintf>
        }

        printfFixed(stdout, 30, "Divided VCO Frequency:");
 8008a9c:	211e      	movs	r1, #30
 8008a9e:	4a63      	ldr	r2, [pc, #396]	; (8008c2c <max2870StatusPrint+0x1b4>)
 8008aa0:	4620      	mov	r0, r4
 8008aa2:	f7ff ffc3 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u kHz"SHELL_NEWLINE_STR, driver->currentTune.frequency/1000);
 8008aa6:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 8008aaa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8008aae:	2300      	movs	r3, #0
 8008ab0:	f7fa fe8c 	bl	80037cc <__aeabi_uldivmod>
 8008ab4:	4602      	mov	r2, r0
 8008ab6:	460b      	mov	r3, r1
 8008ab8:	4620      	mov	r0, r4
 8008aba:	495d      	ldr	r1, [pc, #372]	; (8008c30 <max2870StatusPrint+0x1b8>)
 8008abc:	f7ff fe0d 	bl	80086da <chprintf>
        printfFixed(stdout, 30, "Output A Power:");
 8008ac0:	4a5c      	ldr	r2, [pc, #368]	; (8008c34 <max2870StatusPrint+0x1bc>)
 8008ac2:	211e      	movs	r1, #30
 8008ac4:	4620      	mov	r0, r4
 8008ac6:	f7ff ffb1 	bl	8008a2c <printfFixed>
        if(driver->currentTune.powerA != -127) {
 8008aca:	f995 2010 	ldrsb.w	r2, [r5, #16]
 8008ace:	f112 0f7f 	cmn.w	r2, #127	; 0x7f
 8008ad2:	d073      	beq.n	8008bbc <max2870StatusPrint+0x144>
            chprintf(stdout, "%d dBm"SHELL_NEWLINE_STR, driver->currentTune.powerA);
 8008ad4:	4620      	mov	r0, r4
 8008ad6:	4958      	ldr	r1, [pc, #352]	; (8008c38 <max2870StatusPrint+0x1c0>)
 8008ad8:	f7ff fdff 	bl	80086da <chprintf>
        } else {
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
        }
        printfFixed(stdout, 30, "Output B Power:");
 8008adc:	4a57      	ldr	r2, [pc, #348]	; (8008c3c <max2870StatusPrint+0x1c4>)
 8008ade:	211e      	movs	r1, #30
 8008ae0:	4620      	mov	r0, r4
 8008ae2:	f7ff ffa3 	bl	8008a2c <printfFixed>
        if(driver->currentTune.powerB != -127) {
 8008ae6:	f995 2011 	ldrsb.w	r2, [r5, #17]
 8008aea:	f112 0f7f 	cmn.w	r2, #127	; 0x7f
 8008aee:	d06a      	beq.n	8008bc6 <max2870StatusPrint+0x14e>
            chprintf(stdout, "%d dBm"SHELL_NEWLINE_STR, driver->currentTune.powerB);
 8008af0:	4620      	mov	r0, r4
 8008af2:	4951      	ldr	r1, [pc, #324]	; (8008c38 <max2870StatusPrint+0x1c0>)
 8008af4:	f7ff fdf1 	bl	80086da <chprintf>
        } else {
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
        }
        if(driver->currentTune.isLocked) {
 8008af8:	7f2b      	ldrb	r3, [r5, #28]
 8008afa:	b14b      	cbz	r3, 8008b10 <max2870StatusPrint+0x98>
            printfFixed(stdout, 30, "Lock Time:");
 8008afc:	211e      	movs	r1, #30
 8008afe:	4a50      	ldr	r2, [pc, #320]	; (8008c40 <max2870StatusPrint+0x1c8>)
 8008b00:	4620      	mov	r0, r4
 8008b02:	f7ff ff93 	bl	8008a2c <printfFixed>
            chprintf(stdout, "%u cycles"SHELL_NEWLINE_STR, driver->currentTune.lockTime);
 8008b06:	4620      	mov	r0, r4
 8008b08:	7eea      	ldrb	r2, [r5, #27]
 8008b0a:	494e      	ldr	r1, [pc, #312]	; (8008c44 <max2870StatusPrint+0x1cc>)
 8008b0c:	f7ff fde5 	bl	80086da <chprintf>
        }
        printfFixed(stdout, 30, "PFD Frequency:");
 8008b10:	211e      	movs	r1, #30
 8008b12:	4a4d      	ldr	r2, [pc, #308]	; (8008c48 <max2870StatusPrint+0x1d0>)
 8008b14:	4620      	mov	r0, r4
 8008b16:	f7ff ff89 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u kHz"SHELL_NEWLINE_STR, driver->pfdFrequency/1000);
 8008b1a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008b1e:	f8d5 20b8 	ldr.w	r2, [r5, #184]	; 0xb8
 8008b22:	4943      	ldr	r1, [pc, #268]	; (8008c30 <max2870StatusPrint+0x1b8>)
 8008b24:	fbb2 f2f3 	udiv	r2, r2, r3
 8008b28:	4620      	mov	r0, r4
 8008b2a:	f7ff fdd6 	bl	80086da <chprintf>
        printfFixed(stdout, 30, "Step Frequency:");
 8008b2e:	211e      	movs	r1, #30
 8008b30:	4a46      	ldr	r2, [pc, #280]	; (8008c4c <max2870StatusPrint+0x1d4>)
 8008b32:	4620      	mov	r0, r4
 8008b34:	f7ff ff7a 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u Hz"SHELL_NEWLINE_STR, driver->config->stepFrequency);
 8008b38:	682b      	ldr	r3, [r5, #0]
 8008b3a:	4945      	ldr	r1, [pc, #276]	; (8008c50 <max2870StatusPrint+0x1d8>)
 8008b3c:	699a      	ldr	r2, [r3, #24]
 8008b3e:	4620      	mov	r0, r4
 8008b40:	f7ff fdcb 	bl	80086da <chprintf>
        printfFixed(stdout, 30, "BS Divider:");
 8008b44:	211e      	movs	r1, #30
 8008b46:	4a43      	ldr	r2, [pc, #268]	; (8008c54 <max2870StatusPrint+0x1dc>)
 8008b48:	4620      	mov	r0, r4
 8008b4a:	f7ff ff6f 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->bsValue);
 8008b4e:	f8b5 20c4 	ldrh.w	r2, [r5, #196]	; 0xc4
 8008b52:	4941      	ldr	r1, [pc, #260]	; (8008c58 <max2870StatusPrint+0x1e0>)
 8008b54:	4620      	mov	r0, r4
 8008b56:	f7ff fdc0 	bl	80086da <chprintf>
        printfFixed(stdout, 30, "Reload Counter:");
 8008b5a:	211e      	movs	r1, #30
 8008b5c:	4a3f      	ldr	r2, [pc, #252]	; (8008c5c <max2870StatusPrint+0x1e4>)
 8008b5e:	4620      	mov	r0, r4
 8008b60:	f7ff ff64 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->pllMonReloadCounter);
 8008b64:	f895 20e4 	ldrb.w	r2, [r5, #228]	; 0xe4
 8008b68:	493b      	ldr	r1, [pc, #236]	; (8008c58 <max2870StatusPrint+0x1e0>)
 8008b6a:	4620      	mov	r0, r4
 8008b6c:	f7ff fdb5 	bl	80086da <chprintf>

        printfFixed(stdout, 30, "Current VCO Band From Cache:");
 8008b70:	211e      	movs	r1, #30
 8008b72:	4a3b      	ldr	r2, [pc, #236]	; (8008c60 <max2870StatusPrint+0x1e8>)
 8008b74:	4620      	mov	r0, r4
 8008b76:	f7ff ff59 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, !driver->currentTune.usedVCOAutotune);
 8008b7a:	7f6a      	ldrb	r2, [r5, #29]
 8008b7c:	4936      	ldr	r1, [pc, #216]	; (8008c58 <max2870StatusPrint+0x1e0>)
 8008b7e:	f082 0201 	eor.w	r2, r2, #1
 8008b82:	4620      	mov	r0, r4
 8008b84:	f7ff fda9 	bl	80086da <chprintf>
        printfFixed(stdout, 30, "Current VCO Band:");
 8008b88:	211e      	movs	r1, #30
 8008b8a:	4a36      	ldr	r2, [pc, #216]	; (8008c64 <max2870StatusPrint+0x1ec>)
 8008b8c:	4620      	mov	r0, r4
 8008b8e:	f7ff ff4d 	bl	8008a2c <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->currentTune.usedVCO);
 8008b92:	7e6a      	ldrb	r2, [r5, #25]
 8008b94:	4930      	ldr	r1, [pc, #192]	; (8008c58 <max2870StatusPrint+0x1e0>)
 8008b96:	4620      	mov	r0, r4
 8008b98:	f7ff fd9f 	bl	80086da <chprintf>

        printfFixed(stdout, 30, "Current VCO Tuning Voltage:");
 8008b9c:	211e      	movs	r1, #30
 8008b9e:	4620      	mov	r0, r4
 8008ba0:	4a31      	ldr	r2, [pc, #196]	; (8008c68 <max2870StatusPrint+0x1f0>)
 8008ba2:	f7ff ff43 	bl	8008a2c <printfFixed>
        switch(driver->currentTune.adcVoltage) {
 8008ba6:	7eab      	ldrb	r3, [r5, #26]
 8008ba8:	2b06      	cmp	r3, #6
 8008baa:	d835      	bhi.n	8008c18 <max2870StatusPrint+0x1a0>
 8008bac:	e8df f003 	tbb	[pc, r3]
 8008bb0:	2e2e2c10 	.word	0x2e2e2c10
 8008bb4:	3030      	.short	0x3030
 8008bb6:	32          	.byte	0x32
 8008bb7:	00          	.byte	0x00
            chprintf(stdout, "PLL UNLOCK!!!"SHELL_NEWLINE_STR);
 8008bb8:	492c      	ldr	r1, [pc, #176]	; (8008c6c <max2870StatusPrint+0x1f4>)
 8008bba:	e76c      	b.n	8008a96 <max2870StatusPrint+0x1e>
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
 8008bbc:	4620      	mov	r0, r4
 8008bbe:	492c      	ldr	r1, [pc, #176]	; (8008c70 <max2870StatusPrint+0x1f8>)
 8008bc0:	f7ff fd8b 	bl	80086da <chprintf>
 8008bc4:	e78a      	b.n	8008adc <max2870StatusPrint+0x64>
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
 8008bc6:	4620      	mov	r0, r4
 8008bc8:	4929      	ldr	r1, [pc, #164]	; (8008c70 <max2870StatusPrint+0x1f8>)
 8008bca:	f7ff fd86 	bl	80086da <chprintf>
 8008bce:	e793      	b.n	8008af8 <max2870StatusPrint+0x80>
            case 0:
                chprintf(stdout, "0.2");
 8008bd0:	4928      	ldr	r1, [pc, #160]	; (8008c74 <max2870StatusPrint+0x1fc>)
                break;
            case 6:
                chprintf(stdout, "2.3");
                break;
            default:
                chprintf(stdout, "3");
 8008bd2:	4620      	mov	r0, r4
 8008bd4:	f7ff fd81 	bl	80086da <chprintf>
                break;
        }
        chprintf(stdout, "V"SHELL_NEWLINE_STR"Registers:"SHELL_NEWLINE_STR);
 8008bd8:	4620      	mov	r0, r4
 8008bda:	4927      	ldr	r1, [pc, #156]	; (8008c78 <max2870StatusPrint+0x200>)
 8008bdc:	f7ff fd7d 	bl	80086da <chprintf>
        for(int i=0; i<7; i++) {
 8008be0:	2600      	movs	r6, #0
            chprintf(stdout, "\t%u: %08x"SHELL_NEWLINE_STR, i, driver->registers[i]);
 8008be2:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8008c7c <max2870StatusPrint+0x204>
 8008be6:	f105 07c8 	add.w	r7, r5, #200	; 0xc8
 8008bea:	4632      	mov	r2, r6
 8008bec:	4641      	mov	r1, r8
 8008bee:	4620      	mov	r0, r4
 8008bf0:	f857 3b04 	ldr.w	r3, [r7], #4
        for(int i=0; i<7; i++) {
 8008bf4:	3601      	adds	r6, #1
            chprintf(stdout, "\t%u: %08x"SHELL_NEWLINE_STR, i, driver->registers[i]);
 8008bf6:	f7ff fd70 	bl	80086da <chprintf>
        for(int i=0; i<7; i++) {
 8008bfa:	2e07      	cmp	r6, #7
 8008bfc:	d1f5      	bne.n	8008bea <max2870StatusPrint+0x172>
    if(enable) {
 8008bfe:	4628      	mov	r0, r5
    } else {
        chprintf(stdout, "Low power mode"SHELL_NEWLINE_STR);
    }

    max2870SpiState(driver, false);
}
 8008c00:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8008c04:	f7ff bd24 	b.w	8008650 <max2870SpiState.part.0>
                chprintf(stdout, "0.6");
 8008c08:	491d      	ldr	r1, [pc, #116]	; (8008c80 <max2870StatusPrint+0x208>)
 8008c0a:	e7e2      	b.n	8008bd2 <max2870StatusPrint+0x15a>
                chprintf(stdout, "1");
 8008c0c:	491d      	ldr	r1, [pc, #116]	; (8008c84 <max2870StatusPrint+0x20c>)
 8008c0e:	e7e0      	b.n	8008bd2 <max2870StatusPrint+0x15a>
                chprintf(stdout, "1.7");
 8008c10:	491d      	ldr	r1, [pc, #116]	; (8008c88 <max2870StatusPrint+0x210>)
 8008c12:	e7de      	b.n	8008bd2 <max2870StatusPrint+0x15a>
                chprintf(stdout, "2.3");
 8008c14:	491d      	ldr	r1, [pc, #116]	; (8008c8c <max2870StatusPrint+0x214>)
 8008c16:	e7dc      	b.n	8008bd2 <max2870StatusPrint+0x15a>
                chprintf(stdout, "3");
 8008c18:	491d      	ldr	r1, [pc, #116]	; (8008c90 <max2870StatusPrint+0x218>)
 8008c1a:	e7da      	b.n	8008bd2 <max2870StatusPrint+0x15a>
        chprintf(stdout, "Low power mode"SHELL_NEWLINE_STR);
 8008c1c:	4620      	mov	r0, r4
 8008c1e:	491d      	ldr	r1, [pc, #116]	; (8008c94 <max2870StatusPrint+0x21c>)
 8008c20:	f7ff fd5b 	bl	80086da <chprintf>
 8008c24:	e7eb      	b.n	8008bfe <max2870StatusPrint+0x186>
 8008c26:	bf00      	nop
 8008c28:	0800bdf5 	.word	0x0800bdf5
 8008c2c:	0800be12 	.word	0x0800be12
 8008c30:	0800c0e9 	.word	0x0800c0e9
 8008c34:	0800be29 	.word	0x0800be29
 8008c38:	0800be39 	.word	0x0800be39
 8008c3c:	0800be48 	.word	0x0800be48
 8008c40:	0800be58 	.word	0x0800be58
 8008c44:	0800be63 	.word	0x0800be63
 8008c48:	0800be6f 	.word	0x0800be6f
 8008c4c:	0800be7e 	.word	0x0800be7e
 8008c50:	0800be8e 	.word	0x0800be8e
 8008c54:	0800be96 	.word	0x0800be96
 8008c58:	0800c13c 	.word	0x0800c13c
 8008c5c:	0800bea2 	.word	0x0800bea2
 8008c60:	0800beb2 	.word	0x0800beb2
 8008c64:	0800becf 	.word	0x0800becf
 8008c68:	0800bee1 	.word	0x0800bee1
 8008c6c:	0800be02 	.word	0x0800be02
 8008c70:	0800be42 	.word	0x0800be42
 8008c74:	0800befd 	.word	0x0800befd
 8008c78:	0800bf0d 	.word	0x0800bf0d
 8008c7c:	0800bf1d 	.word	0x0800bf1d
 8008c80:	0800bf01 	.word	0x0800bf01
 8008c84:	0800bb4f 	.word	0x0800bb4f
 8008c88:	0800bf05 	.word	0x0800bf05
 8008c8c:	0800bf09 	.word	0x0800bf09
 8008c90:	0800bf0b 	.word	0x0800bf0b
 8008c94:	0800bf29 	.word	0x0800bf29

08008c98 <gpioCPUStatus>:
{
 8008c98:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8008c9c:	460d      	mov	r5, r1
    chprintf(chp, "\tDriver: HAL (MM 0x%08x)"SHELL_NEWLINE_STR, (uint32_t)driver->driver);
 8008c9e:	6802      	ldr	r2, [r0, #0]
{
 8008ca0:	4606      	mov	r6, r0
    chprintf(chp, "\tDriver: HAL (MM 0x%08x)"SHELL_NEWLINE_STR, (uint32_t)driver->driver);
 8008ca2:	4915      	ldr	r1, [pc, #84]	; (8008cf8 <gpioCPUStatus+0x60>)
 8008ca4:	4628      	mov	r0, r5
 8008ca6:	f7ff fd18 	bl	80086da <chprintf>
 8008caa:	2400      	movs	r4, #0
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008cac:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8008cfc <gpioCPUStatus+0x64>
 8008cb0:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8008d00 <gpioCPUStatus+0x68>
        printfFixed(chp, 32, "\tPin %u (%s):",
 8008cb4:	4f13      	ldr	r7, [pc, #76]	; (8008d04 <gpioCPUStatus+0x6c>)
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008cb6:	4621      	mov	r1, r4
 8008cb8:	4630      	mov	r0, r6
 8008cba:	f7fd f8bd 	bl	8005e38 <gpioCPUGetPinMode>
    switch(mode) {
 8008cbe:	1e43      	subs	r3, r0, #1
 8008cc0:	b2db      	uxtb	r3, r3
 8008cc2:	2b10      	cmp	r3, #16
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008cc4:	bf8c      	ite	hi
 8008cc6:	4643      	movhi	r3, r8
 8008cc8:	f859 3023 	ldrls.w	r3, [r9, r3, lsl #2]
        printfFixed(chp, 32, "\tPin %u (%s):",
 8008ccc:	463a      	mov	r2, r7
 8008cce:	2120      	movs	r1, #32
 8008cd0:	9300      	str	r3, [sp, #0]
 8008cd2:	4628      	mov	r0, r5
 8008cd4:	4623      	mov	r3, r4
 8008cd6:	f7ff fea9 	bl	8008a2c <printfFixed>
        chprintf(chp,  "%u"SHELL_NEWLINE_STR, palReadPad((ioportid_t)driver->driver, i));
 8008cda:	6833      	ldr	r3, [r6, #0]
 8008cdc:	4628      	mov	r0, r5
 8008cde:	689a      	ldr	r2, [r3, #8]
 8008ce0:	4909      	ldr	r1, [pc, #36]	; (8008d08 <gpioCPUStatus+0x70>)
 8008ce2:	40e2      	lsrs	r2, r4
 8008ce4:	f002 0201 	and.w	r2, r2, #1
    for(uint8_t i=0; i<16; i++) {
 8008ce8:	3401      	adds	r4, #1
        chprintf(chp,  "%u"SHELL_NEWLINE_STR, palReadPad((ioportid_t)driver->driver, i));
 8008cea:	f7ff fcf6 	bl	80086da <chprintf>
    for(uint8_t i=0; i<16; i++) {
 8008cee:	2c10      	cmp	r4, #16
 8008cf0:	d1e1      	bne.n	8008cb6 <gpioCPUStatus+0x1e>
}
 8008cf2:	b003      	add	sp, #12
 8008cf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008cf8:	0800bf3a 	.word	0x0800bf3a
 8008cfc:	0800ba66 	.word	0x0800ba66
 8008d00:	0800c7c0 	.word	0x0800c7c0
 8008d04:	0800bf55 	.word	0x0800bf55
 8008d08:	0800c13c 	.word	0x0800c13c

08008d0c <syslog>:
};
static const BaseSequentialStream syslogStream = {.vmt = &syslogVMT};


void syslog(const char *format, ...)
{
 8008d0c:	b40f      	push	{r0, r1, r2, r3}
 8008d0e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    va_list args;
    va_start(args, format);

    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d10:	4d16      	ldr	r5, [pc, #88]	; (8008d6c <syslog+0x60>)
{
 8008d12:	ab06      	add	r3, sp, #24
 8008d14:	f853 6b04 	ldr.w	r6, [r3], #4
    queue->lenHeaderStart = queue->writePtr;
 8008d18:	4c15      	ldr	r4, [pc, #84]	; (8008d70 <syslog+0x64>)
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d1a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008d1e:	6828      	ldr	r0, [r5, #0]
    va_start(args, format);
 8008d20:	9301      	str	r3, [sp, #4]
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d22:	f7fc fb8d 	bl	8005440 <xQueueSemaphoreTake>
 8008d26:	6923      	ldr	r3, [r4, #16]
    packetQueueWriteByte(queue, 0x00);
 8008d28:	2000      	movs	r0, #0
    queue->lenHeaderStart = queue->writePtr;
 8008d2a:	61e3      	str	r3, [r4, #28]
    packetQueueWriteByte(queue, 0x00);
 8008d2c:	f7fd f92a 	bl	8005f84 <packetQueueWriteByte.constprop.0>
    packetQueueWriteByte(queue, 0x00);
 8008d30:	2000      	movs	r0, #0
 8008d32:	f7fd f927 	bl	8005f84 <packetQueueWriteByte.constprop.0>
    queue->pktLen = 0;
 8008d36:	2300      	movs	r3, #0
 8008d38:	61a3      	str	r3, [r4, #24]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8008d3a:	f7fd f8ef 	bl	8005f1c <vPortValidateInterruptPriority>
    packetQueueStartWritePacket(&syslogQueue);
    chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] ", osalOsGetSystemTimeX());
 8008d3e:	4c0d      	ldr	r4, [pc, #52]	; (8008d74 <syslog+0x68>)
		xReturn = xTickCount;
 8008d40:	4b0d      	ldr	r3, [pc, #52]	; (8008d78 <syslog+0x6c>)
 8008d42:	4620      	mov	r0, r4
 8008d44:	681a      	ldr	r2, [r3, #0]
 8008d46:	490d      	ldr	r1, [pc, #52]	; (8008d7c <syslog+0x70>)
 8008d48:	f7ff fcc7 	bl	80086da <chprintf>
    chvprintf((BaseSequentialStream*)&syslogStream, format, args);
 8008d4c:	4631      	mov	r1, r6
 8008d4e:	9a01      	ldr	r2, [sp, #4]
 8008d50:	4620      	mov	r0, r4
 8008d52:	f7fd fed3 	bl	8006afc <chvprintf>
    packetQueueEndWritePacket(&syslogQueue);
 8008d56:	f7fd f969 	bl	800602c <packetQueueEndWritePacket.constprop.0>
    xSemaphoreGive(syslogSemaphore);
 8008d5a:	6828      	ldr	r0, [r5, #0]
 8008d5c:	f7ff fb58 	bl	8008410 <xQueueGenericSend.constprop.0>

    va_end(args);
}
 8008d60:	b002      	add	sp, #8
 8008d62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8008d66:	b004      	add	sp, #16
 8008d68:	4770      	bx	lr
 8008d6a:	bf00      	nop
 8008d6c:	20001334 	.word	0x20001334
 8008d70:	20001310 	.word	0x20001310
 8008d74:	0800cb80 	.word	0x0800cb80
 8008d78:	20001648 	.word	0x20001648
 8008d7c:	0800bf63 	.word	0x0800bf63

08008d80 <shellTerminationCallback>:
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 8008d80:	4b0e      	ldr	r3, [pc, #56]	; (8008dbc <shellTerminationCallback+0x3c>)
{
 8008d82:	b570      	push	{r4, r5, r6, lr}
 8008d84:	681b      	ldr	r3, [r3, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 8008d86:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
    if(activeShell) {
 8008d88:	b1bc      	cbz	r4, 8008dba <shellTerminationCallback+0x3a>
        if(activeShell->shellCfg.sc_histbuf) {
 8008d8a:	68e0      	ldr	r0, [r4, #12]
 8008d8c:	b108      	cbz	r0, 8008d92 <shellTerminationCallback+0x12>
            vPortFree(activeShell->shellCfg.sc_histbuf);
 8008d8e:	f7fc fac1 	bl	8005314 <vPortFree>
        chprintf(activeShell->stream, "Shell 0x%08x closed.", activeShell);
 8008d92:	4622      	mov	r2, r4
 8008d94:	490a      	ldr	r1, [pc, #40]	; (8008dc0 <shellTerminationCallback+0x40>)
 8008d96:	6960      	ldr	r0, [r4, #20]
 8008d98:	f7ff fc9f 	bl	80086da <chprintf>
        syslog("Shell 0x%08x closed.", activeShell);
 8008d9c:	4808      	ldr	r0, [pc, #32]	; (8008dc0 <shellTerminationCallback+0x40>)
 8008d9e:	4621      	mov	r1, r4
 8008da0:	f7ff ffb4 	bl	8008d0c <syslog>
        void *param = activeShell->param;
 8008da4:	e9d4 5606 	ldrd	r5, r6, [r4, #24]
        vPortFree(activeShell);
 8008da8:	4620      	mov	r0, r4
 8008daa:	f7fc fab3 	bl	8005314 <vPortFree>
        if(callback) {
 8008dae:	b125      	cbz	r5, 8008dba <shellTerminationCallback+0x3a>
            callback(param);
 8008db0:	4630      	mov	r0, r6
 8008db2:	462b      	mov	r3, r5
}
 8008db4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            callback(param);
 8008db8:	4718      	bx	r3
}
 8008dba:	bd70      	pop	{r4, r5, r6, pc}
 8008dbc:	200011a8 	.word	0x200011a8
 8008dc0:	0800bf6c 	.word	0x0800bf6c
 8008dc4:	00000000 	.word	0x00000000

08008dc8 <max2870TuneNoLock>:
{
 8008dc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008dcc:	460c      	mov	r4, r1
 8008dce:	b08b      	sub	sp, #44	; 0x2c
 8008dd0:	4605      	mov	r5, r0
    uint32_t registers[6] = {};
 8008dd2:	2218      	movs	r2, #24
 8008dd4:	2100      	movs	r1, #0
 8008dd6:	a804      	add	r0, sp, #16
 8008dd8:	f002 fcf0 	bl	800b7bc <memset>
    uint64_t frequency = tune->frequency;
 8008ddc:	e9d4 6800 	ldrd	r6, r8, [r4]
    if(frequency == 0) {
 8008de0:	ea56 0308 	orrs.w	r3, r6, r8
 8008de4:	d107      	bne.n	8008df6 <max2870TuneNoLock+0x2e>
        max2870Disable(driver);
 8008de6:	4628      	mov	r0, r5
 8008de8:	f7ff fad8 	bl	800839c <max2870Disable>
        return TUNE_OK;
 8008dec:	2700      	movs	r7, #0
}
 8008dee:	4638      	mov	r0, r7
 8008df0:	b00b      	add	sp, #44	; 0x2c
 8008df2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(frequency > MAX2870_VCO_MAX_FREQUENCY || frequency < MAX2870_VCO_MIN_FREQUENCY/128) {
 8008df6:	4bae      	ldr	r3, [pc, #696]	; (80090b0 <max2870TuneNoLock+0x2e8>)
 8008df8:	49ae      	ldr	r1, [pc, #696]	; (80090b4 <max2870TuneNoLock+0x2ec>)
 8008dfa:	18f3      	adds	r3, r6, r3
 8008dfc:	f168 0200 	sbc.w	r2, r8, #0
 8008e00:	4299      	cmp	r1, r3
 8008e02:	f04f 0301 	mov.w	r3, #1
 8008e06:	4193      	sbcs	r3, r2
 8008e08:	f0c0 81c5 	bcc.w	8009196 <max2870TuneNoLock+0x3ce>
 8008e0c:	2700      	movs	r7, #0
    while(frequency < MAX2870_VCO_MIN_FREQUENCY) {
 8008e0e:	463b      	mov	r3, r7
 8008e10:	4aa9      	ldr	r2, [pc, #676]	; (80090b8 <max2870TuneNoLock+0x2f0>)
 8008e12:	42b2      	cmp	r2, r6
 8008e14:	eb73 0008 	sbcs.w	r0, r3, r8
 8008e18:	f107 0101 	add.w	r1, r7, #1
 8008e1c:	f080 80fd 	bcs.w	800901a <max2870TuneNoLock+0x252>
    uint32_t steps = frequency / driver->config->stepFrequency;
 8008e20:	f8d5 a000 	ldr.w	sl, [r5]
 8008e24:	2300      	movs	r3, #0
 8008e26:	f8da 2018 	ldr.w	r2, [sl, #24]
 8008e2a:	4630      	mov	r0, r6
 8008e2c:	4641      	mov	r1, r8
 8008e2e:	f7fa fccd 	bl	80037cc <__aeabi_uldivmod>
    uint32_t pllN = steps / driver->fracDivider;
 8008e32:	f8b5 90bc 	ldrh.w	r9, [r5, #188]	; 0xbc
    if(pllN < 16 || pllN > 4091) {
 8008e36:	f640 73eb 	movw	r3, #4075	; 0xfeb
    uint32_t pllN = steps / driver->fracDivider;
 8008e3a:	fbb0 f1f9 	udiv	r1, r0, r9
    if(pllN < 16 || pllN > 4091) {
 8008e3e:	f1a1 0c10 	sub.w	ip, r1, #16
 8008e42:	459c      	cmp	ip, r3
    uint32_t pllN = steps / driver->fracDivider;
 8008e44:	464a      	mov	r2, r9
    uint32_t steps = frequency / driver->config->stepFrequency;
 8008e46:	9001      	str	r0, [sp, #4]
    if(pllN < 16 || pllN > 4091) {
 8008e48:	f200 81a8 	bhi.w	800919c <max2870TuneNoLock+0x3d4>
    uint16_t pllFracF = steps - (pllN * driver->fracDivider);
 8008e4c:	fb01 0019 	mls	r0, r1, r9, r0
 8008e50:	b280      	uxth	r0, r0
    if(pllFracF) {
 8008e52:	2800      	cmp	r0, #0
 8008e54:	f000 80ef 	beq.w	8009036 <max2870TuneNoLock+0x26e>
        uint16_t pllFracGcd = gcd(pllFracF, pllFracM);
 8008e58:	4603      	mov	r3, r0
    if (v == 0) return u;
 8008e5a:	f1b9 0f00 	cmp.w	r9, #0
 8008e5e:	d018      	beq.n	8008e92 <max2870TuneNoLock+0xca>
    for (shift = 0; ((u | v) & 1) == 0; ++shift) {
 8008e60:	f04f 0c00 	mov.w	ip, #0
 8008e64:	ea43 0e02 	orr.w	lr, r3, r2
 8008e68:	f01e 0f01 	tst.w	lr, #1
 8008e6c:	f000 80da 	beq.w	8009024 <max2870TuneNoLock+0x25c>
    while ((u & 1) == 0) {
 8008e70:	f013 0f01 	tst.w	r3, #1
 8008e74:	f000 80db 	beq.w	800902e <max2870TuneNoLock+0x266>
        while ((v & 1) == 0) {
 8008e78:	f012 0f01 	tst.w	r2, #1
 8008e7c:	f000 80d9 	beq.w	8009032 <max2870TuneNoLock+0x26a>
        if (u > v) {
 8008e80:	429a      	cmp	r2, r3
 8008e82:	bf3e      	ittt	cc
 8008e84:	469e      	movcc	lr, r3
 8008e86:	4613      	movcc	r3, r2
 8008e88:	4672      	movcc	r2, lr
    } while (v != 0);
 8008e8a:	1ad2      	subs	r2, r2, r3
 8008e8c:	d1f4      	bne.n	8008e78 <max2870TuneNoLock+0xb0>
    return u << shift;
 8008e8e:	fa03 f30c 	lsl.w	r3, r3, ip
 8008e92:	b29b      	uxth	r3, r3
        pllFracM /= pllFracGcd;
 8008e94:	fbb9 f9f3 	udiv	r9, r9, r3
        pllFracF /= pllFracGcd;
 8008e98:	fbb0 f0f3 	udiv	r0, r0, r3
        registers[1] |= _BV(MAX2870_REG1_CPL_OFFSET);
 8008e9c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8008ea0:	9305      	str	r3, [sp, #20]
    registers[0] |= pllN << MAX2870_REG0_N_OFFSET;
 8008ea2:	9b04      	ldr	r3, [sp, #16]
    registers[2] |= driver->refDividerRegister2;
 8008ea4:	f8d5 20c0 	ldr.w	r2, [r5, #192]	; 0xc0
    registers[0] |= pllN << MAX2870_REG0_N_OFFSET;
 8008ea8:	ea43 33c1 	orr.w	r3, r3, r1, lsl #15
    registers[0] |= pllFracF << MAX2870_REG0_FRAC_OFFSET;
 8008eac:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
    registers[1] |= pllFracM << MAX2870_REG1_M_OFFSET;
 8008eb0:	9b05      	ldr	r3, [sp, #20]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008eb2:	b2ff      	uxtb	r7, r7
    registers[1] |= pllFracM << MAX2870_REG1_M_OFFSET;
 8008eb4:	ea43 03c9 	orr.w	r3, r3, r9, lsl #3
 8008eb8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008ebc:	9305      	str	r3, [sp, #20]
    registers[2] |= driver->refDividerRegister2;
 8008ebe:	9b06      	ldr	r3, [sp, #24]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008ec0:	ea4f 5b07 	mov.w	fp, r7, lsl #20
    registers[2] |= driver->refDividerRegister2;
 8008ec4:	4313      	orrs	r3, r2
    registers[2] |= 0x6 <<  MAX2870_REG2_MUX_OFFSET;
 8008ec6:	f043 52c0 	orr.w	r2, r3, #402653184	; 0x18000000
 8008eca:	9206      	str	r2, [sp, #24]
    if(!driver->config->invertingLoopFilter) {
 8008ecc:	f89a 200a 	ldrb.w	r2, [sl, #10]
    registers[0] |= pllFracF << MAX2870_REG0_FRAC_OFFSET;
 8008ed0:	9004      	str	r0, [sp, #16]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008ed2:	f8cd b020 	str.w	fp, [sp, #32]
    if(!driver->config->invertingLoopFilter) {
 8008ed6:	b922      	cbnz	r2, 8008ee2 <max2870TuneNoLock+0x11a>
        registers[2] |= _BV(MAX2870_REG2_PDP_OFFSET);
 8008ed8:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8008edc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008ee0:	9306      	str	r3, [sp, #24]
    registers[2] |= driver->config->chargePumpCurrent << MAX2870_REG2_CP_OFFSET;
 8008ee2:	f89a 200b 	ldrb.w	r2, [sl, #11]
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008ee6:	f89a 100c 	ldrb.w	r1, [sl, #12]
    registers[2] |= driver->config->chargePumpCurrent << MAX2870_REG2_CP_OFFSET;
 8008eea:	0253      	lsls	r3, r2, #9
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008eec:	ea43 7341 	orr.w	r3, r3, r1, lsl #29
 8008ef0:	9906      	ldr	r1, [sp, #24]
    if(driver->pfdFrequency > 32000000) {
 8008ef2:	4872      	ldr	r0, [pc, #456]	; (80090bc <max2870TuneNoLock+0x2f4>)
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008ef4:	430b      	orrs	r3, r1
    if(driver->pfdFrequency > 32000000) {
 8008ef6:	f8d5 10b8 	ldr.w	r1, [r5, #184]	; 0xb8
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008efa:	9306      	str	r3, [sp, #24]
    if(driver->pfdFrequency > 32000000) {
 8008efc:	4281      	cmp	r1, r0
    if(tune->fastLockDurationMicroseconds) {
 8008efe:	68e0      	ldr	r0, [r4, #12]
        registers[2] |= _BV(MAX2870_REG2_LDS_OFFSET);
 8008f00:	bf84      	itt	hi
 8008f02:	f043 4300 	orrhi.w	r3, r3, #2147483648	; 0x80000000
 8008f06:	9306      	strhi	r3, [sp, #24]
    if(tune->fastLockDurationMicroseconds) {
 8008f08:	b1a0      	cbz	r0, 8008f34 <max2870TuneNoLock+0x16c>
        if(driver->config->chargePumpCurrent) {
 8008f0a:	2a00      	cmp	r2, #0
 8008f0c:	f040 8149 	bne.w	80091a2 <max2870TuneNoLock+0x3da>
        uint32_t tmp = (uint64_t)driver->pfdFrequency * (uint64_t)tune->fastLockDurationMicroseconds / 1000000;
 8008f10:	2300      	movs	r3, #0
 8008f12:	fba1 0100 	umull	r0, r1, r1, r0
 8008f16:	4a6a      	ldr	r2, [pc, #424]	; (80090c0 <max2870TuneNoLock+0x2f8>)
 8008f18:	f7fa fc58 	bl	80037cc <__aeabi_uldivmod>
        tmp /= pllFracM;
 8008f1c:	fbb0 f3f9 	udiv	r3, r0, r9
        if(tmp>4095) {
 8008f20:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8008f24:	f080 808f 	bcs.w	8009046 <max2870TuneNoLock+0x27e>
        if(tmp) {
 8008f28:	4581      	cmp	r9, r0
 8008f2a:	d803      	bhi.n	8008f34 <max2870TuneNoLock+0x16c>
            registers[3] |= tmp << MAX2870_REG3_CDIV_OFFSET;
 8008f2c:	00db      	lsls	r3, r3, #3
 8008f2e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008f32:	9307      	str	r3, [sp, #28]
    if(!tune->outBfundamental) {
 8008f34:	7aa3      	ldrb	r3, [r4, #10]
 8008f36:	b913      	cbnz	r3, 8008f3e <max2870TuneNoLock+0x176>
        registers[4] |= _BV(MAX2870_REG4_BDIV_OFFSET);
 8008f38:	f44b 7300 	orr.w	r3, fp, #512	; 0x200
 8008f3c:	9308      	str	r3, [sp, #32]
    registers[4] |= (driver->bsValue & 0xFF) << MAX2870_REG4_BS_OFFSET;
 8008f3e:	f8b5 20c4 	ldrh.w	r2, [r5, #196]	; 0xc4
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008f42:	4860      	ldr	r0, [pc, #384]	; (80090c4 <max2870TuneNoLock+0x2fc>)
    registers[4] |= (driver->bsValue & 0xFF) << MAX2870_REG4_BS_OFFSET;
 8008f44:	0313      	lsls	r3, r2, #12
 8008f46:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
    registers[4] |= (driver->bsValue >> 8) << MAX2870_REG4_BS_MSB_OFFSET;
 8008f4a:	0a12      	lsrs	r2, r2, #8
 8008f4c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8008f50:	9a08      	ldr	r2, [sp, #32]
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008f52:	1830      	adds	r0, r6, r0
    registers[4] |= (driver->bsValue >> 8) << MAX2870_REG4_BS_MSB_OFFSET;
 8008f54:	ea43 0302 	orr.w	r3, r3, r2
    registers[4] |= _BV(MAX2870_REG4_FB_OFFSET);
 8008f58:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8008f5c:	9308      	str	r3, [sp, #32]
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008f5e:	f168 0100 	sbc.w	r1, r8, #0
 8008f62:	a351      	add	r3, pc, #324	; (adr r3, 80090a8 <max2870TuneNoLock+0x2e0>)
 8008f64:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f68:	f7fa fc30 	bl	80037cc <__aeabi_uldivmod>
    if((driver->vcoCache[vcoIndex] & 0x80) && !tune->useVCOAutotune) {
 8008f6c:	eb05 0900 	add.w	r9, r5, r0
 8008f70:	f999 3020 	ldrsb.w	r3, [r9, #32]
 8008f74:	f899 2020 	ldrb.w	r2, [r9, #32]
 8008f78:	2b00      	cmp	r3, #0
 8008f7a:	da67      	bge.n	800904c <max2870TuneNoLock+0x284>
 8008f7c:	7c26      	ldrb	r6, [r4, #16]
 8008f7e:	b92e      	cbnz	r6, 8008f8c <max2870TuneNoLock+0x1c4>
        registers[3] |= (driver->vcoCache[vcoIndex] & 0x3F) << MAX2870_REG3_VCO_OFFSET;
 8008f80:	9b07      	ldr	r3, [sp, #28]
 8008f82:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
        registers[3] |= _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 8008f86:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8008f8a:	9307      	str	r3, [sp, #28]
    if(!driver->enabled) {
 8008f8c:	792b      	ldrb	r3, [r5, #4]
 8008f8e:	b99b      	cbnz	r3, 8008fb8 <max2870TuneNoLock+0x1f0>
        if(driver->config->gpioChipEnable != 0xffff) {
 8008f90:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008f94:	f8ba 0008 	ldrh.w	r0, [sl, #8]
 8008f98:	4298      	cmp	r0, r3
 8008f9a:	d005      	beq.n	8008fa8 <max2870TuneNoLock+0x1e0>
            gpioSetPin(driver->config->gpioChipEnable, true);
 8008f9c:	2101      	movs	r1, #1
 8008f9e:	f7fe fae5 	bl	800756c <gpioSetPin.isra.0>
            osalThreadSleepMilliseconds(20);
 8008fa2:	2014      	movs	r0, #20
 8008fa4:	f7fc f9f0 	bl	8005388 <vTaskDelay>
        max2870WriteAllRegisters(driver, registers, true);
 8008fa8:	4628      	mov	r0, r5
 8008faa:	2201      	movs	r2, #1
 8008fac:	a904      	add	r1, sp, #16
 8008fae:	f7ff fa0f 	bl	80083d0 <max2870WriteAllRegisters.isra.0>
        osalThreadSleepMilliseconds(20);
 8008fb2:	2014      	movs	r0, #20
 8008fb4:	f7fc f9e8 	bl	8005388 <vTaskDelay>
        *power = -4;
 8008fb8:	f04f 0afc 	mov.w	sl, #252	; 0xfc
        *power = 2;
 8008fbc:	f04f 0b02 	mov.w	fp, #2
    if(*power < -4) {
 8008fc0:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8008fc4:	1d18      	adds	r0, r3, #4
 8008fc6:	da43      	bge.n	8009050 <max2870TuneNoLock+0x288>
        *power = -127;
 8008fc8:	2381      	movs	r3, #129	; 0x81
        return registerValue;
 8008fca:	2200      	movs	r2, #0
        *power = -127;
 8008fcc:	7223      	strb	r3, [r4, #8]
        registers[4] |= max2870PowerToRegister(&tune->powerA) << MAX2870_REG4_APWR_OFFSET;
 8008fce:	9b08      	ldr	r3, [sp, #32]
 8008fd0:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
    if(*power < -4) {
 8008fd4:	f994 2009 	ldrsb.w	r2, [r4, #9]
 8008fd8:	1d11      	adds	r1, r2, #4
 8008fda:	da4f      	bge.n	800907c <max2870TuneNoLock+0x2b4>
        *power = -127;
 8008fdc:	2281      	movs	r2, #129	; 0x81
 8008fde:	7262      	strb	r2, [r4, #9]
        return registerValue;
 8008fe0:	2200      	movs	r2, #0
        registers[4] |= max2870PowerToRegister(&tune->powerB) << MAX2870_REG4_BPWR_OFFSET;
 8008fe2:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8008fe6:	9308      	str	r3, [sp, #32]
        if(driver->pllMonReloadCounter >= 20) {
 8008fe8:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 8008fec:	4628      	mov	r0, r5
        if(driver->pllMonReloadCounter >= 20) {
 8008fee:	2b13      	cmp	r3, #19
            driver->pllMonReloadCounter = 0;
 8008ff0:	bf89      	itett	hi
 8008ff2:	2300      	movhi	r3, #0
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 8008ff4:	792a      	ldrbls	r2, [r5, #4]
            max2870WriteAllRegisters(driver, registers, true);
 8008ff6:	2201      	movhi	r2, #1
            driver->pllMonReloadCounter = 0;
 8008ff8:	f885 30e4 	strbhi.w	r3, [r5, #228]	; 0xe4
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 8008ffc:	bf98      	it	ls
 8008ffe:	f082 0201 	eorls.w	r2, r2, #1
 8009002:	a904      	add	r1, sp, #16
 8009004:	f7ff f9e4 	bl	80083d0 <max2870WriteAllRegisters.isra.0>
    registerValue = _BV(2); /* Output enabled */
 8009008:	f04f 0800 	mov.w	r8, #0
            spiReceive(driver->config->spiPort, sizeof(lock), &lock);
 800900c:	682a      	ldr	r2, [r5, #0]
 800900e:	6810      	ldr	r0, [r2, #0]
  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));
 8009010:	2800      	cmp	r0, #0
 8009012:	d159      	bne.n	80090c8 <max2870TuneNoLock+0x300>
 8009014:	f7fb fcd6 	bl	80049c4 <vTaskEndScheduler>
 8009018:	e7fe      	b.n	8009018 <max2870TuneNoLock+0x250>
        frequency *= 2;
 800901a:	19b6      	adds	r6, r6, r6
 800901c:	460f      	mov	r7, r1
 800901e:	eb48 0808 	adc.w	r8, r8, r8
        outDivide++;
 8009022:	e6f6      	b.n	8008e12 <max2870TuneNoLock+0x4a>
        u >>= 1;
 8009024:	085b      	lsrs	r3, r3, #1
        v >>= 1;
 8009026:	0852      	lsrs	r2, r2, #1
    for (shift = 0; ((u | v) & 1) == 0; ++shift) {
 8009028:	f10c 0c01 	add.w	ip, ip, #1
 800902c:	e71a      	b.n	8008e64 <max2870TuneNoLock+0x9c>
        u >>= 1;
 800902e:	085b      	lsrs	r3, r3, #1
 8009030:	e71e      	b.n	8008e70 <max2870TuneNoLock+0xa8>
            v >>= 1;
 8009032:	0852      	lsrs	r2, r2, #1
 8009034:	e720      	b.n	8008e78 <max2870TuneNoLock+0xb0>
        registers[0] |= _BV(MAX2870_REG0_INT_OFFSET);
 8009036:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
        registers[1] |= _BV(MAX2870_REG1_CPOC_OFFSET);
 800903a:	e9cd 3304 	strd	r3, r3, [sp, #16]
        registers[2] |= _BV(MAX2870_REG2_LDF_OFFSET);
 800903e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009042:	9306      	str	r3, [sp, #24]
 8009044:	e72d      	b.n	8008ea2 <max2870TuneNoLock+0xda>
            tmp = 4095;
 8009046:	f640 73ff 	movw	r3, #4095	; 0xfff
 800904a:	e76f      	b.n	8008f2c <max2870TuneNoLock+0x164>
    bool vcoAutoTune = true;
 800904c:	2601      	movs	r6, #1
 800904e:	e79d      	b.n	8008f8c <max2870TuneNoLock+0x1c4>
    if(*power >= 5) {
 8009050:	2b04      	cmp	r3, #4
 8009052:	dd03      	ble.n	800905c <max2870TuneNoLock+0x294>
        *power = 5;
 8009054:	2305      	movs	r3, #5
        registerValue |= 3;
 8009056:	2207      	movs	r2, #7
        *power = 5;
 8009058:	7223      	strb	r3, [r4, #8]
        registerValue |= 3;
 800905a:	e7b8      	b.n	8008fce <max2870TuneNoLock+0x206>
    } else if(*power >= 2) {
 800905c:	2b01      	cmp	r3, #1
 800905e:	dd03      	ble.n	8009068 <max2870TuneNoLock+0x2a0>
        registerValue |= 2;
 8009060:	2206      	movs	r2, #6
        *power = 2;
 8009062:	f884 b008 	strb.w	fp, [r4, #8]
        registerValue |= 2;
 8009066:	e7b2      	b.n	8008fce <max2870TuneNoLock+0x206>
    } else if(*power >= -1) {
 8009068:	3301      	adds	r3, #1
        *power = -1;
 800906a:	bfa5      	ittet	ge
 800906c:	23ff      	movge	r3, #255	; 0xff
        registerValue |= 1;
 800906e:	2205      	movge	r2, #5
    registerValue = _BV(2); /* Output enabled */
 8009070:	2204      	movlt	r2, #4
        *power = -1;
 8009072:	7223      	strbge	r3, [r4, #8]
        *power = -4;
 8009074:	bfb8      	it	lt
 8009076:	f884 a008 	strblt.w	sl, [r4, #8]
 800907a:	e7a8      	b.n	8008fce <max2870TuneNoLock+0x206>
    if(*power >= 5) {
 800907c:	2a04      	cmp	r2, #4
 800907e:	dd03      	ble.n	8009088 <max2870TuneNoLock+0x2c0>
        *power = 5;
 8009080:	2205      	movs	r2, #5
 8009082:	7262      	strb	r2, [r4, #9]
        registerValue |= 3;
 8009084:	2207      	movs	r2, #7
 8009086:	e7ac      	b.n	8008fe2 <max2870TuneNoLock+0x21a>
    } else if(*power >= 2) {
 8009088:	2a01      	cmp	r2, #1
 800908a:	dd03      	ble.n	8009094 <max2870TuneNoLock+0x2cc>
        registerValue |= 2;
 800908c:	2206      	movs	r2, #6
        *power = 2;
 800908e:	f884 b009 	strb.w	fp, [r4, #9]
        registerValue |= 2;
 8009092:	e7a6      	b.n	8008fe2 <max2870TuneNoLock+0x21a>
    } else if(*power >= -1) {
 8009094:	3201      	adds	r2, #1
        *power = -1;
 8009096:	bfab      	itete	ge
 8009098:	22ff      	movge	r2, #255	; 0xff
    registerValue = _BV(2); /* Output enabled */
 800909a:	2204      	movlt	r2, #4
        *power = -1;
 800909c:	7262      	strbge	r2, [r4, #9]
        *power = -4;
 800909e:	f884 a009 	strblt.w	sl, [r4, #9]
        registerValue |= 1;
 80090a2:	bfa8      	it	ge
 80090a4:	2205      	movge	r2, #5
        *power = -4;
 80090a6:	e79c      	b.n	8008fe2 <max2870TuneNoLock+0x21a>
 80090a8:	01312d00 	.word	0x01312d00
 80090ac:	00000000 	.word	0x00000000
 80090b0:	fe9a5f44 	.word	0xfe9a5f44
 80090b4:	643b1b44 	.word	0x643b1b44
 80090b8:	b2d05dff 	.word	0xb2d05dff
 80090bc:	01e84800 	.word	0x01e84800
 80090c0:	000f4240 	.word	0x000f4240
 80090c4:	4d2fa200 	.word	0x4d2fa200
 80090c8:	2102      	movs	r1, #2
 80090ca:	f10d 020e 	add.w	r2, sp, #14
 80090ce:	f7fd faa7 	bl	8006620 <spiReceive.part.0>
            if(timeoutCnt == 255) {
 80090d2:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 80090d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80090da:	d148      	bne.n	800916e <max2870TuneNoLock+0x3a6>
                if(!vcoAutoTune) {
 80090dc:	b9d6      	cbnz	r6, 8009114 <max2870TuneNoLock+0x34c>
                    registers[3] &=~ _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 80090de:	9b07      	ldr	r3, [sp, #28]
    } while(lock != 0xFFFF);
 80090e0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
                    registers[3] &=~ _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 80090e4:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80090e8:	9307      	str	r3, [sp, #28]
    } while(lock != 0xFFFF);
 80090ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80090ee:	429a      	cmp	r2, r3
                    driver->vcoCache[vcoIndex] = 0;
 80090f0:	f889 6020 	strb.w	r6, [r9, #32]
                    vcoAutoTune = true;
 80090f4:	f04f 0601 	mov.w	r6, #1
    } while(lock != 0xFFFF);
 80090f8:	f47f af62 	bne.w	8008fc0 <max2870TuneNoLock+0x1f8>
    for(int i=0; i<outDivide; i++) {
 80090fc:	2100      	movs	r1, #0
    tune->frequency = ((uint64_t)steps * (uint64_t)driver->config->stepFrequency);
 80090fe:	682b      	ldr	r3, [r5, #0]
 8009100:	9a01      	ldr	r2, [sp, #4]
 8009102:	699b      	ldr	r3, [r3, #24]
 8009104:	fba3 2302 	umull	r2, r3, r3, r2
 8009108:	e9c4 2300 	strd	r2, r3, [r4]
    for(int i=0; i<outDivide; i++) {
 800910c:	428f      	cmp	r7, r1
 800910e:	dc38      	bgt.n	8009182 <max2870TuneNoLock+0x3ba>
    MAX2870TuneResult result = TUNE_OK;
 8009110:	2700      	movs	r7, #0
 8009112:	e004      	b.n	800911e <max2870TuneNoLock+0x356>
                    syslog("MAX2870 Tuning failed.");
 8009114:	4824      	ldr	r0, [pc, #144]	; (80091a8 <max2870TuneNoLock+0x3e0>)
 8009116:	f7ff fdf9 	bl	8008d0c <syslog>
                    result = TUNE_NOT_LOCKED;
 800911a:	f06f 0703 	mvn.w	r7, #3
    reg6 = max2870ReadRegister6(driver);
 800911e:	4628      	mov	r0, r5
 8009120:	f7ff f8e8 	bl	80082f4 <max2870ReadRegister6>
    if(vcoAutoTune && result==TUNE_OK) {
 8009124:	0843      	lsrs	r3, r0, #1
 8009126:	b136      	cbz	r6, 8009136 <max2870TuneNoLock+0x36e>
 8009128:	b92f      	cbnz	r7, 8009136 <max2870TuneNoLock+0x36e>
        driver->vcoCache[vcoIndex] = 0x80 | ((reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F);
 800912a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800912e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8009132:	f889 2020 	strb.w	r2, [r9, #32]
    tune->adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 8009136:	f3c0 4082 	ubfx	r0, r0, #18, #3
 800913a:	74a0      	strb	r0, [r4, #18]
    tune->isLocked = (result == TUNE_OK);
 800913c:	fab7 f087 	clz	r0, r7
    tune->usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 8009140:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009144:	7463      	strb	r3, [r4, #17]
    tune->lockTime = timeoutCnt;
 8009146:	f884 8013 	strb.w	r8, [r4, #19]
    if(driver->config->lockStatus) {
 800914a:	682b      	ldr	r3, [r5, #0]
    tune->isLocked = (result == TUNE_OK);
 800914c:	0940      	lsrs	r0, r0, #5
    if(driver->config->lockStatus) {
 800914e:	69db      	ldr	r3, [r3, #28]
    tune->usedVCOAutotune = vcoAutoTune;
 8009150:	7566      	strb	r6, [r4, #21]
    tune->isLocked = (result == TUNE_OK);
 8009152:	7520      	strb	r0, [r4, #20]
    if(driver->config->lockStatus) {
 8009154:	b103      	cbz	r3, 8009158 <max2870TuneNoLock+0x390>
        driver->config->lockStatus(tune->isLocked);
 8009156:	4798      	blx	r3
    driver->enabled = true;
 8009158:	2301      	movs	r3, #1
    driver->currentTune = *tune;
 800915a:	3508      	adds	r5, #8
    driver->enabled = true;
 800915c:	f805 3c04 	strb.w	r3, [r5, #-4]
    driver->currentTune = *tune;
 8009160:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8009162:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8009164:	e894 0003 	ldmia.w	r4, {r0, r1}
 8009168:	e885 0003 	stmia.w	r5, {r0, r1}
    return result;
 800916c:	e63f      	b.n	8008dee <max2870TuneNoLock+0x26>
        } while(lock != 0xFFFF);
 800916e:	f8bd 200e 	ldrh.w	r2, [sp, #14]
            timeoutCnt++;
 8009172:	f108 0801 	add.w	r8, r8, #1
        } while(lock != 0xFFFF);
 8009176:	429a      	cmp	r2, r3
            timeoutCnt++;
 8009178:	fa5f f888 	uxtb.w	r8, r8
        } while(lock != 0xFFFF);
 800917c:	f47f af46 	bne.w	800900c <max2870TuneNoLock+0x244>
 8009180:	e7bc      	b.n	80090fc <max2870TuneNoLock+0x334>
        tune->frequency /= 2;
 8009182:	e9d4 3200 	ldrd	r3, r2, [r4]
 8009186:	085b      	lsrs	r3, r3, #1
 8009188:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
 800918c:	0852      	lsrs	r2, r2, #1
 800918e:	e9c4 3200 	strd	r3, r2, [r4]
    for(int i=0; i<outDivide; i++) {
 8009192:	3101      	adds	r1, #1
 8009194:	e7ba      	b.n	800910c <max2870TuneNoLock+0x344>
        return TUNE_FREQUENCY_OUT_OF_RANGE;
 8009196:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800919a:	e628      	b.n	8008dee <max2870TuneNoLock+0x26>
        return TUNE_PLL_N_OUT_OF_RANGE;
 800919c:	f06f 0701 	mvn.w	r7, #1
 80091a0:	e625      	b.n	8008dee <max2870TuneNoLock+0x26>
            return TUNE_CANT_FASTLOCK;
 80091a2:	f06f 0702 	mvn.w	r7, #2
 80091a6:	e622      	b.n	8008dee <max2870TuneNoLock+0x26>
 80091a8:	0800bf81 	.word	0x0800bf81

080091ac <max2870DoMonitorTask>:
{
 80091ac:	b538      	push	{r3, r4, r5, lr}
 80091ae:	4604      	mov	r4, r0
    max2870SpiState(driver, true);
 80091b0:	f7fe ff80 	bl	80080b4 <max2870SpiState.constprop.0>
    if(driver->enabled) {
 80091b4:	7925      	ldrb	r5, [r4, #4]
 80091b6:	b165      	cbz	r5, 80091d2 <max2870DoMonitorTask+0x26>
        if(driver->pllMonReloadCounter >= 29) {
 80091b8:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
 80091bc:	2b1c      	cmp	r3, #28
 80091be:	d90d      	bls.n	80091dc <max2870DoMonitorTask+0x30>
            max2870WriteAllRegisters(driver, driver->registers, true);
 80091c0:	2201      	movs	r2, #1
 80091c2:	4620      	mov	r0, r4
 80091c4:	f104 01c8 	add.w	r1, r4, #200	; 0xc8
 80091c8:	f7ff f902 	bl	80083d0 <max2870WriteAllRegisters.isra.0>
            driver->pllMonReloadCounter = 0;
 80091cc:	2300      	movs	r3, #0
 80091ce:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
    if(enable) {
 80091d2:	4620      	mov	r0, r4
 80091d4:	f7ff fa3c 	bl	8008650 <max2870SpiState.part.0>
}
 80091d8:	4628      	mov	r0, r5
 80091da:	bd38      	pop	{r3, r4, r5, pc}
            driver->pllMonReloadCounter++;
 80091dc:	3301      	adds	r3, #1
 80091de:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
            uint32_t reg6 = max2870ReadRegister6(driver);
 80091e2:	4620      	mov	r0, r4
 80091e4:	f7ff f886 	bl	80082f4 <max2870ReadRegister6>
            driver->currentTune.adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 80091e8:	f3c0 4382 	ubfx	r3, r0, #18, #3
            driver->currentTune.usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 80091ec:	f3c0 0045 	ubfx	r0, r0, #1, #6
            driver->currentTune.adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 80091f0:	76a3      	strb	r3, [r4, #26]
            driver->currentTune.usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 80091f2:	7660      	strb	r0, [r4, #25]
            if(driver->currentTune.adcVoltage == 0 ||
 80091f4:	b11b      	cbz	r3, 80091fe <max2870DoMonitorTask+0x52>
 80091f6:	2b07      	cmp	r3, #7
 80091f8:	d001      	beq.n	80091fe <max2870DoMonitorTask+0x52>
                    !driver->currentTune.isLocked) {
 80091fa:	7f23      	ldrb	r3, [r4, #28]
                    driver->currentTune.adcVoltage == 7 ||
 80091fc:	b953      	cbnz	r3, 8009214 <max2870DoMonitorTask+0x68>
                syslog("MAX2870 Lost lock, retuning.");
 80091fe:	4806      	ldr	r0, [pc, #24]	; (8009218 <max2870DoMonitorTask+0x6c>)
 8009200:	f7ff fd84 	bl	8008d0c <syslog>
                driver->currentTune.useVCOAutotune = true;
 8009204:	2301      	movs	r3, #1
                max2870TuneNoLock(driver, &driver->currentTune);
 8009206:	4620      	mov	r0, r4
                driver->currentTune.useVCOAutotune = true;
 8009208:	7623      	strb	r3, [r4, #24]
                max2870TuneNoLock(driver, &driver->currentTune);
 800920a:	f104 0108 	add.w	r1, r4, #8
 800920e:	f7ff fddb 	bl	8008dc8 <max2870TuneNoLock>
 8009212:	e7de      	b.n	80091d2 <max2870DoMonitorTask+0x26>
        didWork = true;
 8009214:	461d      	mov	r5, r3
 8009216:	e7dc      	b.n	80091d2 <max2870DoMonitorTask+0x26>
 8009218:	0800bf98 	.word	0x0800bf98

0800921c <max2870Tune>:
{
 800921c:	b538      	push	{r3, r4, r5, lr}
 800921e:	4604      	mov	r4, r0
 8009220:	460d      	mov	r5, r1
    max2870SpiState(driver, true);
 8009222:	f7fe ff47 	bl	80080b4 <max2870SpiState.constprop.0>
    MAX2870TuneResult result = max2870TuneNoLock(driver, tune);
 8009226:	4629      	mov	r1, r5
 8009228:	4620      	mov	r0, r4
 800922a:	f7ff fdcd 	bl	8008dc8 <max2870TuneNoLock>
 800922e:	4605      	mov	r5, r0
    if(enable) {
 8009230:	4620      	mov	r0, r4
 8009232:	f7ff fa0d 	bl	8008650 <max2870SpiState.part.0>
}
 8009236:	4628      	mov	r0, r5
 8009238:	bd38      	pop	{r3, r4, r5, pc}
	...

0800923c <converterSHFLoTune>:
{
 800923c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    tune.fastLockDurationMicroseconds = 0;
 800923e:	2300      	movs	r3, #0
 8009240:	9303      	str	r3, [sp, #12]
    tune.useVCOAutotune = false;
 8009242:	f88d 3010 	strb.w	r3, [sp, #16]
    tune.powerB = -127;
 8009246:	2381      	movs	r3, #129	; 0x81
 8009248:	f88d 3009 	strb.w	r3, [sp, #9]
    tune.frequency = (uint64_t)freqKHz * 1000;
 800924c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009250:	fba0 0303 	umull	r0, r3, r0, r3
    tune.powerA = power;
 8009254:	f88d 1008 	strb.w	r1, [sp, #8]
    tune.frequency = (uint64_t)freqKHz * 1000;
 8009258:	e9cd 0300 	strd	r0, r3, [sp]
    return max2870Tune(&loPLL, &tune) == TUNE_OK;
 800925c:	4669      	mov	r1, sp
 800925e:	4804      	ldr	r0, [pc, #16]	; (8009270 <converterSHFLoTune+0x34>)
 8009260:	f7ff ffdc 	bl	800921c <max2870Tune>
}
 8009264:	fab0 f080 	clz	r0, r0
 8009268:	0940      	lsrs	r0, r0, #5
 800926a:	b007      	add	sp, #28
 800926c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009270:	20001098 	.word	0x20001098
 8009274:	00000000 	.word	0x00000000

08009278 <max2870VcoPrecal>:
{
 8009278:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800927c:	b08d      	sub	sp, #52	; 0x34
    MAX2870TuneRequest previousTune = driver->currentTune;
 800927e:	ad06      	add	r5, sp, #24
 8009280:	f100 0608 	add.w	r6, r0, #8
{
 8009284:	4604      	mov	r4, r0
    bool pllWasEnabled = driver->enabled;
 8009286:	7907      	ldrb	r7, [r0, #4]
    MAX2870TuneRequest previousTune = driver->currentTune;
 8009288:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800928a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800928c:	e896 0003 	ldmia.w	r6, {r0, r1}
 8009290:	e885 0003 	stmia.w	r5, {r0, r1}
    tune.useVCOAutotune = true;
 8009294:	2501      	movs	r5, #1
    MAX2870TuneRequest tune = {};
 8009296:	2218      	movs	r2, #24
 8009298:	2100      	movs	r1, #0
 800929a:	4668      	mov	r0, sp
 800929c:	f002 fa8e 	bl	800b7bc <memset>
    tune.powerA = -127;
 80092a0:	f248 1381 	movw	r3, #33153	; 0x8181
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 80092a4:	46a8      	mov	r8, r5
    max2870SpiState(driver, true);
 80092a6:	4620      	mov	r0, r4
    tune.powerA = -127;
 80092a8:	f8ad 3008 	strh.w	r3, [sp, #8]
    tune.useVCOAutotune = true;
 80092ac:	f88d 5010 	strb.w	r5, [sp, #16]
    max2870SpiState(driver, true);
 80092b0:	f7fe ff00 	bl	80080b4 <max2870SpiState.constprop.0>
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 80092b4:	a31c      	add	r3, pc, #112	; (adr r3, 8009328 <max2870VcoPrecal+0xb0>)
 80092b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80092ba:	e9cd 2300 	strd	r2, r3, [sp]
            tune.frequency += MAX2870_VCO_INCREMENT) {
 80092be:	4e18      	ldr	r6, [pc, #96]	; (8009320 <max2870VcoPrecal+0xa8>)
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 80092c0:	f8df 9060 	ldr.w	r9, [pc, #96]	; 8009324 <max2870VcoPrecal+0xac>
        if(max2870TuneNoLock(driver, &tune)) {
 80092c4:	4669      	mov	r1, sp
 80092c6:	4620      	mov	r0, r4
 80092c8:	f7ff fd7e 	bl	8008dc8 <max2870TuneNoLock>
            tune.frequency += MAX2870_VCO_INCREMENT) {
 80092cc:	9b00      	ldr	r3, [sp, #0]
 80092ce:	9a01      	ldr	r2, [sp, #4]
            allGood = false;
 80092d0:	2800      	cmp	r0, #0
 80092d2:	bf18      	it	ne
 80092d4:	2500      	movne	r5, #0
            tune.frequency += MAX2870_VCO_INCREMENT) {
 80092d6:	199b      	adds	r3, r3, r6
 80092d8:	f142 0200 	adc.w	r2, r2, #0
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 80092dc:	4599      	cmp	r9, r3
            tune.frequency += MAX2870_VCO_INCREMENT) {
 80092de:	e9cd 3200 	strd	r3, r2, [sp]
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 80092e2:	eb78 0302 	sbcs.w	r3, r8, r2
 80092e6:	d2ed      	bcs.n	80092c4 <max2870VcoPrecal+0x4c>
    if(!pllWasEnabled) {
 80092e8:	b997      	cbnz	r7, 8009310 <max2870VcoPrecal+0x98>
        max2870Disable(driver);
 80092ea:	4620      	mov	r0, r4
 80092ec:	f7ff f856 	bl	800839c <max2870Disable>
    if(driver->vcoCache[0] >= 0x9f ||
 80092f0:	f894 3020 	ldrb.w	r3, [r4, #32]
 80092f4:	2b9e      	cmp	r3, #158	; 0x9e
 80092f6:	d810      	bhi.n	800931a <max2870VcoPrecal+0xa2>
 80092f8:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
    	allGood = false;
 80092fc:	2b9f      	cmp	r3, #159	; 0x9f
 80092fe:	bf98      	it	ls
 8009300:	2500      	movls	r5, #0
    if(enable) {
 8009302:	4620      	mov	r0, r4
 8009304:	f7ff f9a4 	bl	8008650 <max2870SpiState.part.0>
}
 8009308:	4628      	mov	r0, r5
 800930a:	b00d      	add	sp, #52	; 0x34
 800930c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        max2870TuneNoLock(driver, &previousTune);
 8009310:	4620      	mov	r0, r4
 8009312:	a906      	add	r1, sp, #24
 8009314:	f7ff fd58 	bl	8008dc8 <max2870TuneNoLock>
 8009318:	e7ea      	b.n	80092f0 <max2870VcoPrecal+0x78>
    	allGood = false;
 800931a:	2500      	movs	r5, #0
 800931c:	e7f1      	b.n	8009302 <max2870VcoPrecal+0x8a>
 800931e:	bf00      	nop
 8009320:	01312d00 	.word	0x01312d00
 8009324:	65a0bbff 	.word	0x65a0bbff
 8009328:	b368f480 	.word	0xb368f480
 800932c:	00000000 	.word	0x00000000

08009330 <gpioDummySetPinMode>:
{
 8009330:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 8009332:	6801      	ldr	r1, [r0, #0]
 8009334:	4802      	ldr	r0, [pc, #8]	; (8009340 <gpioDummySetPinMode+0x10>)
 8009336:	f7ff fce9 	bl	8008d0c <syslog>
}
 800933a:	2000      	movs	r0, #0
 800933c:	bd08      	pop	{r3, pc}
 800933e:	bf00      	nop
 8009340:	0800bfb5 	.word	0x0800bfb5

08009344 <gpioDummyGetPinMode>:
{
 8009344:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 8009346:	6801      	ldr	r1, [r0, #0]
 8009348:	4802      	ldr	r0, [pc, #8]	; (8009354 <gpioDummyGetPinMode+0x10>)
 800934a:	f7ff fcdf 	bl	8008d0c <syslog>
}
 800934e:	2002      	movs	r0, #2
 8009350:	bd08      	pop	{r3, pc}
 8009352:	bf00      	nop
 8009354:	0800bfb5 	.word	0x0800bfb5

08009358 <gpioDummySetValue>:
{
 8009358:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 800935a:	6801      	ldr	r1, [r0, #0]
 800935c:	4802      	ldr	r0, [pc, #8]	; (8009368 <gpioDummySetValue+0x10>)
 800935e:	f7ff fcd5 	bl	8008d0c <syslog>
}
 8009362:	2000      	movs	r0, #0
 8009364:	bd08      	pop	{r3, pc}
 8009366:	bf00      	nop
 8009368:	0800bfb5 	.word	0x0800bfb5

0800936c <gpioDummyGetValue>:
{
 800936c:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 800936e:	6801      	ldr	r1, [r0, #0]
 8009370:	4802      	ldr	r0, [pc, #8]	; (800937c <gpioDummyGetValue+0x10>)
 8009372:	f7ff fccb 	bl	8008d0c <syslog>
}
 8009376:	2000      	movs	r0, #0
 8009378:	bd08      	pop	{r3, pc}
 800937a:	bf00      	nop
 800937c:	0800bfb5 	.word	0x0800bfb5

08009380 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>:
i2c_result i2cSafeMasterTransmitTimeoutWithRetry (
 8009380:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009384:	4604      	mov	r4, r0
 8009386:	4617      	mov	r7, r2
    if(!devAddr) return MSG_RESET;
 8009388:	460d      	mov	r5, r1
i2c_result i2cSafeMasterTransmitTimeoutWithRetry (
 800938a:	9301      	str	r3, [sp, #4]
    if(!devAddr) return MSG_RESET;
 800938c:	2900      	cmp	r1, #0
 800938e:	d07f      	beq.n	8009490 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x110>
    memset(rxbuf, 0xFE, rxbytes);
 8009390:	21fe      	movs	r1, #254	; 0xfe
 8009392:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8009394:	980c      	ldr	r0, [sp, #48]	; 0x30
 8009396:	f002 fa11 	bl	800b7bc <memset>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 800939a:	2603      	movs	r6, #3
  i2cp->errors = I2C_NO_ERROR;
 800939c:	f04f 0900 	mov.w	r9, #0
 80093a0:	006d      	lsls	r5, r5, #1
		xReturn = xTickCount;
 80093a2:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 800949c <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x11c>
 80093a6:	fa1f f885 	uxth.w	r8, r5
  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 80093aa:	b914      	cbnz	r4, 80093b2 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x32>
 80093ac:	f7fb fb0a 	bl	80049c4 <vTaskEndScheduler>
 80093b0:	e7fe      	b.n	80093b0 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x30>
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 80093b2:	7825      	ldrb	r5, [r4, #0]
 80093b4:	2d02      	cmp	r5, #2
 80093b6:	d002      	beq.n	80093be <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x3e>
 80093b8:	f7fb fb04 	bl	80049c4 <vTaskEndScheduler>
 80093bc:	e7fe      	b.n	80093bc <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x3c>
  osalSysLock();
 80093be:	f7fb faf1 	bl	80049a4 <vPortEnterCritical>
  i2cp->state = I2C_ACTIVE_TX;
 80093c2:	2303      	movs	r3, #3
  i2cp->errors = I2C_NO_ERROR;
 80093c4:	f8c4 9008 	str.w	r9, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 80093c8:	7023      	strb	r3, [r4, #0]
  i2cp->numInterrupts = 0;
 80093ca:	f8c4 9080 	str.w	r9, [r4, #128]	; 0x80
  i2cp->addr = (addr << 1);
 80093ce:	f8a4 8064 	strh.w	r8, [r4, #100]	; 0x64
  I2C_TypeDef *dp = i2cp->i2c;
 80093d2:	6fa0      	ldr	r0, [r4, #120]	; 0x78

  /* Releases the lock from high level driver.*/
  osalSysUnlock();
 80093d4:	f7fb fd0a 	bl	8004dec <osalSysUnlock.lto_priv.0>

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80093d8:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80093da:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80093dc:	685b      	ldr	r3, [r3, #4]
 80093de:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 80093e0:	9a01      	ldr	r2, [sp, #4]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 80093e2:	60df      	str	r7, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 80093e4:	605a      	str	r2, [r3, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80093e6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80093e8:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80093ea:	685b      	ldr	r3, [r3, #4]
 80093ec:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80093ee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80093f0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 80093f2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80093f4:	605a      	str	r2, [r3, #4]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80093f6:	f7fc fd91 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80093fa:	f8da b000 	ldr.w	fp, [sl]
  end = start + OSAL_MS2ST(STM32_I2C_BUSY_TIMEOUT);

  /* Waits until BUSY flag is reset or, alternatively, for a timeout
     condition.*/
  while (true) {
    osalSysLock();
 80093fe:	f7fb fad1 	bl	80049a4 <vPortEnterCritical>

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8009402:	6983      	ldr	r3, [r0, #24]
 8009404:	0799      	lsls	r1, r3, #30
 8009406:	d402      	bmi.n	800940e <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x8e>
 8009408:	6803      	ldr	r3, [r0, #0]
 800940a:	059a      	lsls	r2, r3, #22
 800940c:	d50a      	bpl.n	8009424 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xa4>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800940e:	f7fc fd85 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8009412:	f8da 3000 	ldr.w	r3, [sl]
    systime_t past = now - begin;
 8009416:	eba3 030b 	sub.w	r3, r3, fp
    if(past < duration) return true;
 800941a:	2b31      	cmp	r3, #49	; 0x31
 800941c:	d82e      	bhi.n	800947c <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xfc>
    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
      return MSG_TIMEOUT;

    osalSysUnlock();
 800941e:	f7fb fce5 	bl	8004dec <osalSysUnlock.lto_priv.0>
    osalSysLock();
 8009422:	e7ec      	b.n	80093fe <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x7e>
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8009424:	6843      	ldr	r3, [r0, #4]
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 8009426:	2105      	movs	r1, #5
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8009428:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800942c:	6043      	str	r3, [r0, #4]
  dp->CR1 |= I2C_CR1_START;
 800942e:	6803      	ldr	r3, [r0, #0]
 8009430:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009434:	6003      	str	r3, [r0, #0]
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 8009436:	f104 0060 	add.w	r0, r4, #96	; 0x60
 800943a:	f7fd f8c7 	bl	80065cc <osalThreadSuspendTimeoutS>
    i2cp->state = I2C_LOCKED;
 800943e:	1c43      	adds	r3, r0, #1
 8009440:	bf08      	it	eq
 8009442:	2505      	moveq	r5, #5
 8009444:	7025      	strb	r5, [r4, #0]
  osalSysUnlock();
 8009446:	f7fb fcd1 	bl	8004dec <osalSysUnlock.lto_priv.0>
        if(status == MSG_OK){
 800944a:	b320      	cbz	r0, 8009496 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x116>
        osalSysLock();
 800944c:	f7fb faaa 	bl	80049a4 <vPortEnterCritical>
        i2c->i2cErrors++;
 8009450:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
        if((retVal = i2cSafeRawUnclogBus(i2c))) {
 8009454:	4620      	mov	r0, r4
        i2c->i2cErrors++;
 8009456:	3301      	adds	r3, #1
 8009458:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        osalSysUnlock();
 800945c:	f7fb fcc6 	bl	8004dec <osalSysUnlock.lto_priv.0>
        if((retVal = i2cSafeRawUnclogBus(i2c))) {
 8009460:	f7fe fd68 	bl	8007f34 <i2cSafeRawUnclogBus>
 8009464:	4605      	mov	r5, r0
 8009466:	b168      	cbz	r0, 8009484 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x104>
            syslog("I2C error, bus failure: %s.", i2cSafeResultToString(retVal));
 8009468:	f7fa ff72 	bl	8004350 <i2cSafeResultToString>
 800946c:	4601      	mov	r1, r0
 800946e:	480c      	ldr	r0, [pc, #48]	; (80094a0 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x120>)
 8009470:	f7ff fc4c 	bl	8008d0c <syslog>
}
 8009474:	4628      	mov	r0, r5
 8009476:	b003      	add	sp, #12
 8009478:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    i2cp->state = I2C_LOCKED;
 800947c:	2505      	movs	r5, #5
      return MSG_TIMEOUT;
 800947e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8009482:	e7df      	b.n	8009444 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xc4>
    for(i=0; i<maxTries; i++) {
 8009484:	3e01      	subs	r6, #1
 8009486:	d190      	bne.n	80093aa <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x2a>
    syslog("I2C error, %u failed attempts.", maxTries);
 8009488:	2103      	movs	r1, #3
 800948a:	4806      	ldr	r0, [pc, #24]	; (80094a4 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x124>)
 800948c:	f7ff fc3e 	bl	8008d0c <syslog>
    if(!devAddr) return MSG_RESET;
 8009490:	f06f 0501 	mvn.w	r5, #1
 8009494:	e7ee      	b.n	8009474 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xf4>
            retVal = status;
 8009496:	4605      	mov	r5, r0
 8009498:	e7ec      	b.n	8009474 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xf4>
 800949a:	bf00      	nop
 800949c:	20001648 	.word	0x20001648
 80094a0:	0800bfcb 	.word	0x0800bfcb
 80094a4:	0800bfe7 	.word	0x0800bfe7

080094a8 <i2cSafeReadRegBulkStandard.constprop.0>:
i2c_result i2cSafeReadRegBulkStandard(I2CDriver* i2c,
 80094a8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80094aa:	460d      	mov	r5, r1
 80094ac:	461e      	mov	r6, r3
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 80094ae:	4604      	mov	r4, r0
 80094b0:	b910      	cbnz	r0, 80094b8 <i2cSafeReadRegBulkStandard.constprop.0+0x10>
 80094b2:	f7fb fa87 	bl	80049c4 <vTaskEndScheduler>
 80094b6:	e7fe      	b.n	80094b6 <i2cSafeReadRegBulkStandard.constprop.0+0xe>
    uint8_t txBuf[1] = {addr};
 80094b8:	f88d 200c 	strb.w	r2, [sp, #12]
    i2cAcquireBus(i2c);
 80094bc:	f7fc f93c 	bl	8005738 <i2cAcquireBus>
    i2c_status = i2cSafeMasterTransmitTimeoutWithRetry(i2c, devAddr, txBuf,
 80094c0:	2302      	movs	r3, #2
 80094c2:	4629      	mov	r1, r5
 80094c4:	e9cd 6300 	strd	r6, r3, [sp]
 80094c8:	aa03      	add	r2, sp, #12
 80094ca:	2301      	movs	r3, #1
 80094cc:	4620      	mov	r0, r4
 80094ce:	f7ff ff57 	bl	8009380 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>
 80094d2:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 80094d4:	4620      	mov	r0, r4
 80094d6:	f7ff f8b1 	bl	800863c <i2cReleaseBus>
}
 80094da:	4628      	mov	r0, r5
 80094dc:	b004      	add	sp, #16
 80094de:	bd70      	pop	{r4, r5, r6, pc}

080094e0 <i2cSafeReadRegStandard>:
{
 80094e0:	b513      	push	{r0, r1, r4, lr}
 80094e2:	461c      	mov	r4, r3
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 80094e4:	b910      	cbnz	r0, 80094ec <i2cSafeReadRegStandard+0xc>
 80094e6:	f7fb fa6d 	bl	80049c4 <vTaskEndScheduler>
 80094ea:	e7fe      	b.n	80094ea <i2cSafeReadRegStandard+0xa>
    i2c_result result = i2cSafeReadRegBulkStandard(i2c, devAddr, addr, values, sizeof(values));
 80094ec:	ab01      	add	r3, sp, #4
 80094ee:	f7ff ffdb 	bl	80094a8 <i2cSafeReadRegBulkStandard.constprop.0>
    *value=values[0];
 80094f2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80094f6:	7023      	strb	r3, [r4, #0]
}
 80094f8:	b002      	add	sp, #8
 80094fa:	bd10      	pop	{r4, pc}

080094fc <MCP9804MeasureTemperature.part.0>:
#include "mcp9804.h"
#include "../i2csafe/i2csafe.h"
#include <string.h>
#include "../system.h"

int16_t MCP9804MeasureTemperature(MCP9804Driver* driver, bool newMeasurement)
 80094fc:	b513      	push	{r0, r1, r4, lr}
 80094fe:	4604      	mov	r4, r0
    if(!newMeasurement) {
        return driver->temperature;
    }

    uint8_t data[2];
    i2c_result result = i2cSafeReadRegBulkStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x5, data, 2);
 8009500:	6800      	ldr	r0, [r0, #0]
 8009502:	2205      	movs	r2, #5
 8009504:	7901      	ldrb	r1, [r0, #4]
 8009506:	ab01      	add	r3, sp, #4
 8009508:	6800      	ldr	r0, [r0, #0]
 800950a:	f7ff ffcd 	bl	80094a8 <i2cSafeReadRegBulkStandard.constprop.0>

    if(result != I2C_BUS_OK) {
 800950e:	b130      	cbz	r0, 800951e <MCP9804MeasureTemperature.part.0+0x22>
        driver->temperature = 0x7FFF;
 8009510:	f647 73ff 	movw	r3, #32767	; 0x7fff

        driver->temperature = temp;

        /* Check sign */
        if(data[0] & 0x10) {
            driver->temperature = 4096 - temp;
 8009514:	80a3      	strh	r3, [r4, #4]
        }
    }

    return driver->temperature;
}
 8009516:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 800951a:	b002      	add	sp, #8
 800951c:	bd10      	pop	{r4, pc}
        uint16_t temp = ((data[0] & 0xF) << 8) | data[1];
 800951e:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8009522:	020b      	lsls	r3, r1, #8
 8009524:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
 8009528:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800952c:	4313      	orrs	r3, r2
        if(data[0] & 0x10) {
 800952e:	06ca      	lsls	r2, r1, #27
            driver->temperature = 4096 - temp;
 8009530:	bf48      	it	mi
 8009532:	f5c3 5380 	rsbmi	r3, r3, #4096	; 0x1000
 8009536:	e7ed      	b.n	8009514 <MCP9804MeasureTemperature.part.0+0x18>

08009538 <cmdTemp>:

#include <string.h>


void cmdTemp(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 8009538:	b510      	push	{r4, lr}
 800953a:	460c      	mov	r4, r1
 800953c:	f7ff ffde 	bl	80094fc <MCP9804MeasureTemperature.part.0>
    (void)argv;
    MCP9804Driver* tempSens = (MCP9804Driver*)user;

    int32_t temp = MCP9804MeasureTemperature(tempSens, true);

    chprintf(chp, "Temperature: %d mC"SHELL_NEWLINE_STR, temp*1000/16);
 8009540:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009544:	4342      	muls	r2, r0
 8009546:	bf48      	it	mi
 8009548:	320f      	addmi	r2, #15
 800954a:	4620      	mov	r0, r4
}
 800954c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "Temperature: %d mC"SHELL_NEWLINE_STR, temp*1000/16);
 8009550:	4901      	ldr	r1, [pc, #4]	; (8009558 <cmdTemp+0x20>)
 8009552:	1112      	asrs	r2, r2, #4
 8009554:	f7ff b8c1 	b.w	80086da <chprintf>
 8009558:	0800c006 	.word	0x0800c006

0800955c <parse_arguments>:
static char *parse_arguments(char *str, char **saveptr) {
 800955c:	b570      	push	{r4, r5, r6, lr}
 800955e:	460d      	mov	r5, r1
  if (str != NULL)
 8009560:	b100      	cbz	r0, 8009564 <parse_arguments+0x8>
    *saveptr = str;
 8009562:	6008      	str	r0, [r1, #0]
  p = *saveptr;
 8009564:	682e      	ldr	r6, [r5, #0]
  if (!p) {
 8009566:	b17e      	cbz	r6, 8009588 <parse_arguments+0x2c>
  p += strspn(p, " \t");
 8009568:	490e      	ldr	r1, [pc, #56]	; (80095a4 <parse_arguments+0x48>)
 800956a:	4630      	mov	r0, r6
 800956c:	f002 fa28 	bl	800b9c0 <strspn>
  if (*p == '"') {
 8009570:	5c31      	ldrb	r1, [r6, r0]
  p += strspn(p, " \t");
 8009572:	1834      	adds	r4, r6, r0
  if (*p == '"') {
 8009574:	2922      	cmp	r1, #34	; 0x22
 8009576:	d10a      	bne.n	800958e <parse_arguments+0x32>
    p++;
 8009578:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
 800957a:	4620      	mov	r0, r4
 800957c:	f002 f970 	bl	800b860 <strchr>
  if (*saveptr != NULL) {
 8009580:	b950      	cbnz	r0, 8009598 <parse_arguments+0x3c>
 8009582:	6028      	str	r0, [r5, #0]
  return *p != '\0' ? p : NULL;
 8009584:	7823      	ldrb	r3, [r4, #0]
 8009586:	b903      	cbnz	r3, 800958a <parse_arguments+0x2e>
 8009588:	2400      	movs	r4, #0
}
 800958a:	4620      	mov	r0, r4
 800958c:	bd70      	pop	{r4, r5, r6, pc}
    *saveptr = strpbrk(p, " \t");
 800958e:	4620      	mov	r0, r4
 8009590:	4904      	ldr	r1, [pc, #16]	; (80095a4 <parse_arguments+0x48>)
 8009592:	f002 f9f9 	bl	800b988 <strpbrk>
 8009596:	e7f3      	b.n	8009580 <parse_arguments+0x24>
    *(*saveptr)++ = '\0';
 8009598:	1c43      	adds	r3, r0, #1
 800959a:	602b      	str	r3, [r5, #0]
 800959c:	2300      	movs	r3, #0
 800959e:	7003      	strb	r3, [r0, #0]
 80095a0:	e7f0      	b.n	8009584 <parse_arguments+0x28>
 80095a2:	bf00      	nop
 80095a4:	0800c01b 	.word	0x0800c01b

080095a8 <cmdexec>:
                      char *name, int argc, char *argv[]) {
 80095a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80095ac:	4605      	mov	r5, r0
 80095ae:	460e      	mov	r6, r1
 80095b0:	4617      	mov	r7, r2
 80095b2:	4698      	mov	r8, r3
  while (scp->sc_name != NULL) {
 80095b4:	6828      	ldr	r0, [r5, #0]
 80095b6:	b908      	cbnz	r0, 80095bc <cmdexec+0x14>
  return true;
 80095b8:	2001      	movs	r0, #1
 80095ba:	e00b      	b.n	80095d4 <cmdexec+0x2c>
    if (strcmp(scp->sc_name, name) == 0) {
 80095bc:	4639      	mov	r1, r7
 80095be:	f7fa faff 	bl	8003bc0 <strcmp>
 80095c2:	4604      	mov	r4, r0
 80095c4:	b940      	cbnz	r0, 80095d8 <cmdexec+0x30>
      scp->sc_function(scp->sc_user, chp, argc, argv);
 80095c6:	68a8      	ldr	r0, [r5, #8]
 80095c8:	4642      	mov	r2, r8
 80095ca:	4631      	mov	r1, r6
 80095cc:	686f      	ldr	r7, [r5, #4]
 80095ce:	9b06      	ldr	r3, [sp, #24]
 80095d0:	47b8      	blx	r7
      return false;
 80095d2:	4620      	mov	r0, r4
}
 80095d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    scp++;
 80095d8:	350c      	adds	r5, #12
 80095da:	e7eb      	b.n	80095b4 <cmdexec+0xc>

080095dc <cmdGPIO>:

void cmdGPIO(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 80095dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    (void) user;

    if(argc < 1) {
 80095e0:	1e16      	subs	r6, r2, #0
{
 80095e2:	460d      	mov	r5, r1
 80095e4:	461f      	mov	r7, r3
    if(argc < 1) {
 80095e6:	dc04      	bgt.n	80095f2 <cmdGPIO+0x16>
        cmdGPIOUsage(chp);
 80095e8:	4628      	mov	r0, r5
    } else {
        cmdGPIOUsage(chp);
    }

    //TXA6408PrintStatus(&mixerControllerIO, chp);
}
 80095ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        cmdGPIOUsage(chp);
 80095ee:	f7ff b9e3 	b.w	80089b8 <cmdGPIOUsage>
    if(!strcmp(argv[0], "status")) {
 80095f2:	f8d3 8000 	ldr.w	r8, [r3]
 80095f6:	4944      	ldr	r1, [pc, #272]	; (8009708 <cmdGPIO+0x12c>)
 80095f8:	4640      	mov	r0, r8
 80095fa:	f7fa fae1 	bl	8003bc0 <strcmp>
 80095fe:	4604      	mov	r4, r0
 8009600:	bb78      	cbnz	r0, 8009662 <cmdGPIO+0x86>

void gpioPrintStatus(BaseSequentialStream* chp)
{
    for(uint8_t i=0; i<GPIODriverData.numPorts; i++) {
 8009602:	f8df 8108 	ldr.w	r8, [pc, #264]	; 800970c <cmdGPIO+0x130>
        const GPIOPort* port = gpioGetPortDriver(i);

        chprintf(chp, "Port %u: ", i);
 8009606:	f8df 9108 	ldr.w	r9, [pc, #264]	; 8009710 <cmdGPIO+0x134>
        if(GPIODriverData.registeredPorts & _BV(i)) {
            chprintf(chp, "(Active, %u pins)", port->numPins);
 800960a:	f8df a108 	ldr.w	sl, [pc, #264]	; 8009714 <cmdGPIO+0x138>
 800960e:	e021      	b.n	8009654 <cmdGPIO+0x78>
        const GPIOPort* port = gpioGetPortDriver(i);
 8009610:	4630      	mov	r0, r6
 8009612:	f7fa fed1 	bl	80043b8 <gpioGetPortDriver>
        chprintf(chp, "Port %u: ", i);
 8009616:	4649      	mov	r1, r9
        const GPIOPort* port = gpioGetPortDriver(i);
 8009618:	4607      	mov	r7, r0
        chprintf(chp, "Port %u: ", i);
 800961a:	4632      	mov	r2, r6
 800961c:	4628      	mov	r0, r5
 800961e:	f7ff f85c 	bl	80086da <chprintf>
        if(GPIODriverData.registeredPorts & _BV(i)) {
 8009622:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8009626:	40f3      	lsrs	r3, r6
 8009628:	07db      	lsls	r3, r3, #31
 800962a:	d504      	bpl.n	8009636 <cmdGPIO+0x5a>
            chprintf(chp, "(Active, %u pins)", port->numPins);
 800962c:	4651      	mov	r1, sl
 800962e:	4628      	mov	r0, r5
 8009630:	687a      	ldr	r2, [r7, #4]
 8009632:	f7ff f852 	bl	80086da <chprintf>
        }
        chprintf(chp, SHELL_NEWLINE_STR);
 8009636:	4628      	mov	r0, r5
 8009638:	4937      	ldr	r1, [pc, #220]	; (8009718 <cmdGPIO+0x13c>)
 800963a:	f7ff f84e 	bl	80086da <chprintf>

        if(port->functions->status) {
 800963e:	68bb      	ldr	r3, [r7, #8]
 8009640:	695b      	ldr	r3, [r3, #20]
 8009642:	b113      	cbz	r3, 800964a <cmdGPIO+0x6e>
            port->functions->status(port, chp);
 8009644:	4629      	mov	r1, r5
 8009646:	4638      	mov	r0, r7
 8009648:	4798      	blx	r3
        }
        chprintf(chp, SHELL_NEWLINE_STR);
 800964a:	4628      	mov	r0, r5
 800964c:	4932      	ldr	r1, [pc, #200]	; (8009718 <cmdGPIO+0x13c>)
 800964e:	f7ff f844 	bl	80086da <chprintf>
    for(uint8_t i=0; i<GPIODriverData.numPorts; i++) {
 8009652:	3401      	adds	r4, #1
 8009654:	f898 3004 	ldrb.w	r3, [r8, #4]
 8009658:	b2e6      	uxtb	r6, r4
 800965a:	42b3      	cmp	r3, r6
 800965c:	d8d8      	bhi.n	8009610 <cmdGPIO+0x34>
}
 800965e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(argc == 3) {
 8009662:	2e03      	cmp	r6, #3
 8009664:	d1c0      	bne.n	80095e8 <cmdGPIO+0xc>
        uint8_t portId = strToInt(argv[0], 10);
 8009666:	210a      	movs	r1, #10
 8009668:	4640      	mov	r0, r8
 800966a:	f7fa fdb2 	bl	80041d2 <strToInt>
        if(!strcmp(argv[1], "bus")) {
 800966e:	687c      	ldr	r4, [r7, #4]
        uint8_t portId = strToInt(argv[0], 10);
 8009670:	4606      	mov	r6, r0
        if(!strcmp(argv[1], "bus")) {
 8009672:	492a      	ldr	r1, [pc, #168]	; (800971c <cmdGPIO+0x140>)
 8009674:	4620      	mov	r0, r4
 8009676:	f7fa faa3 	bl	8003bc0 <strcmp>
 800967a:	4680      	mov	r8, r0
 800967c:	b968      	cbnz	r0, 800969a <cmdGPIO+0xbe>
            if(!strcmp(argv[2], "off")) {
 800967e:	4928      	ldr	r1, [pc, #160]	; (8009720 <cmdGPIO+0x144>)
 8009680:	68b8      	ldr	r0, [r7, #8]
        uint8_t portId = strToInt(argv[0], 10);
 8009682:	b2f6      	uxtb	r6, r6
            if(!strcmp(argv[2], "off")) {
 8009684:	f7fa fa9c 	bl	8003bc0 <strcmp>
 8009688:	b928      	cbnz	r0, 8009696 <cmdGPIO+0xba>
                gpioPortIoDisable(portId, true);
 800968a:	2101      	movs	r1, #1
                gpioPortIoDisable(portId, false);
 800968c:	4630      	mov	r0, r6
}
 800968e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioPortIoDisable(portId, false);
 8009692:	f7fa beb1 	b.w	80043f8 <gpioPortIoDisable>
 8009696:	4641      	mov	r1, r8
 8009698:	e7f8      	b.n	800968c <cmdGPIO+0xb0>
            uint8_t pinId = strToInt(argv[1], 10);
 800969a:	210a      	movs	r1, #10
 800969c:	4620      	mov	r0, r4
 800969e:	f7fa fd98 	bl	80041d2 <strToInt>
            uint16_t pin = MAKE_GPIO(portId, pinId);
 80096a2:	b2c4      	uxtb	r4, r0
 80096a4:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
            if(!strcmp(argv[2], "output")) {
 80096a8:	68be      	ldr	r6, [r7, #8]
 80096aa:	491e      	ldr	r1, [pc, #120]	; (8009724 <cmdGPIO+0x148>)
 80096ac:	4630      	mov	r0, r6
            uint16_t pin = MAKE_GPIO(portId, pinId);
 80096ae:	b2a4      	uxth	r4, r4
            if(!strcmp(argv[2], "output")) {
 80096b0:	f7fa fa86 	bl	8003bc0 <strcmp>
 80096b4:	b928      	cbnz	r0, 80096c2 <cmdGPIO+0xe6>
                gpioSetPinMode(pin, PAL_MODE_OUTPUT_PUSHPULL);
 80096b6:	2106      	movs	r1, #6
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 80096b8:	4620      	mov	r0, r4
}
 80096ba:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 80096be:	f7fd be29 	b.w	8007314 <gpioSetPinMode.isra.0>
            } else if(!strcmp(argv[2], "input")) {
 80096c2:	4630      	mov	r0, r6
 80096c4:	4918      	ldr	r1, [pc, #96]	; (8009728 <cmdGPIO+0x14c>)
 80096c6:	f7fa fa7b 	bl	8003bc0 <strcmp>
 80096ca:	b908      	cbnz	r0, 80096d0 <cmdGPIO+0xf4>
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 80096cc:	2102      	movs	r1, #2
 80096ce:	e7f3      	b.n	80096b8 <cmdGPIO+0xdc>
            } else if(!strcmp(argv[2], "set")) {
 80096d0:	4630      	mov	r0, r6
 80096d2:	4916      	ldr	r1, [pc, #88]	; (800972c <cmdGPIO+0x150>)
 80096d4:	f7fa fa74 	bl	8003bc0 <strcmp>
 80096d8:	b928      	cbnz	r0, 80096e6 <cmdGPIO+0x10a>
                gpioSetPin(pin, true);
 80096da:	2101      	movs	r1, #1
 80096dc:	4620      	mov	r0, r4
}
 80096de:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioSetPin(pin, false);
 80096e2:	f7fd bf43 	b.w	800756c <gpioSetPin.isra.0>
            } else if(!strcmp(argv[2], "clear")) {
 80096e6:	4912      	ldr	r1, [pc, #72]	; (8009730 <cmdGPIO+0x154>)
 80096e8:	4630      	mov	r0, r6
 80096ea:	f7fa fa69 	bl	8003bc0 <strcmp>
 80096ee:	4601      	mov	r1, r0
                gpioSetPin(pin, false);
 80096f0:	4620      	mov	r0, r4
            } else if(!strcmp(argv[2], "clear")) {
 80096f2:	2900      	cmp	r1, #0
 80096f4:	d0f3      	beq.n	80096de <cmdGPIO+0x102>
                chprintf(chp, "Value: %u"SHELL_NEWLINE_STR, gpioGetPin(pin));
 80096f6:	f7fa fe6d 	bl	80043d4 <gpioGetPin>
 80096fa:	490e      	ldr	r1, [pc, #56]	; (8009734 <cmdGPIO+0x158>)
 80096fc:	4602      	mov	r2, r0
 80096fe:	4628      	mov	r0, r5
}
 8009700:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                chprintf(chp, "Value: %u"SHELL_NEWLINE_STR, gpioGetPin(pin));
 8009704:	f7fe bfe9 	b.w	80086da <chprintf>
 8009708:	0800c01e 	.word	0x0800c01e
 800970c:	20000928 	.word	0x20000928
 8009710:	0800c025 	.word	0x0800c025
 8009714:	0800c02f 	.word	0x0800c02f
 8009718:	0800be0f 	.word	0x0800be0f
 800971c:	0800c041 	.word	0x0800c041
 8009720:	0800c045 	.word	0x0800c045
 8009724:	0800c049 	.word	0x0800c049
 8009728:	0800c050 	.word	0x0800c050
 800972c:	0800c056 	.word	0x0800c056
 8009730:	0800c05a 	.word	0x0800c05a
 8009734:	0800c060 	.word	0x0800c060

08009738 <cmdConvert>:
    chprintf(chp, "\tconvert hs [shfband] [1/0]"SHELL_NEWLINE_STR);
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
}

void cmdConvert(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 8009738:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ConverterManager* converter = (ConverterManager*)user;

    if(argc == 1) {
 800973c:	2a01      	cmp	r2, #1
{
 800973e:	4605      	mov	r5, r0
 8009740:	460c      	mov	r4, r1
 8009742:	4690      	mov	r8, r2
 8009744:	461e      	mov	r6, r3
 8009746:	b088      	sub	sp, #32
    if(argc == 1) {
 8009748:	d177      	bne.n	800983a <cmdConvert+0x102>
        if(!strcmp(argv[0], "status")) {
 800974a:	4968      	ldr	r1, [pc, #416]	; (80098ec <cmdConvert+0x1b4>)
 800974c:	6818      	ldr	r0, [r3, #0]
 800974e:	f7fa fa37 	bl	8003bc0 <strcmp>
 8009752:	4606      	mov	r6, r0
 8009754:	2800      	cmp	r0, #0
 8009756:	f040 80bb 	bne.w	80098d0 <cmdConvert+0x198>
    return true;
}

void converterStatus(BaseSequentialStream* chp, ConverterManager* converter)
{
    chprintf(chp, "Bands: [Disable mask: 0x%08x]"SHELL_NEWLINE_STR, converter->disabledBands);
 800975a:	69ea      	ldr	r2, [r5, #28]
 800975c:	4964      	ldr	r1, [pc, #400]	; (80098f0 <cmdConvert+0x1b8>)
 800975e:	4620      	mov	r0, r4
 8009760:	f7fe ffbb 	bl	80086da <chprintf>
    printfFixed(chp, 9, "\tBand ID");
 8009764:	2109      	movs	r1, #9
 8009766:	4a63      	ldr	r2, [pc, #396]	; (80098f4 <cmdConvert+0x1bc>)
 8009768:	4620      	mov	r0, r4
 800976a:	f7ff f95f 	bl	8008a2c <printfFixed>
    printfFixed(chp, 7, "Name");
 800976e:	2107      	movs	r1, #7
 8009770:	4a61      	ldr	r2, [pc, #388]	; (80098f8 <cmdConvert+0x1c0>)
 8009772:	4620      	mov	r0, r4
 8009774:	f7ff f95a 	bl	8008a2c <printfFixed>
    printfFixed(chp, 14, "FreqMin [kHz]");
 8009778:	210e      	movs	r1, #14
 800977a:	4a60      	ldr	r2, [pc, #384]	; (80098fc <cmdConvert+0x1c4>)
 800977c:	4620      	mov	r0, r4
 800977e:	f7ff f955 	bl	8008a2c <printfFixed>
    chprintf(chp,	     "FreqMax [kHz]"SHELL_NEWLINE_STR);
 8009782:	4620      	mov	r0, r4
 8009784:	495e      	ldr	r1, [pc, #376]	; (8009900 <cmdConvert+0x1c8>)
 8009786:	f7fe ffa8 	bl	80086da <chprintf>
        if(i == converter->activeBand) {
            printfFixed(chp, 9, "\t%u [*]", i);
        } else {
            printfFixed(chp, 9, "\t%u", i);
        }
        printfFixed(chp, 7, "%s", converter->bands[i].bandName);
 800978a:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8009904 <cmdConvert+0x1cc>
        printfFixed(chp, 14, "%u", converter->bands[i].minFrequencyKHz);
 800978e:	f8df 9178 	ldr.w	r9, [pc, #376]	; 8009908 <cmdConvert+0x1d0>
        chprintf(chp,	     "%u"SHELL_NEWLINE_STR, converter->bands[i].maxFrequencyKHz);
 8009792:	f8df a178 	ldr.w	sl, [pc, #376]	; 800990c <cmdConvert+0x1d4>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8009796:	2714      	movs	r7, #20
 8009798:	b2f3      	uxtb	r3, r6
 800979a:	435f      	muls	r7, r3
 800979c:	696a      	ldr	r2, [r5, #20]
 800979e:	443a      	add	r2, r7
 80097a0:	6912      	ldr	r2, [r2, #16]
 80097a2:	b96a      	cbnz	r2, 80097c0 <cmdConvert+0x88>
    }

    chprintf(chp, SHELL_NEWLINE_STR);
 80097a4:	4620      	mov	r0, r4
 80097a6:	495a      	ldr	r1, [pc, #360]	; (8009910 <cmdConvert+0x1d8>)
 80097a8:	f7fe ff97 	bl	80086da <chprintf>

    if(converter->activeBand == 0xff) {
 80097ac:	7e2b      	ldrb	r3, [r5, #24]
 80097ae:	2bff      	cmp	r3, #255	; 0xff
 80097b0:	d12c      	bne.n	800980c <cmdConvert+0xd4>
        chprintf(chp, "Converter disabled." SHELL_NEWLINE_STR);
 80097b2:	4958      	ldr	r1, [pc, #352]	; (8009914 <cmdConvert+0x1dc>)
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 80097b4:	4620      	mov	r0, r4
            return;
        }
    }

    cmdConvertUsage(chp);
}
 80097b6:	b008      	add	sp, #32
 80097b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 80097bc:	f7fe bf8d 	b.w	80086da <chprintf>
        if(_BV(i) & converter-> disabledBands) {
 80097c0:	69ea      	ldr	r2, [r5, #28]
 80097c2:	40da      	lsrs	r2, r3
 80097c4:	07d1      	lsls	r1, r2, #31
 80097c6:	d41f      	bmi.n	8009808 <cmdConvert+0xd0>
        if(i == converter->activeBand) {
 80097c8:	7e2a      	ldrb	r2, [r5, #24]
            printfFixed(chp, 9, "\t%u", i);
 80097ca:	2109      	movs	r1, #9
        if(i == converter->activeBand) {
 80097cc:	429a      	cmp	r2, r3
            printfFixed(chp, 9, "\t%u [*]", i);
 80097ce:	bf0a      	itet	eq
 80097d0:	4613      	moveq	r3, r2
            printfFixed(chp, 9, "\t%u", i);
 80097d2:	4a51      	ldrne	r2, [pc, #324]	; (8009918 <cmdConvert+0x1e0>)
            printfFixed(chp, 9, "\t%u [*]", i);
 80097d4:	4a51      	ldreq	r2, [pc, #324]	; (800991c <cmdConvert+0x1e4>)
            printfFixed(chp, 9, "\t%u", i);
 80097d6:	4620      	mov	r0, r4
 80097d8:	f7ff f928 	bl	8008a2c <printfFixed>
        printfFixed(chp, 7, "%s", converter->bands[i].bandName);
 80097dc:	696b      	ldr	r3, [r5, #20]
 80097de:	4642      	mov	r2, r8
 80097e0:	2107      	movs	r1, #7
 80097e2:	59db      	ldr	r3, [r3, r7]
 80097e4:	4620      	mov	r0, r4
 80097e6:	f7ff f921 	bl	8008a2c <printfFixed>
        printfFixed(chp, 14, "%u", converter->bands[i].minFrequencyKHz);
 80097ea:	696b      	ldr	r3, [r5, #20]
 80097ec:	464a      	mov	r2, r9
 80097ee:	443b      	add	r3, r7
 80097f0:	210e      	movs	r1, #14
 80097f2:	685b      	ldr	r3, [r3, #4]
 80097f4:	4620      	mov	r0, r4
 80097f6:	f7ff f919 	bl	8008a2c <printfFixed>
        chprintf(chp,	     "%u"SHELL_NEWLINE_STR, converter->bands[i].maxFrequencyKHz);
 80097fa:	696b      	ldr	r3, [r5, #20]
 80097fc:	4651      	mov	r1, sl
 80097fe:	443b      	add	r3, r7
 8009800:	4620      	mov	r0, r4
 8009802:	689a      	ldr	r2, [r3, #8]
 8009804:	f7fe ff69 	bl	80086da <chprintf>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8009808:	3601      	adds	r6, #1
 800980a:	e7c4      	b.n	8009796 <cmdConvert+0x5e>
    } else {
        chprintf(chp, "Input Frequency:    %u kHz" SHELL_NEWLINE_STR, converter->currentTune.inputFrequencyKHz);
 800980c:	682a      	ldr	r2, [r5, #0]
 800980e:	4620      	mov	r0, r4
 8009810:	4943      	ldr	r1, [pc, #268]	; (8009920 <cmdConvert+0x1e8>)
 8009812:	f7fe ff62 	bl	80086da <chprintf>
        chprintf(chp, "Output Frequency:   %u kHz" SHELL_NEWLINE_STR, converter->currentTune.outputFrequencyKHz);
 8009816:	68ea      	ldr	r2, [r5, #12]
 8009818:	4620      	mov	r0, r4
 800981a:	4942      	ldr	r1, [pc, #264]	; (8009924 <cmdConvert+0x1ec>)
 800981c:	f7fe ff5d 	bl	80086da <chprintf>
        chprintf(chp, "Spectral inversion: %u" SHELL_NEWLINE_STR, converter->currentTune.spectrumInversion);
 8009820:	7c2a      	ldrb	r2, [r5, #16]
 8009822:	4620      	mov	r0, r4
 8009824:	4940      	ldr	r1, [pc, #256]	; (8009928 <cmdConvert+0x1f0>)
 8009826:	f7fe ff58 	bl	80086da <chprintf>
        chprintf(chp, "Selected antenna:   %u" SHELL_NEWLINE_STR , converter->currentTune.antennaInput);
 800982a:	4620      	mov	r0, r4
 800982c:	686a      	ldr	r2, [r5, #4]
 800982e:	493f      	ldr	r1, [pc, #252]	; (800992c <cmdConvert+0x1f4>)
}
 8009830:	b008      	add	sp, #32
 8009832:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009836:	f7fe bf50 	b.w	80086da <chprintf>
    } else if (argc >= 2) {
 800983a:	dd49      	ble.n	80098d0 <cmdConvert+0x198>
        if(argc == 3 && !strcmp(argv[0], "hs")) {
 800983c:	2a03      	cmp	r2, #3
        if(!strcmp(argv[0], "status")) {
 800983e:	681f      	ldr	r7, [r3, #0]
        if(argc == 3 && !strcmp(argv[0], "hs")) {
 8009840:	d117      	bne.n	8009872 <cmdConvert+0x13a>
 8009842:	4638      	mov	r0, r7
 8009844:	493a      	ldr	r1, [pc, #232]	; (8009930 <cmdConvert+0x1f8>)
 8009846:	f7fa f9bb 	bl	8003bc0 <strcmp>
 800984a:	b990      	cbnz	r0, 8009872 <cmdConvert+0x13a>
            uint32_t band = strToInt(argv[1], 10);
 800984c:	210a      	movs	r1, #10
 800984e:	6870      	ldr	r0, [r6, #4]
 8009850:	f7fa fcbf 	bl	80041d2 <strToInt>
            if(band < sizeof(converterSHFBandConfig)/sizeof(ConverterSHFConfig)) {
 8009854:	2803      	cmp	r0, #3
 8009856:	d80c      	bhi.n	8009872 <cmdConvert+0x13a>
                converterSHFBandConfig[band].useHighSideMixing = (argv[2][0] == '1');
 8009858:	230c      	movs	r3, #12
 800985a:	4358      	muls	r0, r3
 800985c:	68b3      	ldr	r3, [r6, #8]
 800985e:	781b      	ldrb	r3, [r3, #0]
 8009860:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 8009864:	4253      	negs	r3, r2
 8009866:	4153      	adcs	r3, r2
 8009868:	4a32      	ldr	r2, [pc, #200]	; (8009934 <cmdConvert+0x1fc>)
 800986a:	5413      	strb	r3, [r2, r0]
}
 800986c:	b008      	add	sp, #32
 800986e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(!strcmp(argv[0], "setup")) {
 8009872:	4638      	mov	r0, r7
 8009874:	4930      	ldr	r1, [pc, #192]	; (8009938 <cmdConvert+0x200>)
 8009876:	f7fa f9a3 	bl	8003bc0 <strcmp>
 800987a:	4607      	mov	r7, r0
 800987c:	bb40      	cbnz	r0, 80098d0 <cmdConvert+0x198>
            uint32_t frequency = strToInt(argv[1], 10);
 800987e:	210a      	movs	r1, #10
 8009880:	6870      	ldr	r0, [r6, #4]
 8009882:	f7fa fca6 	bl	80041d2 <strToInt>
            if(argc >= 3) {
 8009886:	f1b8 0f02 	cmp.w	r8, #2
            tuneRequest.antennaInput = 0;
 800988a:	e9cd 0703 	strd	r0, r7, [sp, #12]
            if(argc >= 3) {
 800988e:	d111      	bne.n	80098b4 <cmdConvert+0x17c>
            tuneRequest.forceBand = false;
 8009890:	f88d 7014 	strb.w	r7, [sp, #20]
            bool result = converterTune(converter, &tuneRequest);
 8009894:	4628      	mov	r0, r5
 8009896:	a903      	add	r1, sp, #12
 8009898:	f7fa fe1c 	bl	80044d4 <converterTune>
            if(result) {
 800989c:	b198      	cbz	r0, 80098c6 <cmdConvert+0x18e>
                chprintf(chp, "IF Frequency: %u kHz, inversion: %u (band %u)"SHELL_NEWLINE_STR, tuneRequest.outputFrequencyKHz, tuneRequest.spectrumInversion, tuneRequest.bandId);
 800989e:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80098a2:	4620      	mov	r0, r4
 80098a4:	9300      	str	r3, [sp, #0]
 80098a6:	9a06      	ldr	r2, [sp, #24]
 80098a8:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80098ac:	4923      	ldr	r1, [pc, #140]	; (800993c <cmdConvert+0x204>)
 80098ae:	f7fe ff14 	bl	80086da <chprintf>
 80098b2:	e7db      	b.n	800986c <cmdConvert+0x134>
                tuneRequest.forceBand = true;
 80098b4:	2301      	movs	r3, #1
                tuneRequest.bandId = strToInt(argv[2], 10);
 80098b6:	68b0      	ldr	r0, [r6, #8]
                tuneRequest.forceBand = true;
 80098b8:	f88d 3014 	strb.w	r3, [sp, #20]
                tuneRequest.bandId = strToInt(argv[2], 10);
 80098bc:	f7fa fc89 	bl	80041d2 <strToInt>
 80098c0:	f88d 0015 	strb.w	r0, [sp, #21]
 80098c4:	e7e6      	b.n	8009894 <cmdConvert+0x15c>
                chprintf(chp, "Error!"SHELL_NEWLINE_STR);
 80098c6:	4620      	mov	r0, r4
 80098c8:	491d      	ldr	r1, [pc, #116]	; (8009940 <cmdConvert+0x208>)
 80098ca:	f7fe ff06 	bl	80086da <chprintf>
            return;
 80098ce:	e7cd      	b.n	800986c <cmdConvert+0x134>
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 80098d0:	491c      	ldr	r1, [pc, #112]	; (8009944 <cmdConvert+0x20c>)
 80098d2:	4620      	mov	r0, r4
 80098d4:	f7fe ff01 	bl	80086da <chprintf>
    chprintf(chp, "\tconvert setup [freqkHz] [forceBand]"SHELL_NEWLINE_STR);
 80098d8:	491b      	ldr	r1, [pc, #108]	; (8009948 <cmdConvert+0x210>)
 80098da:	4620      	mov	r0, r4
 80098dc:	f7fe fefd 	bl	80086da <chprintf>
    chprintf(chp, "\tconvert hs [shfband] [1/0]"SHELL_NEWLINE_STR);
 80098e0:	491a      	ldr	r1, [pc, #104]	; (800994c <cmdConvert+0x214>)
 80098e2:	4620      	mov	r0, r4
 80098e4:	f7fe fef9 	bl	80086da <chprintf>
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 80098e8:	4919      	ldr	r1, [pc, #100]	; (8009950 <cmdConvert+0x218>)
 80098ea:	e763      	b.n	80097b4 <cmdConvert+0x7c>
 80098ec:	0800c01e 	.word	0x0800c01e
 80098f0:	0800c06c 	.word	0x0800c06c
 80098f4:	0800c08c 	.word	0x0800c08c
 80098f8:	0800c301 	.word	0x0800c301
 80098fc:	0800c095 	.word	0x0800c095
 8009900:	0800c0a3 	.word	0x0800c0a3
 8009904:	0800bc2f 	.word	0x0800bc2f
 8009908:	0800c0bc 	.word	0x0800c0bc
 800990c:	0800c13c 	.word	0x0800c13c
 8009910:	0800be0f 	.word	0x0800be0f
 8009914:	0800c0bf 	.word	0x0800c0bf
 8009918:	0800c0bb 	.word	0x0800c0bb
 800991c:	0800c0b3 	.word	0x0800c0b3
 8009920:	0800c0d5 	.word	0x0800c0d5
 8009924:	0800c0f2 	.word	0x0800c0f2
 8009928:	0800c10f 	.word	0x0800c10f
 800992c:	0800c128 	.word	0x0800c128
 8009930:	0800c141 	.word	0x0800c141
 8009934:	2000080c 	.word	0x2000080c
 8009938:	0800c144 	.word	0x0800c144
 800993c:	0800c14a 	.word	0x0800c14a
 8009940:	0800c17a 	.word	0x0800c17a
 8009944:	0800bc18 	.word	0x0800bc18
 8009948:	0800c183 	.word	0x0800c183
 800994c:	0800c1aa 	.word	0x0800c1aa
 8009950:	0800c1c8 	.word	0x0800c1c8

08009954 <cmdReboot>:
{
 8009954:	b538      	push	{r3, r4, r5, lr}
 8009956:	460c      	mov	r4, r1
    if(argc == 0) {
 8009958:	b9ca      	cbnz	r2, 800998e <cmdReboot+0x3a>
        chprintf(chp,"Usage:"SHELL_NEWLINE_STR);
 800995a:	4927      	ldr	r1, [pc, #156]	; (80099f8 <cmdReboot+0xa4>)
 800995c:	4620      	mov	r0, r4
 800995e:	f7fe febc 	bl	80086da <chprintf>
        chprintf(chp,"\t reboot nvic"SHELL_NEWLINE_STR);
 8009962:	4926      	ldr	r1, [pc, #152]	; (80099fc <cmdReboot+0xa8>)
 8009964:	4620      	mov	r0, r4
 8009966:	f7fe feb8 	bl	80086da <chprintf>
        chprintf(chp,"\t reboot loader"SHELL_NEWLINE_STR);
 800996a:	4925      	ldr	r1, [pc, #148]	; (8009a00 <cmdReboot+0xac>)
 800996c:	4620      	mov	r0, r4
 800996e:	f7fe feb4 	bl	80086da <chprintf>
        chprintf(chp,"\t reboot loaderp"SHELL_NEWLINE_STR);
 8009972:	4924      	ldr	r1, [pc, #144]	; (8009a04 <cmdReboot+0xb0>)
 8009974:	4620      	mov	r0, r4
 8009976:	f7fe feb0 	bl	80086da <chprintf>
        chprintf(chp,"\t reboot crash"SHELL_NEWLINE_STR);
 800997a:	4923      	ldr	r1, [pc, #140]	; (8009a08 <cmdReboot+0xb4>)
 800997c:	4620      	mov	r0, r4
 800997e:	f7fe feac 	bl	80086da <chprintf>
        chprintf(chp,"\t reboot memexec"SHELL_NEWLINE_STR);
 8009982:	4922      	ldr	r1, [pc, #136]	; (8009a0c <cmdReboot+0xb8>)
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 8009984:	4620      	mov	r0, r4
}
 8009986:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 800998a:	f7fe bea6 	b.w	80086da <chprintf>
    } else if(argc == 1 && !strcmp(argv[0], "loaderp")) {
 800998e:	2a01      	cmp	r2, #1
 8009990:	d12f      	bne.n	80099f2 <cmdReboot+0x9e>
 8009992:	681d      	ldr	r5, [r3, #0]
 8009994:	491e      	ldr	r1, [pc, #120]	; (8009a10 <cmdReboot+0xbc>)
 8009996:	4628      	mov	r0, r5
 8009998:	f7fa f912 	bl	8003bc0 <strcmp>
 800999c:	b1f0      	cbz	r0, 80099dc <cmdReboot+0x88>
    } else if(argc == 1 && !strcmp(argv[0], "loader")) {
 800999e:	4628      	mov	r0, r5
 80099a0:	491c      	ldr	r1, [pc, #112]	; (8009a14 <cmdReboot+0xc0>)
 80099a2:	f7fa f90d 	bl	8003bc0 <strcmp>
 80099a6:	b1d8      	cbz	r0, 80099e0 <cmdReboot+0x8c>
    } else if(argc == 1 && !strcmp(argv[0], "crash")) {
 80099a8:	4628      	mov	r0, r5
 80099aa:	491b      	ldr	r1, [pc, #108]	; (8009a18 <cmdReboot+0xc4>)
 80099ac:	f7fa f908 	bl	8003bc0 <strcmp>
 80099b0:	b910      	cbnz	r0, 80099b8 <cmdReboot+0x64>
        osalSysHalt("crash");
 80099b2:	f7fb f807 	bl	80049c4 <vTaskEndScheduler>
 80099b6:	e7fe      	b.n	80099b6 <cmdReboot+0x62>
    } else if(argc == 1 && !strcmp(argv[0], "memexec")) {
 80099b8:	4628      	mov	r0, r5
 80099ba:	4918      	ldr	r1, [pc, #96]	; (8009a1c <cmdReboot+0xc8>)
 80099bc:	f7fa f900 	bl	8003bc0 <strcmp>
 80099c0:	b9b8      	cbnz	r0, 80099f2 <cmdReboot+0x9e>
        if(callIt(4) == 5 && callIt(54) == 55) {
 80099c2:	2004      	movs	r0, #4
        uint32_t (*callIt)(uint32_t) = (uint32_t(*)(uint32_t))(incr0bxlr+1); /* +1 for thumb mode */
 80099c4:	4d16      	ldr	r5, [pc, #88]	; (8009a20 <cmdReboot+0xcc>)
        if(callIt(4) == 5 && callIt(54) == 55) {
 80099c6:	47a8      	blx	r5
 80099c8:	2805      	cmp	r0, #5
 80099ca:	d105      	bne.n	80099d8 <cmdReboot+0x84>
 80099cc:	2036      	movs	r0, #54	; 0x36
 80099ce:	47a8      	blx	r5
 80099d0:	2837      	cmp	r0, #55	; 0x37
 80099d2:	d101      	bne.n	80099d8 <cmdReboot+0x84>
            chprintf(chp, "Success!"SHELL_NEWLINE_STR);
 80099d4:	4913      	ldr	r1, [pc, #76]	; (8009a24 <cmdReboot+0xd0>)
 80099d6:	e7d5      	b.n	8009984 <cmdReboot+0x30>
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 80099d8:	4913      	ldr	r1, [pc, #76]	; (8009a28 <cmdReboot+0xd4>)
 80099da:	e7d3      	b.n	8009984 <cmdReboot+0x30>
        rebootCode = 0x424C;
 80099dc:	f244 204c 	movw	r0, #16972	; 0x424c
    RCC->APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 80099e0:	4a12      	ldr	r2, [pc, #72]	; (8009a2c <cmdReboot+0xd8>)
 80099e2:	69d3      	ldr	r3, [r2, #28]
 80099e4:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 80099e8:	61d3      	str	r3, [r2, #28]
    BKP->DR10 = rebootCode;
 80099ea:	4b11      	ldr	r3, [pc, #68]	; (8009a30 <cmdReboot+0xdc>)
 80099ec:	6298      	str	r0, [r3, #40]	; 0x28
    NVIC_SystemReset();
 80099ee:	f7fa fc1f 	bl	8004230 <NVIC_SystemReset.lto_priv.0>
        rebootCode = 0x424D;
 80099f2:	f244 204d 	movw	r0, #16973	; 0x424d
 80099f6:	e7f3      	b.n	80099e0 <cmdReboot+0x8c>
 80099f8:	0800bc18 	.word	0x0800bc18
 80099fc:	0800c1da 	.word	0x0800c1da
 8009a00:	0800c1ea 	.word	0x0800c1ea
 8009a04:	0800c1fc 	.word	0x0800c1fc
 8009a08:	0800c20f 	.word	0x0800c20f
 8009a0c:	0800c220 	.word	0x0800c220
 8009a10:	0800c233 	.word	0x0800c233
 8009a14:	0800c23b 	.word	0x0800c23b
 8009a18:	0800c242 	.word	0x0800c242
 8009a1c:	0800c248 	.word	0x0800c248
 8009a20:	2000084d 	.word	0x2000084d
 8009a24:	0800c250 	.word	0x0800c250
 8009a28:	0800c25b 	.word	0x0800c25b
 8009a2c:	40021000 	.word	0x40021000
 8009a30:	40006c00 	.word	0x40006c00

08009a34 <cmdSyslog>:
{
 8009a34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(argc == 1 && !strcmp(argv[0], "clear")) {
 8009a38:	2a01      	cmp	r2, #1
{
 8009a3a:	460d      	mov	r5, r1
 8009a3c:	461c      	mov	r4, r3
 8009a3e:	b087      	sub	sp, #28
    if(argc == 1 && !strcmp(argv[0], "clear")) {
 8009a40:	d117      	bne.n	8009a72 <cmdSyslog+0x3e>
 8009a42:	4942      	ldr	r1, [pc, #264]	; (8009b4c <cmdSyslog+0x118>)
 8009a44:	6818      	ldr	r0, [r3, #0]
 8009a46:	f7fa f8bb 	bl	8003bc0 <strcmp>
 8009a4a:	4604      	mov	r4, r0
 8009a4c:	b9f8      	cbnz	r0, 8009a8e <cmdSyslog+0x5a>
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009a4e:	4b40      	ldr	r3, [pc, #256]	; (8009b50 <cmdSyslog+0x11c>)
 8009a50:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009a54:	681d      	ldr	r5, [r3, #0]
 8009a56:	4628      	mov	r0, r5
 8009a58:	f7fb fcf2 	bl	8005440 <xQueueSemaphoreTake>
    }
}

void packetQueueInit(PacketQueue_t* queue, void* buffer, uint32_t bufferSize)
{
    memset(queue, 0, sizeof(*queue));
 8009a5c:	221c      	movs	r2, #28
 8009a5e:	4621      	mov	r1, r4
 8009a60:	483c      	ldr	r0, [pc, #240]	; (8009b54 <cmdSyslog+0x120>)
 8009a62:	f001 feab 	bl	800b7bc <memset>
    xSemaphoreGive(syslogSemaphore);
 8009a66:	4628      	mov	r0, r5
}
 8009a68:	b007      	add	sp, #28
 8009a6a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            i += readBytes;
        }
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
    }
    packetQueueEndReadTransaction(&syslogQueue, true);
    xSemaphoreGive(syslogSemaphore);
 8009a6e:	f7fe bccf 	b.w	8008410 <xQueueGenericSend.constprop.0>
    } else if(argc == 2 && !strcmp(argv[0], "add")) {
 8009a72:	2a02      	cmp	r2, #2
 8009a74:	d10b      	bne.n	8009a8e <cmdSyslog+0x5a>
 8009a76:	4938      	ldr	r1, [pc, #224]	; (8009b58 <cmdSyslog+0x124>)
 8009a78:	6818      	ldr	r0, [r3, #0]
 8009a7a:	f7fa f8a1 	bl	8003bc0 <strcmp>
 8009a7e:	b930      	cbnz	r0, 8009a8e <cmdSyslog+0x5a>
        syslog("%s", argv[1]);
 8009a80:	6861      	ldr	r1, [r4, #4]
 8009a82:	4836      	ldr	r0, [pc, #216]	; (8009b5c <cmdSyslog+0x128>)
}
 8009a84:	b007      	add	sp, #28
 8009a86:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        syslog("%s", argv[1]);
 8009a8a:	f7ff b93f 	b.w	8008d0c <syslog>
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009a8e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8009b50 <cmdSyslog+0x11c>
    if(syslogQueue.numDropped) {
 8009a92:	4c33      	ldr	r4, [pc, #204]	; (8009b60 <cmdSyslog+0x12c>)
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009a94:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009a98:	f8d8 0000 	ldr.w	r0, [r8]
 8009a9c:	f7fb fcd0 	bl	8005440 <xQueueSemaphoreTake>
    if(syslogQueue.numDropped) {
 8009aa0:	6a22      	ldr	r2, [r4, #32]
 8009aa2:	b11a      	cbz	r2, 8009aac <cmdSyslog+0x78>
        chprintf(chp, "... %u dropped ..."SHELL_NEWLINE_STR, syslogQueue.numDropped);
 8009aa4:	4628      	mov	r0, r5
 8009aa6:	492f      	ldr	r1, [pc, #188]	; (8009b64 <cmdSyslog+0x130>)
 8009aa8:	f7fe fe17 	bl	80086da <chprintf>
    queue->readPtrStored = queue->readPtr;
 8009aac:	68a3      	ldr	r3, [r4, #8]
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
 8009aae:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 8009b68 <cmdSyslog+0x134>
 8009ab2:	60e3      	str	r3, [r4, #12]
    queue->pktCountStored = queue->pktCount;
 8009ab4:	8aa3      	ldrh	r3, [r4, #20]
 8009ab6:	82e3      	strh	r3, [r4, #22]
    if(!queue->pktCount) {
 8009ab8:	8aa3      	ldrh	r3, [r4, #20]
 8009aba:	b943      	cbnz	r3, 8009ace <cmdSyslog+0x9a>
        queue->readPtr = queue->readPtrStored;
 8009abc:	68e3      	ldr	r3, [r4, #12]
    xSemaphoreGive(syslogSemaphore);
 8009abe:	f8d8 0000 	ldr.w	r0, [r8]
 8009ac2:	60a3      	str	r3, [r4, #8]
        queue->pktCount = queue->pktCountStored;
 8009ac4:	8ae3      	ldrh	r3, [r4, #22]
 8009ac6:	82a3      	strh	r3, [r4, #20]
 8009ac8:	e7ce      	b.n	8009a68 <cmdSyslog+0x34>
        return 0;
 8009aca:	463e      	mov	r6, r7
 8009acc:	e02a      	b.n	8009b24 <cmdSyslog+0xf0>
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009ace:	f7fc fa4b 	bl	8005f68 <packetQueueReadByte.constprop.0>
 8009ad2:	4606      	mov	r6, r0
                    (packetQueueReadByte(queue));
 8009ad4:	f7fc fa48 	bl	8005f68 <packetQueueReadByte.constprop.0>
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009ad8:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
    return queue->pktLen;
 8009adc:	b283      	uxth	r3, r0
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009ade:	61a0      	str	r0, [r4, #24]
    return queue->pktLen;
 8009ae0:	9300      	str	r3, [sp, #0]
    while((len = packetQueueReadPacket(&syslogQueue))) {
 8009ae2:	2800      	cmp	r0, #0
 8009ae4:	d0ea      	beq.n	8009abc <cmdSyslog+0x88>
        uint16_t i = 0;
 8009ae6:	f04f 0900 	mov.w	r9, #0
    if(!queue->pktLen) {
 8009aea:	69a7      	ldr	r7, [r4, #24]
 8009aec:	2f00      	cmp	r7, #0
 8009aee:	d0ec      	beq.n	8009aca <cmdSyslog+0x96>
    if(bufLen > queue->pktLen) {
 8009af0:	2f0c      	cmp	r7, #12
 8009af2:	bf28      	it	cs
 8009af4:	270c      	movcs	r7, #12
        for(uint16_t i=0; i<bufLen; i++) {
 8009af6:	f04f 0b00 	mov.w	fp, #0
 8009afa:	b2be      	uxth	r6, r7
 8009afc:	aa03      	add	r2, sp, #12
 8009afe:	9201      	str	r2, [sp, #4]
            buffer[i] = packetQueueReadByte(queue);
 8009b00:	f7fc fa32 	bl	8005f68 <packetQueueReadByte.constprop.0>
        for(uint16_t i=0; i<bufLen; i++) {
 8009b04:	f10b 0b01 	add.w	fp, fp, #1
            buffer[i] = packetQueueReadByte(queue);
 8009b08:	9a01      	ldr	r2, [sp, #4]
        for(uint16_t i=0; i<bufLen; i++) {
 8009b0a:	fa1f fb8b 	uxth.w	fp, fp
 8009b0e:	45b3      	cmp	fp, r6
            buffer[i] = packetQueueReadByte(queue);
 8009b10:	f802 0b01 	strb.w	r0, [r2], #1
        for(uint16_t i=0; i<bufLen; i++) {
 8009b14:	d3f3      	bcc.n	8009afe <cmdSyslog+0xca>
    queue->pktLen -= bufLen;
 8009b16:	69a2      	ldr	r2, [r4, #24]
 8009b18:	1bd7      	subs	r7, r2, r7
 8009b1a:	61a7      	str	r7, [r4, #24]
    if(!queue->pktLen) {
 8009b1c:	b917      	cbnz	r7, 8009b24 <cmdSyslog+0xf0>
        queue->pktCount--;
 8009b1e:	8aa2      	ldrh	r2, [r4, #20]
 8009b20:	3a01      	subs	r2, #1
 8009b22:	82a2      	strh	r2, [r4, #20]
            chnWrite(chp, tmpBuf, readBytes);
 8009b24:	682a      	ldr	r2, [r5, #0]
 8009b26:	4628      	mov	r0, r5
 8009b28:	6817      	ldr	r7, [r2, #0]
 8009b2a:	a903      	add	r1, sp, #12
 8009b2c:	4632      	mov	r2, r6
 8009b2e:	47b8      	blx	r7
            i += readBytes;
 8009b30:	444e      	add	r6, r9
        while(i < len) {
 8009b32:	9b00      	ldr	r3, [sp, #0]
            i += readBytes;
 8009b34:	fa1f f986 	uxth.w	r9, r6
        while(i < len) {
 8009b38:	4599      	cmp	r9, r3
 8009b3a:	d3d6      	bcc.n	8009aea <cmdSyslog+0xb6>
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
 8009b3c:	682b      	ldr	r3, [r5, #0]
 8009b3e:	2202      	movs	r2, #2
 8009b40:	4651      	mov	r1, sl
 8009b42:	4628      	mov	r0, r5
 8009b44:	681b      	ldr	r3, [r3, #0]
 8009b46:	4798      	blx	r3
 8009b48:	e7b6      	b.n	8009ab8 <cmdSyslog+0x84>
 8009b4a:	bf00      	nop
 8009b4c:	0800c05a 	.word	0x0800c05a
 8009b50:	20001334 	.word	0x20001334
 8009b54:	20001318 	.word	0x20001318
 8009b58:	0800c26b 	.word	0x0800c26b
 8009b5c:	0800bc2f 	.word	0x0800bc2f
 8009b60:	20001310 	.word	0x20001310
 8009b64:	0800c26f 	.word	0x0800c26f
 8009b68:	0800be0f 	.word	0x0800be0f

08009b6c <shellStartThread>:
{
 8009b6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009b70:	4681      	mov	r9, r0
  *(scfg->sc_histbuf) = 0;
 8009b72:	f04f 0b00 	mov.w	fp, #0
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 8009b76:	4bb6      	ldr	r3, [pc, #728]	; (8009e50 <shellStartThread+0x2e4>)
 8009b78:	b0a3      	sub	sp, #140	; 0x8c
 8009b7a:	681b      	ldr	r3, [r3, #0]
    syslog("Shell 0x%08x started (%s).", activeShell, activeShell->taskName);
 8009b7c:	4601      	mov	r1, r0
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 8009b7e:	65d8      	str	r0, [r3, #92]	; 0x5c
 8009b80:	6802      	ldr	r2, [r0, #0]
 8009b82:	48b4      	ldr	r0, [pc, #720]	; (8009e54 <shellStartThread+0x2e8>)
 8009b84:	f7ff f8c2 	bl	8008d0c <syslog>
  const ShellCommand *scp = scfg->sc_commands;
 8009b88:	e9d9 7301 	ldrd	r7, r3, [r9, #4]
 8009b8c:	9302      	str	r3, [sp, #8]
  *(scfg->sc_histbuf) = 0;
 8009b8e:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8009b92:	f883 b000 	strb.w	fp, [r3]
  ShellHistory hist = {
 8009b96:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8009b9a:	e9cd bb0a 	strd	fp, fp, [sp, #40]	; 0x28
 8009b9e:	9307      	str	r3, [sp, #28]
 8009ba0:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8009ba4:	e9cd 3b08 	strd	r3, fp, [sp, #32]
  chprintf(chp, SHELL_NEWLINE_STR);
 8009ba8:	49ab      	ldr	r1, [pc, #684]	; (8009e58 <shellStartThread+0x2ec>)
 8009baa:	4638      	mov	r0, r7
 8009bac:	f7fe fd95 	bl	80086da <chprintf>
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
#if SHELL_USE_ESC_SEQ == TRUE
  bool escape = false;
  bool bracket = false;
 8009bb0:	f04f 0800 	mov.w	r8, #0
  char *p = line;
 8009bb4:	ad12      	add	r5, sp, #72	; 0x48
  bool escape = false;
 8009bb6:	46c2      	mov	sl, r8
 8009bb8:	462e      	mov	r6, r5
    chprintf(chp, SHELL_PROMPT_STR);
 8009bba:	4638      	mov	r0, r7
 8009bbc:	49a7      	ldr	r1, [pc, #668]	; (8009e5c <shellStartThread+0x2f0>)
 8009bbe:	f7fe fd8c 	bl	80086da <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8009bc2:	f8d9 4004 	ldr.w	r4, [r9, #4]
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8009bc6:	6823      	ldr	r3, [r4, #0]
 8009bc8:	2201      	movs	r2, #1
 8009bca:	4620      	mov	r0, r4
 8009bcc:	685b      	ldr	r3, [r3, #4]
 8009bce:	f10d 0117 	add.w	r1, sp, #23
 8009bd2:	4798      	blx	r3
 8009bd4:	2800      	cmp	r0, #0
 8009bd6:	d041      	beq.n	8009c5c <shellStartThread+0xf0>
      return true;
#if SHELL_USE_ESC_SEQ == TRUE
    if (c == 27) {
 8009bd8:	f89d 1017 	ldrb.w	r1, [sp, #23]
 8009bdc:	291b      	cmp	r1, #27
 8009bde:	f000 8129 	beq.w	8009e34 <shellStartThread+0x2c8>
      escape = true;
      continue;
    }
    if (escape) {
 8009be2:	f1ba 0f00 	cmp.w	sl, #0
 8009be6:	d033      	beq.n	8009c50 <shellStartThread+0xe4>
      escape = false;
      if (c == '[') {
 8009be8:	295b      	cmp	r1, #91	; 0x5b
 8009bea:	f000 8126 	beq.w	8009e3a <shellStartThread+0x2ce>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
 8009bee:	f1b8 0f00 	cmp.w	r8, #0
 8009bf2:	d02b      	beq.n	8009c4c <shellStartThread+0xe0>
        bracket = false;
#if SHELL_USE_HISTORY == TRUE
        if (c == 'A') {
 8009bf4:	2941      	cmp	r1, #65	; 0x41
 8009bf6:	d119      	bne.n	8009c2c <shellStartThread+0xc0>
          int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 8009bf8:	2200      	movs	r2, #0
 8009bfa:	4631      	mov	r1, r6
 8009bfc:	a807      	add	r0, sp, #28
 8009bfe:	f7fd ff8a 	bl	8007b16 <get_history>

          if (len > 0) {
 8009c02:	f1b0 0800 	subs.w	r8, r0, #0
 8009c06:	dd1f      	ble.n	8009c48 <shellStartThread+0xdc>

          if (len == 0)
            *line = 0;

          if (len >= 0) {
            _shell_reset_cur(chp);
 8009c08:	2308      	movs	r3, #8
 8009c0a:	224a      	movs	r2, #74	; 0x4a
 8009c0c:	4994      	ldr	r1, [pc, #592]	; (8009e60 <shellStartThread+0x2f4>)
 8009c0e:	4620      	mov	r0, r4
 8009c10:	f7fe fd63 	bl	80086da <chprintf>
            _shell_clr_line(chp);
 8009c14:	4993      	ldr	r1, [pc, #588]	; (8009e64 <shellStartThread+0x2f8>)
 8009c16:	4620      	mov	r0, r4
 8009c18:	f7fe fd5f 	bl	80086da <chprintf>
            chprintf(chp, "%s", line);
 8009c1c:	4632      	mov	r2, r6
 8009c1e:	4620      	mov	r0, r4
 8009c20:	4991      	ldr	r1, [pc, #580]	; (8009e68 <shellStartThread+0x2fc>)
 8009c22:	f7fe fd5a 	bl	80086da <chprintf>
            p = line + len;
 8009c26:	eb06 0508 	add.w	r5, r6, r8
 8009c2a:	e00d      	b.n	8009c48 <shellStartThread+0xdc>
        if (c == 'B') {
 8009c2c:	2942      	cmp	r1, #66	; 0x42
 8009c2e:	d10b      	bne.n	8009c48 <shellStartThread+0xdc>
          int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 8009c30:	2201      	movs	r2, #1
 8009c32:	4631      	mov	r1, r6
 8009c34:	a807      	add	r0, sp, #28
 8009c36:	f7fd ff6e 	bl	8007b16 <get_history>
          if (len == 0)
 8009c3a:	f1b0 0800 	subs.w	r8, r0, #0
 8009c3e:	d102      	bne.n	8009c46 <shellStartThread+0xda>
            *line = 0;
 8009c40:	f88d 8048 	strb.w	r8, [sp, #72]	; 0x48
 8009c44:	e7e0      	b.n	8009c08 <shellStartThread+0x9c>
          if (len >= 0) {
 8009c46:	dadf      	bge.n	8009c08 <shellStartThread+0x9c>
        bracket = false;
 8009c48:	f04f 0800 	mov.w	r8, #0
      escape = false;
 8009c4c:	46c2      	mov	sl, r8
 8009c4e:	e7ba      	b.n	8009bc6 <shellStartThread+0x5a>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8009c50:	2904      	cmp	r1, #4
 8009c52:	d116      	bne.n	8009c82 <shellStartThread+0x116>
      chprintf(chp, "^D");
 8009c54:	4620      	mov	r0, r4
 8009c56:	4985      	ldr	r1, [pc, #532]	; (8009e6c <shellStartThread+0x300>)
 8009c58:	f7fe fd3f 	bl	80086da <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 8009c5c:	4638      	mov	r0, r7
 8009c5e:	497e      	ldr	r1, [pc, #504]	; (8009e58 <shellStartThread+0x2ec>)
 8009c60:	f7fe fd3b 	bl	80086da <chprintf>
      chprintf(chp, "logout");
 8009c64:	4982      	ldr	r1, [pc, #520]	; (8009e70 <shellStartThread+0x304>)
 8009c66:	4638      	mov	r0, r7
 8009c68:	f7fe fd37 	bl	80086da <chprintf>
  chSysLock();
 8009c6c:	f7fa fe9a 	bl	80049a4 <vPortEnterCritical>
    osalEventBroadcastFlagsI(event_source, 1);
 8009c70:	4880      	ldr	r0, [pc, #512]	; (8009e74 <shellStartThread+0x308>)
 8009c72:	2101      	movs	r1, #1
 8009c74:	f7fd f936 	bl	8006ee4 <osalEventBroadcastFlagsI>
    vTaskDelete(NULL);
 8009c78:	f7fc fa02 	bl	8006080 <vTaskDelete.constprop.0>
}
 8009c7c:	b023      	add	sp, #140	; 0x8c
 8009c7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8009c82:	2908      	cmp	r1, #8
 8009c84:	d001      	beq.n	8009c8a <shellStartThread+0x11e>
 8009c86:	297f      	cmp	r1, #127	; 0x7f
 8009c88:	d112      	bne.n	8009cb0 <shellStartThread+0x144>
      if (p != line) {
 8009c8a:	42b5      	cmp	r5, r6
 8009c8c:	d09b      	beq.n	8009bc6 <shellStartThread+0x5a>
        streamPut(chp, 0x08);
 8009c8e:	6823      	ldr	r3, [r4, #0]
 8009c90:	2108      	movs	r1, #8
 8009c92:	689b      	ldr	r3, [r3, #8]
 8009c94:	4620      	mov	r0, r4
 8009c96:	4798      	blx	r3
        streamPut(chp, 0x20);
 8009c98:	6823      	ldr	r3, [r4, #0]
 8009c9a:	2120      	movs	r1, #32
 8009c9c:	689b      	ldr	r3, [r3, #8]
 8009c9e:	4620      	mov	r0, r4
 8009ca0:	4798      	blx	r3
        streamPut(chp, 0x08);
 8009ca2:	6823      	ldr	r3, [r4, #0]
 8009ca4:	2108      	movs	r1, #8
 8009ca6:	4620      	mov	r0, r4
 8009ca8:	689b      	ldr	r3, [r3, #8]
 8009caa:	4798      	blx	r3
        p--;
 8009cac:	3d01      	subs	r5, #1
 8009cae:	e78a      	b.n	8009bc6 <shellStartThread+0x5a>
      }
      continue;
    }
    if (c == '\r') {
 8009cb0:	290d      	cmp	r1, #13
 8009cb2:	f040 8081 	bne.w	8009db8 <shellStartThread+0x24c>
      chprintf(chp, SHELL_NEWLINE_STR);
 8009cb6:	4620      	mov	r0, r4
 8009cb8:	4967      	ldr	r1, [pc, #412]	; (8009e58 <shellStartThread+0x2ec>)
 8009cba:	f7fe fd0e 	bl	80086da <chprintf>
  if (length > shp->sh_size - 2)
 8009cbe:	9908      	ldr	r1, [sp, #32]
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
 8009cc0:	1bac      	subs	r4, r5, r6
  if (length > shp->sh_size - 2)
 8009cc2:	1e4b      	subs	r3, r1, #1
 8009cc4:	429c      	cmp	r4, r3
 8009cc6:	da06      	bge.n	8009cd6 <shellStartThread+0x16a>
 8009cc8:	462b      	mov	r3, r5
  while ((*(line + length -1) == ' ') && (length > 0))
 8009cca:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8009cce:	2a20      	cmp	r2, #32
 8009cd0:	d12d      	bne.n	8009d2e <shellStartThread+0x1c2>
 8009cd2:	2c00      	cmp	r4, #0
 8009cd4:	dc29      	bgt.n	8009d2a <shellStartThread+0x1be>
    lp = parse_arguments(line, &tokp);
 8009cd6:	4630      	mov	r0, r6
#endif
      *p = 0;
 8009cd8:	f885 b000 	strb.w	fp, [r5]
    lp = parse_arguments(line, &tokp);
 8009cdc:	a906      	add	r1, sp, #24
 8009cde:	f7ff fc3d 	bl	800955c <parse_arguments>
 8009ce2:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 8009ce6:	4604      	mov	r4, r0
    n = 0;
 8009ce8:	2600      	movs	r6, #0
 8009cea:	4645      	mov	r5, r8
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8009cec:	2000      	movs	r0, #0
 8009cee:	a906      	add	r1, sp, #24
 8009cf0:	f7ff fc34 	bl	800955c <parse_arguments>
 8009cf4:	2800      	cmp	r0, #0
 8009cf6:	f040 80a2 	bne.w	8009e3e <shellStartThread+0x2d2>
    args[n] = NULL;
 8009cfa:	ab22      	add	r3, sp, #136	; 0x88
 8009cfc:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8009d00:	f843 0c58 	str.w	r0, [r3, #-88]
    if (cmd != NULL) {
 8009d04:	2c00      	cmp	r4, #0
 8009d06:	f43f af53 	beq.w	8009bb0 <shellStartThread+0x44>
      if (strcmp(cmd, "help") == 0) {
 8009d0a:	4620      	mov	r0, r4
 8009d0c:	495a      	ldr	r1, [pc, #360]	; (8009e78 <shellStartThread+0x30c>)
 8009d0e:	f7f9 ff57 	bl	8003bc0 <strcmp>
 8009d12:	2800      	cmp	r0, #0
 8009d14:	f040 80da 	bne.w	8009ecc <shellStartThread+0x360>
        if (n > 0) {
 8009d18:	2e00      	cmp	r6, #0
 8009d1a:	f000 80b7 	beq.w	8009e8c <shellStartThread+0x320>
          shellUsage(chp, "help");
 8009d1e:	4638      	mov	r0, r7
 8009d20:	4a55      	ldr	r2, [pc, #340]	; (8009e78 <shellStartThread+0x30c>)
 8009d22:	4956      	ldr	r1, [pc, #344]	; (8009e7c <shellStartThread+0x310>)
 8009d24:	f7fe fcd9 	bl	80086da <chprintf>
          continue;
 8009d28:	e742      	b.n	8009bb0 <shellStartThread+0x44>
    length--;
 8009d2a:	3c01      	subs	r4, #1
 8009d2c:	e7cd      	b.n	8009cca <shellStartThread+0x15e>
  if (length <= 0)
 8009d2e:	2c00      	cmp	r4, #0
 8009d30:	ddd1      	ble.n	8009cd6 <shellStartThread+0x16a>
  if (shp->sh_end >= shp->sh_beg) {
 8009d32:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 8009d34:	9807      	ldr	r0, [sp, #28]
  if (shp->sh_end >= shp->sh_beg) {
 8009d36:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8009d3a:	4562      	cmp	r2, ip
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8009d3c:	bfa5      	ittet	ge
 8009d3e:	eba2 030c 	subge.w	r3, r2, ip
 8009d42:	3301      	addge	r3, #1
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8009d44:	ebac 0302 	sublt.w	r3, ip, r2
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8009d48:	1acb      	subge	r3, r1, r3
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8009d4a:	bfb8      	it	lt
 8009d4c:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 8009d50:	429c      	cmp	r4, r3
 8009d52:	da1e      	bge.n	8009d92 <shellStartThread+0x226>
  if (length < shp->sh_size - shp->sh_end - 1)
 8009d54:	eba1 0802 	sub.w	r8, r1, r2
 8009d58:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009d5c:	3201      	adds	r2, #1
  if (length < shp->sh_size - shp->sh_end - 1)
 8009d5e:	4544      	cmp	r4, r8
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009d60:	4410      	add	r0, r2
  if (length < shp->sh_size - shp->sh_end - 1)
 8009d62:	da1f      	bge.n	8009da4 <shellStartThread+0x238>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009d64:	4622      	mov	r2, r4
 8009d66:	4631      	mov	r1, r6
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 8009d68:	f7f9 feb4 	bl	8003ad4 <memcpy>
  *(shp->sh_buffer + shp->sh_end) = (char)length;
 8009d6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009d6e:	9a07      	ldr	r2, [sp, #28]
 8009d70:	54d4      	strb	r4, [r2, r3]
  shp->sh_end += length + 1;
 8009d72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009d74:	3401      	adds	r4, #1
 8009d76:	441c      	add	r4, r3
  if (shp->sh_end >= shp->sh_size)
 8009d78:	9b08      	ldr	r3, [sp, #32]
  shp->sh_end += length + 1;
 8009d7a:	940a      	str	r4, [sp, #40]	; 0x28
  if (shp->sh_end >= shp->sh_size)
 8009d7c:	429c      	cmp	r4, r3
    shp->sh_end -= shp->sh_size;
 8009d7e:	bfa4      	itt	ge
 8009d80:	1ae4      	subge	r4, r4, r3
 8009d82:	940a      	strge	r4, [sp, #40]	; 0x28
  *(shp->sh_buffer + shp->sh_end) = 0;
 8009d84:	9a07      	ldr	r2, [sp, #28]
 8009d86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009d88:	f802 b003 	strb.w	fp, [r2, r3]
  shp->sh_cur = 0;
 8009d8c:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8009d90:	e7a1      	b.n	8009cd6 <shellStartThread+0x16a>
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 8009d92:	f810 300c 	ldrb.w	r3, [r0, ip]
 8009d96:	4463      	add	r3, ip
 8009d98:	3301      	adds	r3, #1
  if (pos >= shp->sh_size)
 8009d9a:	4299      	cmp	r1, r3
    pos -= shp->sh_size;
 8009d9c:	bfd8      	it	le
 8009d9e:	1a5b      	suble	r3, r3, r1
  shp->sh_beg = pos;
 8009da0:	9309      	str	r3, [sp, #36]	; 0x24
}
 8009da2:	e7c8      	b.n	8009d36 <shellStartThread+0x1ca>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
 8009da4:	4642      	mov	r2, r8
 8009da6:	4631      	mov	r1, r6
 8009da8:	f7f9 fe94 	bl	8003ad4 <memcpy>
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 8009dac:	9807      	ldr	r0, [sp, #28]
 8009dae:	eba4 0208 	sub.w	r2, r4, r8
 8009db2:	eb06 0108 	add.w	r1, r6, r8
 8009db6:	e7d7      	b.n	8009d68 <shellStartThread+0x1fc>
      }
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
 8009db8:	290e      	cmp	r1, #14
 8009dba:	d11e      	bne.n	8009dfa <shellStartThread+0x28e>
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 8009dbc:	2201      	movs	r2, #1
 8009dbe:	4631      	mov	r1, r6
 8009dc0:	a807      	add	r0, sp, #28
 8009dc2:	f7fd fea8 	bl	8007b16 <get_history>

      if (len == 0)
 8009dc6:	1e03      	subs	r3, r0, #0
 8009dc8:	9303      	str	r3, [sp, #12]
 8009dca:	d113      	bne.n	8009df4 <shellStartThread+0x288>
        *line = 0;
 8009dcc:	f88d a048 	strb.w	sl, [sp, #72]	; 0x48
    }
    if (c == 16) {
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);

      if (len > 0) {
        _shell_reset_cur(chp);
 8009dd0:	2308      	movs	r3, #8
 8009dd2:	224a      	movs	r2, #74	; 0x4a
 8009dd4:	4922      	ldr	r1, [pc, #136]	; (8009e60 <shellStartThread+0x2f4>)
 8009dd6:	4620      	mov	r0, r4
 8009dd8:	f7fe fc7f 	bl	80086da <chprintf>
        _shell_clr_line(chp);
 8009ddc:	4921      	ldr	r1, [pc, #132]	; (8009e64 <shellStartThread+0x2f8>)
 8009dde:	4620      	mov	r0, r4
 8009de0:	f7fe fc7b 	bl	80086da <chprintf>
        chprintf(chp, "%s", line);
 8009de4:	4632      	mov	r2, r6
 8009de6:	4620      	mov	r0, r4
 8009de8:	491f      	ldr	r1, [pc, #124]	; (8009e68 <shellStartThread+0x2fc>)
 8009dea:	f7fe fc76 	bl	80086da <chprintf>
        p = line + len;
 8009dee:	9d03      	ldr	r5, [sp, #12]
 8009df0:	4435      	add	r5, r6
 8009df2:	e6e8      	b.n	8009bc6 <shellStartThread+0x5a>
      if (len >= 0) {
 8009df4:	f6ff aee7 	blt.w	8009bc6 <shellStartThread+0x5a>
 8009df8:	e7ea      	b.n	8009dd0 <shellStartThread+0x264>
    if (c == 16) {
 8009dfa:	2910      	cmp	r1, #16
 8009dfc:	d109      	bne.n	8009e12 <shellStartThread+0x2a6>
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 8009dfe:	4652      	mov	r2, sl
 8009e00:	4631      	mov	r1, r6
 8009e02:	a807      	add	r0, sp, #28
 8009e04:	f7fd fe87 	bl	8007b16 <get_history>
      if (len > 0) {
 8009e08:	1e03      	subs	r3, r0, #0
 8009e0a:	9303      	str	r3, [sp, #12]
 8009e0c:	f77f aedb 	ble.w	8009bc6 <shellStartThread+0x5a>
 8009e10:	e7de      	b.n	8009dd0 <shellStartThread+0x264>
      }
      continue;
    }
#endif
    if (c < 0x20)
 8009e12:	291f      	cmp	r1, #31
 8009e14:	f67f aed7 	bls.w	8009bc6 <shellStartThread+0x5a>
      continue;
    if (p < line + size - 1) {
 8009e18:	f10d 0387 	add.w	r3, sp, #135	; 0x87
 8009e1c:	429d      	cmp	r5, r3
 8009e1e:	f4bf aed2 	bcs.w	8009bc6 <shellStartThread+0x5a>
      streamPut(chp, c);
 8009e22:	6823      	ldr	r3, [r4, #0]
 8009e24:	4620      	mov	r0, r4
 8009e26:	689b      	ldr	r3, [r3, #8]
 8009e28:	4798      	blx	r3
      *p++ = (char)c;
 8009e2a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009e2e:	f805 3b01 	strb.w	r3, [r5], #1
 8009e32:	e6c8      	b.n	8009bc6 <shellStartThread+0x5a>
      escape = true;
 8009e34:	f04f 0a01 	mov.w	sl, #1
 8009e38:	e6c5      	b.n	8009bc6 <shellStartThread+0x5a>
        bracket = true;
 8009e3a:	46d0      	mov	r8, sl
 8009e3c:	e6c3      	b.n	8009bc6 <shellStartThread+0x5a>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8009e3e:	2e05      	cmp	r6, #5
 8009e40:	d120      	bne.n	8009e84 <shellStartThread+0x318>
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
 8009e42:	4638      	mov	r0, r7
 8009e44:	490e      	ldr	r1, [pc, #56]	; (8009e80 <shellStartThread+0x314>)
 8009e46:	f7fe fc48 	bl	80086da <chprintf>
    args[n] = NULL;
 8009e4a:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
    if (cmd != NULL) {
 8009e4e:	e6af      	b.n	8009bb0 <shellStartThread+0x44>
 8009e50:	200011a8 	.word	0x200011a8
 8009e54:	0800c284 	.word	0x0800c284
 8009e58:	0800be0f 	.word	0x0800be0f
 8009e5c:	0800c29f 	.word	0x0800c29f
 8009e60:	0800c2a8 	.word	0x0800c2a8
 8009e64:	0800c2b3 	.word	0x0800c2b3
 8009e68:	0800bc2f 	.word	0x0800bc2f
 8009e6c:	0800c2b7 	.word	0x0800c2b7
 8009e70:	0800c2ba 	.word	0x0800c2ba
 8009e74:	200012b8 	.word	0x200012b8
 8009e78:	0800c2d6 	.word	0x0800c2d6
 8009e7c:	0800ba7a 	.word	0x0800ba7a
 8009e80:	0800c2c1 	.word	0x0800c2c1
      args[n++] = lp;
 8009e84:	3601      	adds	r6, #1
 8009e86:	f848 0b04 	str.w	r0, [r8], #4
 8009e8a:	e72f      	b.n	8009cec <shellStartThread+0x180>
        chprintf(chp, "Commands: help ");
 8009e8c:	4638      	mov	r0, r7
 8009e8e:	491e      	ldr	r1, [pc, #120]	; (8009f08 <shellStartThread+0x39c>)
 8009e90:	f7fe fc23 	bl	80086da <chprintf>
  while (scp->sc_name != NULL) {
 8009e94:	4c1d      	ldr	r4, [pc, #116]	; (8009f0c <shellStartThread+0x3a0>)
    chprintf(chp, "%s ", scp->sc_name);
 8009e96:	4d1e      	ldr	r5, [pc, #120]	; (8009f10 <shellStartThread+0x3a4>)
  while (scp->sc_name != NULL) {
 8009e98:	6822      	ldr	r2, [r4, #0]
 8009e9a:	b98a      	cbnz	r2, 8009ec0 <shellStartThread+0x354>
        if (scp != NULL)
 8009e9c:	9b02      	ldr	r3, [sp, #8]
 8009e9e:	2b00      	cmp	r3, #0
 8009ea0:	f43f ae82 	beq.w	8009ba8 <shellStartThread+0x3c>
    chprintf(chp, "%s ", scp->sc_name);
 8009ea4:	4d1a      	ldr	r5, [pc, #104]	; (8009f10 <shellStartThread+0x3a4>)
 8009ea6:	f103 040c 	add.w	r4, r3, #12
  while (scp->sc_name != NULL) {
 8009eaa:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 8009eae:	340c      	adds	r4, #12
 8009eb0:	2a00      	cmp	r2, #0
 8009eb2:	f43f ae79 	beq.w	8009ba8 <shellStartThread+0x3c>
    chprintf(chp, "%s ", scp->sc_name);
 8009eb6:	4629      	mov	r1, r5
 8009eb8:	4638      	mov	r0, r7
 8009eba:	f7fe fc0e 	bl	80086da <chprintf>
    scp++;
 8009ebe:	e7f4      	b.n	8009eaa <shellStartThread+0x33e>
    chprintf(chp, "%s ", scp->sc_name);
 8009ec0:	4629      	mov	r1, r5
 8009ec2:	4638      	mov	r0, r7
 8009ec4:	f7fe fc09 	bl	80086da <chprintf>
    scp++;
 8009ec8:	340c      	adds	r4, #12
 8009eca:	e7e5      	b.n	8009e98 <shellStartThread+0x32c>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8009ecc:	4633      	mov	r3, r6
 8009ece:	4622      	mov	r2, r4
 8009ed0:	4639      	mov	r1, r7
 8009ed2:	480e      	ldr	r0, [pc, #56]	; (8009f0c <shellStartThread+0x3a0>)
 8009ed4:	9500      	str	r5, [sp, #0]
 8009ed6:	f7ff fb67 	bl	80095a8 <cmdexec>
 8009eda:	2800      	cmp	r0, #0
 8009edc:	f43f ae68 	beq.w	8009bb0 <shellStartThread+0x44>
 8009ee0:	9b02      	ldr	r3, [sp, #8]
 8009ee2:	b933      	cbnz	r3, 8009ef2 <shellStartThread+0x386>
        chprintf(chp, "%s", cmd);
 8009ee4:	490b      	ldr	r1, [pc, #44]	; (8009f14 <shellStartThread+0x3a8>)
 8009ee6:	4622      	mov	r2, r4
 8009ee8:	4638      	mov	r0, r7
 8009eea:	f7fe fbf6 	bl	80086da <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
 8009eee:	490a      	ldr	r1, [pc, #40]	; (8009f18 <shellStartThread+0x3ac>)
 8009ef0:	e65b      	b.n	8009baa <shellStartThread+0x3e>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8009ef2:	4633      	mov	r3, r6
 8009ef4:	4622      	mov	r2, r4
 8009ef6:	4639      	mov	r1, r7
 8009ef8:	9802      	ldr	r0, [sp, #8]
 8009efa:	9500      	str	r5, [sp, #0]
 8009efc:	f7ff fb54 	bl	80095a8 <cmdexec>
 8009f00:	2800      	cmp	r0, #0
 8009f02:	d1ef      	bne.n	8009ee4 <shellStartThread+0x378>
 8009f04:	e654      	b.n	8009bb0 <shellStartThread+0x44>
 8009f06:	bf00      	nop
 8009f08:	0800c2db 	.word	0x0800c2db
 8009f0c:	0800cb38 	.word	0x0800cb38
 8009f10:	0800c2eb 	.word	0x0800c2eb
 8009f14:	0800bc2f 	.word	0x0800bc2f
 8009f18:	0800c2ef 	.word	0x0800c2ef

08009f1c <cmdThreadInfo>:
    else if(state == eDeleted) printfFixed(chp, 9, "Deleted");
    else printfFixed(chp, 9, "Invalid");
}

void cmdThreadInfo(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 8009f1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    (void)argc;
    (void)argv;
    (void) user;

    unsigned int numberOfTasks = uxTaskGetNumberOfTasks();
    TaskStatus_t* taskStatusArray = pvPortMalloc(numberOfTasks * sizeof(TaskStatus_t));
 8009f20:	2624      	movs	r6, #36	; 0x24
	return uxCurrentNumberOfTasks;
 8009f22:	f8df 8260 	ldr.w	r8, [pc, #608]	; 800a184 <cmdThreadInfo+0x268>
{
 8009f26:	b085      	sub	sp, #20
 8009f28:	f8d8 5000 	ldr.w	r5, [r8]
 8009f2c:	460c      	mov	r4, r1
    TaskStatus_t* taskStatusArray = pvPortMalloc(numberOfTasks * sizeof(TaskStatus_t));
 8009f2e:	fb06 f005 	mul.w	r0, r6, r5
 8009f32:	f7fb f96f 	bl	8005214 <pvPortMalloc>
    if(!taskStatusArray) {
 8009f36:	4607      	mov	r7, r0
 8009f38:	2800      	cmp	r0, #0
 8009f3a:	f000 8096 	beq.w	800a06a <cmdThreadInfo+0x14e>
		vTaskSuspendAll();
 8009f3e:	f7fa fbc5 	bl	80046cc <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 8009f42:	f8d8 3000 	ldr.w	r3, [r8]
 8009f46:	429d      	cmp	r5, r3
 8009f48:	f0c0 8092 	bcc.w	800a070 <cmdThreadInfo+0x154>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8009f4c:	f04f 0805 	mov.w	r8, #5
 8009f50:	2500      	movs	r5, #0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8009f52:	f04f 0a14 	mov.w	sl, #20
 8009f56:	f8df 9230 	ldr.w	r9, [pc, #560]	; 800a188 <cmdThreadInfo+0x26c>
					uxQueue--;
 8009f5a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8009f5e:	fb06 7005 	mla	r0, r6, r5, r7
 8009f62:	2201      	movs	r2, #1
 8009f64:	fb0a 9108 	mla	r1, sl, r8, r9
 8009f68:	f7fb fbf2 	bl	8005750 <prvListTasksWithinSingleList>
 8009f6c:	4405      	add	r5, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009f6e:	f1b8 0f00 	cmp.w	r8, #0
 8009f72:	d1f2      	bne.n	8009f5a <cmdThreadInfo+0x3e>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8009f74:	4b85      	ldr	r3, [pc, #532]	; (800a18c <cmdThreadInfo+0x270>)
 8009f76:	2202      	movs	r2, #2
 8009f78:	6819      	ldr	r1, [r3, #0]
 8009f7a:	fb06 7005 	mla	r0, r6, r5, r7
 8009f7e:	f7fb fbe7 	bl	8005750 <prvListTasksWithinSingleList>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009f82:	4b83      	ldr	r3, [pc, #524]	; (800a190 <cmdThreadInfo+0x274>)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8009f84:	4405      	add	r5, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009f86:	6819      	ldr	r1, [r3, #0]
 8009f88:	2202      	movs	r2, #2
 8009f8a:	fb06 7005 	mla	r0, r6, r5, r7
 8009f8e:	f7fb fbdf 	bl	8005750 <prvListTasksWithinSingleList>
 8009f92:	4405      	add	r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 8009f94:	2204      	movs	r2, #4
 8009f96:	fb06 7005 	mla	r0, r6, r5, r7
 8009f9a:	497e      	ldr	r1, [pc, #504]	; (800a194 <cmdThreadInfo+0x278>)
 8009f9c:	f7fb fbd8 	bl	8005750 <prvListTasksWithinSingleList>
 8009fa0:	4405      	add	r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 8009fa2:	fb06 7005 	mla	r0, r6, r5, r7
 8009fa6:	2203      	movs	r2, #3
 8009fa8:	497b      	ldr	r1, [pc, #492]	; (800a198 <cmdThreadInfo+0x27c>)
 8009faa:	f7fb fbd1 	bl	8005750 <prvListTasksWithinSingleList>
 8009fae:	4405      	add	r5, r0
		( void ) xTaskResumeAll();
 8009fb0:	f7fb f8ac 	bl	800510c <xTaskResumeAll>
        return;
    }

    uint32_t totalRunTime;
    unsigned int  result = uxTaskGetSystemState(taskStatusArray, numberOfTasks, &totalRunTime);
    printfFixed(chp, 13, "Task ID");
 8009fb4:	210d      	movs	r1, #13
 8009fb6:	4a79      	ldr	r2, [pc, #484]	; (800a19c <cmdThreadInfo+0x280>)
 8009fb8:	4620      	mov	r0, r4
 8009fba:	f7fe fd37 	bl	8008a2c <printfFixed>
    printfFixed(chp, 10, "Task Name");
 8009fbe:	210a      	movs	r1, #10
 8009fc0:	4a77      	ldr	r2, [pc, #476]	; (800a1a0 <cmdThreadInfo+0x284>)
 8009fc2:	4620      	mov	r0, r4
 8009fc4:	f7fe fd32 	bl	8008a2c <printfFixed>
    printfFixed(chp, 11, "Stack Base");
 8009fc8:	210b      	movs	r1, #11
 8009fca:	4a76      	ldr	r2, [pc, #472]	; (800a1a4 <cmdThreadInfo+0x288>)
 8009fcc:	4620      	mov	r0, r4
 8009fce:	f7fe fd2d 	bl	8008a2c <printfFixed>
    printfFixed(chp, 11, "Free Stack");
 8009fd2:	210b      	movs	r1, #11
 8009fd4:	4a74      	ldr	r2, [pc, #464]	; (800a1a8 <cmdThreadInfo+0x28c>)
 8009fd6:	4620      	mov	r0, r4
 8009fd8:	f7fe fd28 	bl	8008a2c <printfFixed>
    printfFixed(chp, 6, "PrioB");
 8009fdc:	2106      	movs	r1, #6
 8009fde:	4a73      	ldr	r2, [pc, #460]	; (800a1ac <cmdThreadInfo+0x290>)
 8009fe0:	4620      	mov	r0, r4
 8009fe2:	f7fe fd23 	bl	8008a2c <printfFixed>
#if configUSE_MUTEXES
    printfFixed(chp, 6, "PrioC");
 8009fe6:	2106      	movs	r1, #6
 8009fe8:	4a71      	ldr	r2, [pc, #452]	; (800a1b0 <cmdThreadInfo+0x294>)
 8009fea:	4620      	mov	r0, r4
 8009fec:	f7fe fd1e 	bl	8008a2c <printfFixed>
#endif
    printfFixed(chp, 9, "State");
 8009ff0:	2109      	movs	r1, #9
 8009ff2:	4a70      	ldr	r2, [pc, #448]	; (800a1b4 <cmdThreadInfo+0x298>)
 8009ff4:	4620      	mov	r0, r4
 8009ff6:	f7fe fd19 	bl	8008a2c <printfFixed>
    chprintf(chp,SHELL_NEWLINE_STR);
 8009ffa:	4620      	mov	r0, r4
 8009ffc:	496e      	ldr	r1, [pc, #440]	; (800a1b8 <cmdThreadInfo+0x29c>)
 8009ffe:	f7fe fb6c 	bl	80086da <chprintf>
    for(unsigned int i = 0; i<result; i++) {
 800a002:	463e      	mov	r6, r7
 800a004:	f04f 0800 	mov.w	r8, #0
        printfFixed(chp, 13, "%u=%08x ", taskStatusArray[i].xTaskNumber, taskStatusArray[i].xHandle);
 800a008:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 800a1bc <cmdThreadInfo+0x2a0>
        if(!strcmp("IDLE", taskStatusArray[i].pcTaskName)) {
 800a00c:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 800a1c0 <cmdThreadInfo+0x2a4>
            printfFixed(chp, 10, "Idle");
        } else {
            printfFixed(chp, 10, "%s", taskStatusArray[i].pcTaskName);
 800a010:	f8df b1b0 	ldr.w	fp, [pc, #432]	; 800a1c4 <cmdThreadInfo+0x2a8>
    for(unsigned int i = 0; i<result; i++) {
 800a014:	45a8      	cmp	r8, r5
 800a016:	d12d      	bne.n	800a074 <cmdThreadInfo+0x158>
    printfFixed(chp, 11, "Descriptor");
    printfFixed(chp, 11, "Callback");
    chprintf(chp, "State"SHELL_NEWLINE_STR);

    MonitorEntry* entry = monThreadFirst;
    unsigned int index = 0;
 800a018:	2600      	movs	r6, #0
            cmdThreadPrintState(chp, taskStatusArray[i].eCurrentState);
        }
        chprintf(chp,SHELL_NEWLINE_STR);
    }

    vPortFree(taskStatusArray);
 800a01a:	4638      	mov	r0, r7
 800a01c:	f7fb f97a 	bl	8005314 <vPortFree>
    chprintf(chp,SHELL_NEWLINE_STR);
 800a020:	4965      	ldr	r1, [pc, #404]	; (800a1b8 <cmdThreadInfo+0x29c>)
 800a022:	4620      	mov	r0, r4
 800a024:	f7fe fb59 	bl	80086da <chprintf>
    printfFixed(chp, 13, "Monitor ID");
 800a028:	210d      	movs	r1, #13
 800a02a:	4a67      	ldr	r2, [pc, #412]	; (800a1c8 <cmdThreadInfo+0x2ac>)
 800a02c:	4620      	mov	r0, r4
 800a02e:	f7fe fcfd 	bl	8008a2c <printfFixed>
    printfFixed(chp, 10, "Task Name");
 800a032:	210a      	movs	r1, #10
 800a034:	4a5a      	ldr	r2, [pc, #360]	; (800a1a0 <cmdThreadInfo+0x284>)
 800a036:	4620      	mov	r0, r4
 800a038:	f7fe fcf8 	bl	8008a2c <printfFixed>
    printfFixed(chp, 11, "Descriptor");
 800a03c:	210b      	movs	r1, #11
 800a03e:	4a63      	ldr	r2, [pc, #396]	; (800a1cc <cmdThreadInfo+0x2b0>)
 800a040:	4620      	mov	r0, r4
 800a042:	f7fe fcf3 	bl	8008a2c <printfFixed>
    printfFixed(chp, 11, "Callback");
 800a046:	210b      	movs	r1, #11
 800a048:	4a61      	ldr	r2, [pc, #388]	; (800a1d0 <cmdThreadInfo+0x2b4>)
 800a04a:	4620      	mov	r0, r4
 800a04c:	f7fe fcee 	bl	8008a2c <printfFixed>
    chprintf(chp, "State"SHELL_NEWLINE_STR);
 800a050:	4620      	mov	r0, r4
 800a052:	4960      	ldr	r1, [pc, #384]	; (800a1d4 <cmdThreadInfo+0x2b8>)
 800a054:	f7fe fb41 	bl	80086da <chprintf>
    MonitorEntry* entry = monThreadFirst;
 800a058:	4b5f      	ldr	r3, [pc, #380]	; (800a1d8 <cmdThreadInfo+0x2bc>)
    while(entry) {
        printfFixed(chp, 13, "%u", index);
 800a05a:	4f60      	ldr	r7, [pc, #384]	; (800a1dc <cmdThreadInfo+0x2c0>)
    MonitorEntry* entry = monThreadFirst;
 800a05c:	681d      	ldr	r5, [r3, #0]
        if(entry->name) {
            printfFixed(chp, 10, "%s",entry->name);
        } else {
            printfFixed(chp, 10, "");
 800a05e:	f8df 8180 	ldr.w	r8, [pc, #384]	; 800a1e0 <cmdThreadInfo+0x2c4>
            printfFixed(chp, 10, "%s",entry->name);
 800a062:	f8df 9160 	ldr.w	r9, [pc, #352]	; 800a1c4 <cmdThreadInfo+0x2a8>
    while(entry) {
 800a066:	2d00      	cmp	r5, #0
 800a068:	d162      	bne.n	800a130 <cmdThreadInfo+0x214>
    monitorPrintStatus(chp);
}
 800a06a:	b005      	add	sp, #20
 800a06c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800a070:	2500      	movs	r5, #0
 800a072:	e79d      	b.n	8009fb0 <cmdThreadInfo+0x94>
        printfFixed(chp, 13, "%u=%08x ", taskStatusArray[i].xTaskNumber, taskStatusArray[i].xHandle);
 800a074:	6833      	ldr	r3, [r6, #0]
 800a076:	464a      	mov	r2, r9
 800a078:	9300      	str	r3, [sp, #0]
 800a07a:	210d      	movs	r1, #13
 800a07c:	68b3      	ldr	r3, [r6, #8]
 800a07e:	4620      	mov	r0, r4
 800a080:	f7fe fcd4 	bl	8008a2c <printfFixed>
        if(!strcmp("IDLE", taskStatusArray[i].pcTaskName)) {
 800a084:	6873      	ldr	r3, [r6, #4]
 800a086:	4650      	mov	r0, sl
 800a088:	4619      	mov	r1, r3
 800a08a:	9303      	str	r3, [sp, #12]
 800a08c:	f7f9 fd98 	bl	8003bc0 <strcmp>
 800a090:	9b03      	ldr	r3, [sp, #12]
 800a092:	2800      	cmp	r0, #0
 800a094:	d132      	bne.n	800a0fc <cmdThreadInfo+0x1e0>
            printfFixed(chp, 10, "Idle");
 800a096:	210a      	movs	r1, #10
 800a098:	4620      	mov	r0, r4
 800a09a:	4a52      	ldr	r2, [pc, #328]	; (800a1e4 <cmdThreadInfo+0x2c8>)
 800a09c:	f7fe fcc6 	bl	8008a2c <printfFixed>
        printfFixed(chp, 11, "%08x", taskStatusArray[i].pxStackBase);
 800a0a0:	210b      	movs	r1, #11
 800a0a2:	69f3      	ldr	r3, [r6, #28]
 800a0a4:	4a50      	ldr	r2, [pc, #320]	; (800a1e8 <cmdThreadInfo+0x2cc>)
 800a0a6:	4620      	mov	r0, r4
 800a0a8:	f7fe fcc0 	bl	8008a2c <printfFixed>
        printfFixed(chp, 11, "%u", (uint32_t)taskStatusArray[i].usStackHighWaterMark);
 800a0ac:	210b      	movs	r1, #11
 800a0ae:	8c33      	ldrh	r3, [r6, #32]
 800a0b0:	4a4a      	ldr	r2, [pc, #296]	; (800a1dc <cmdThreadInfo+0x2c0>)
 800a0b2:	4620      	mov	r0, r4
 800a0b4:	f7fe fcba 	bl	8008a2c <printfFixed>
        printfFixed(chp, 6, "%u", taskStatusArray[i].uxBasePriority);
 800a0b8:	2106      	movs	r1, #6
 800a0ba:	6973      	ldr	r3, [r6, #20]
 800a0bc:	4a47      	ldr	r2, [pc, #284]	; (800a1dc <cmdThreadInfo+0x2c0>)
 800a0be:	4620      	mov	r0, r4
 800a0c0:	f7fe fcb4 	bl	8008a2c <printfFixed>
        printfFixed(chp, 6, "%u", taskStatusArray[i].uxCurrentPriority);
 800a0c4:	2106      	movs	r1, #6
 800a0c6:	6933      	ldr	r3, [r6, #16]
 800a0c8:	4a44      	ldr	r2, [pc, #272]	; (800a1dc <cmdThreadInfo+0x2c0>)
 800a0ca:	4620      	mov	r0, r4
 800a0cc:	f7fe fcae 	bl	8008a2c <printfFixed>
        if(taskStatusArray[i].xHandle == xGetCurrentTaskHandle()) {
 800a0d0:	6830      	ldr	r0, [r6, #0]
    portENTER_CRITICAL();
 800a0d2:	f7fa fc67 	bl	80049a4 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 800a0d6:	4b45      	ldr	r3, [pc, #276]	; (800a1ec <cmdThreadInfo+0x2d0>)
 800a0d8:	6819      	ldr	r1, [r3, #0]
    portEXIT_CRITICAL();
 800a0da:	f7fa fe7b 	bl	8004dd4 <vPortExitCritical>
 800a0de:	4288      	cmp	r0, r1
 800a0e0:	d112      	bne.n	800a108 <cmdThreadInfo+0x1ec>
    if(state == eRunning) printfFixed(chp, 9, "Running");
 800a0e2:	4a43      	ldr	r2, [pc, #268]	; (800a1f0 <cmdThreadInfo+0x2d4>)
    else printfFixed(chp, 9, "Invalid");
 800a0e4:	2109      	movs	r1, #9
 800a0e6:	4620      	mov	r0, r4
 800a0e8:	f7fe fca0 	bl	8008a2c <printfFixed>
        chprintf(chp,SHELL_NEWLINE_STR);
 800a0ec:	4620      	mov	r0, r4
 800a0ee:	4932      	ldr	r1, [pc, #200]	; (800a1b8 <cmdThreadInfo+0x29c>)
 800a0f0:	f7fe faf3 	bl	80086da <chprintf>
    for(unsigned int i = 0; i<result; i++) {
 800a0f4:	f108 0801 	add.w	r8, r8, #1
 800a0f8:	3624      	adds	r6, #36	; 0x24
 800a0fa:	e78b      	b.n	800a014 <cmdThreadInfo+0xf8>
            printfFixed(chp, 10, "%s", taskStatusArray[i].pcTaskName);
 800a0fc:	465a      	mov	r2, fp
 800a0fe:	210a      	movs	r1, #10
 800a100:	4620      	mov	r0, r4
 800a102:	f7fe fc93 	bl	8008a2c <printfFixed>
 800a106:	e7cb      	b.n	800a0a0 <cmdThreadInfo+0x184>
            cmdThreadPrintState(chp, taskStatusArray[i].eCurrentState);
 800a108:	7b33      	ldrb	r3, [r6, #12]
    if(state == eRunning) printfFixed(chp, 9, "Running");
 800a10a:	2b00      	cmp	r3, #0
 800a10c:	d0e9      	beq.n	800a0e2 <cmdThreadInfo+0x1c6>
    else if(state == eReady) printfFixed(chp, 9, "Ready");
 800a10e:	2b01      	cmp	r3, #1
 800a110:	d101      	bne.n	800a116 <cmdThreadInfo+0x1fa>
 800a112:	4a38      	ldr	r2, [pc, #224]	; (800a1f4 <cmdThreadInfo+0x2d8>)
 800a114:	e7e6      	b.n	800a0e4 <cmdThreadInfo+0x1c8>
    else if(state == eBlocked) printfFixed(chp, 9, "Blocked");
 800a116:	2b02      	cmp	r3, #2
 800a118:	d101      	bne.n	800a11e <cmdThreadInfo+0x202>
 800a11a:	4a37      	ldr	r2, [pc, #220]	; (800a1f8 <cmdThreadInfo+0x2dc>)
 800a11c:	e7e2      	b.n	800a0e4 <cmdThreadInfo+0x1c8>
    else if(state == eSuspended) printfFixed(chp, 9, "Suspended");
 800a11e:	2b03      	cmp	r3, #3
 800a120:	d101      	bne.n	800a126 <cmdThreadInfo+0x20a>
 800a122:	4a36      	ldr	r2, [pc, #216]	; (800a1fc <cmdThreadInfo+0x2e0>)
 800a124:	e7de      	b.n	800a0e4 <cmdThreadInfo+0x1c8>
    else if(state == eDeleted) printfFixed(chp, 9, "Deleted");
 800a126:	2b04      	cmp	r3, #4
 800a128:	bf0c      	ite	eq
 800a12a:	4a35      	ldreq	r2, [pc, #212]	; (800a200 <cmdThreadInfo+0x2e4>)
    else printfFixed(chp, 9, "Invalid");
 800a12c:	4a35      	ldrne	r2, [pc, #212]	; (800a204 <cmdThreadInfo+0x2e8>)
 800a12e:	e7d9      	b.n	800a0e4 <cmdThreadInfo+0x1c8>
        printfFixed(chp, 13, "%u", index);
 800a130:	4633      	mov	r3, r6
 800a132:	463a      	mov	r2, r7
 800a134:	210d      	movs	r1, #13
 800a136:	4620      	mov	r0, r4
 800a138:	f7fe fc78 	bl	8008a2c <printfFixed>
        if(entry->name) {
 800a13c:	68eb      	ldr	r3, [r5, #12]
 800a13e:	b1cb      	cbz	r3, 800a174 <cmdThreadInfo+0x258>
            printfFixed(chp, 10, "%s",entry->name);
 800a140:	464a      	mov	r2, r9
 800a142:	210a      	movs	r1, #10
 800a144:	4620      	mov	r0, r4
 800a146:	f7fe fc71 	bl	8008a2c <printfFixed>
        }
        printfFixed(chp, 11, "%08x", entry);
 800a14a:	462b      	mov	r3, r5
 800a14c:	210b      	movs	r1, #11
 800a14e:	4a26      	ldr	r2, [pc, #152]	; (800a1e8 <cmdThreadInfo+0x2cc>)
 800a150:	4620      	mov	r0, r4
 800a152:	f7fe fc6b 	bl	8008a2c <printfFixed>
        printfFixed(chp, 11, "%08x", entry->callback);
 800a156:	682b      	ldr	r3, [r5, #0]
 800a158:	210b      	movs	r1, #11
 800a15a:	4620      	mov	r0, r4
 800a15c:	4a22      	ldr	r2, [pc, #136]	; (800a1e8 <cmdThreadInfo+0x2cc>)
 800a15e:	f7fe fc65 	bl	8008a2c <printfFixed>
        if(entry->active) {
 800a162:	7c2b      	ldrb	r3, [r5, #16]
 800a164:	b163      	cbz	r3, 800a180 <cmdThreadInfo+0x264>
            chprintf(chp, "Active"SHELL_NEWLINE_STR);
 800a166:	4928      	ldr	r1, [pc, #160]	; (800a208 <cmdThreadInfo+0x2ec>)
        } else {
            chprintf(chp, "Idle"SHELL_NEWLINE_STR);
 800a168:	4620      	mov	r0, r4
 800a16a:	f7fe fab6 	bl	80086da <chprintf>
        }
        index++;
 800a16e:	3601      	adds	r6, #1
        entry = entry->next;
 800a170:	68ad      	ldr	r5, [r5, #8]
 800a172:	e778      	b.n	800a066 <cmdThreadInfo+0x14a>
            printfFixed(chp, 10, "");
 800a174:	4642      	mov	r2, r8
 800a176:	210a      	movs	r1, #10
 800a178:	4620      	mov	r0, r4
 800a17a:	f7fe fc57 	bl	8008a2c <printfFixed>
 800a17e:	e7e4      	b.n	800a14a <cmdThreadInfo+0x22e>
            chprintf(chp, "Idle"SHELL_NEWLINE_STR);
 800a180:	4922      	ldr	r1, [pc, #136]	; (800a20c <cmdThreadInfo+0x2f0>)
 800a182:	e7f1      	b.n	800a168 <cmdThreadInfo+0x24c>
 800a184:	2000135c 	.word	0x2000135c
 800a188:	200011b8 	.word	0x200011b8
 800a18c:	200011ac 	.word	0x200011ac
 800a190:	200011b4 	.word	0x200011b4
 800a194:	20001634 	.word	0x20001634
 800a198:	20001620 	.word	0x20001620
 800a19c:	0800c2f4 	.word	0x0800c2f4
 800a1a0:	0800c2fc 	.word	0x0800c2fc
 800a1a4:	0800c306 	.word	0x0800c306
 800a1a8:	0800c311 	.word	0x0800c311
 800a1ac:	0800c31c 	.word	0x0800c31c
 800a1b0:	0800c322 	.word	0x0800c322
 800a1b4:	0800c328 	.word	0x0800c328
 800a1b8:	0800be0f 	.word	0x0800be0f
 800a1bc:	0800c32e 	.word	0x0800c32e
 800a1c0:	0800c337 	.word	0x0800c337
 800a1c4:	0800bc2f 	.word	0x0800bc2f
 800a1c8:	0800c376 	.word	0x0800c376
 800a1cc:	0800c381 	.word	0x0800c381
 800a1d0:	0800c38c 	.word	0x0800c38c
 800a1d4:	0800c395 	.word	0x0800c395
 800a1d8:	200011a0 	.word	0x200011a0
 800a1dc:	0800c0bc 	.word	0x0800c0bc
 800a1e0:	0800c01d 	.word	0x0800c01d
 800a1e4:	0800c33c 	.word	0x0800c33c
 800a1e8:	0800c341 	.word	0x0800c341
 800a1ec:	200011a8 	.word	0x200011a8
 800a1f0:	0800c346 	.word	0x0800c346
 800a1f4:	0800c34e 	.word	0x0800c34e
 800a1f8:	0800c354 	.word	0x0800c354
 800a1fc:	0800c35c 	.word	0x0800c35c
 800a200:	0800c366 	.word	0x0800c366
 800a204:	0800c36e 	.word	0x0800c36e
 800a208:	0800c39d 	.word	0x0800c39d
 800a20c:	0800c3a6 	.word	0x0800c3a6

0800a210 <cmdMax>:
    }
}


void cmdMax(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 800a210:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a214:	4604      	mov	r4, r0
 800a216:	460d      	mov	r5, r1
 800a218:	4698      	mov	r8, r3
    MAX2870Driver* pll = (MAX2870Driver*)user;

    if(argc == 0) {
 800a21a:	4616      	mov	r6, r2
{
 800a21c:	b087      	sub	sp, #28
    if(argc == 0) {
 800a21e:	b92a      	cbnz	r2, 800a22c <cmdMax+0x1c>
        cmdMaxUsage(chp);
 800a220:	4628      	mov	r0, r5
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
    } else {
        cmdMaxUsage(chp);
        return;
    }
}
 800a222:	b007      	add	sp, #28
 800a224:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        cmdMaxUsage(chp);
 800a228:	f7fe bb70 	b.w	800890c <cmdMaxUsage>
    if(!strcmp(argv[0], "tune")) {
 800a22c:	681f      	ldr	r7, [r3, #0]
 800a22e:	497f      	ldr	r1, [pc, #508]	; (800a42c <cmdMax+0x21c>)
 800a230:	4638      	mov	r0, r7
 800a232:	f7f9 fcc5 	bl	8003bc0 <strcmp>
 800a236:	4684      	mov	ip, r0
 800a238:	2800      	cmp	r0, #0
 800a23a:	d158      	bne.n	800a2ee <cmdMax+0xde>
        cmdMaxTune(pll, chp, argc-1, argv+1);
 800a23c:	f106 39ff 	add.w	r9, r6, #4294967295	; 0xffffffff
    MAX2870TuneRequest tune = *max2870getCurrentTuning(pll);
 800a240:	466e      	mov	r6, sp
 800a242:	f104 0708 	add.w	r7, r4, #8
 800a246:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800a248:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800a24a:	e897 0003 	ldmia.w	r7, {r0, r1}
    if(argc >= 1) {
 800a24e:	f1b9 0f00 	cmp.w	r9, #0
    MAX2870TuneRequest tune = *max2870getCurrentTuning(pll);
 800a252:	e886 0003 	stmia.w	r6, {r0, r1}
    tune.fastLockDurationMicroseconds = 0;
 800a256:	f8cd c00c 	str.w	ip, [sp, #12]
    tune.useVCOAutotune = false;
 800a25a:	f88d c010 	strb.w	ip, [sp, #16]
    if(argc >= 1) {
 800a25e:	dd20      	ble.n	800a2a2 <cmdMax+0x92>
        tune.frequency = (uint64_t)strToInt(argv[0], 10) * 1000;
 800a260:	210a      	movs	r1, #10
 800a262:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800a266:	f7f9 ffb4 	bl	80041d2 <strToInt>
 800a26a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a26e:	fb80 0303 	smull	r0, r3, r0, r3
    if(argc >= 2) {
 800a272:	f1b9 0f01 	cmp.w	r9, #1
        tune.frequency = (uint64_t)strToInt(argv[0], 10) * 1000;
 800a276:	e9cd 0300 	strd	r0, r3, [sp]
    if(argc >= 2) {
 800a27a:	d012      	beq.n	800a2a2 <cmdMax+0x92>
        tune.powerA = strToInt(argv[1], 10);
 800a27c:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800a280:	f7f9 ffa7 	bl	80041d2 <strToInt>
    if(argc >= 3) {
 800a284:	f1b9 0f02 	cmp.w	r9, #2
        tune.powerA = strToInt(argv[1], 10);
 800a288:	f88d 0008 	strb.w	r0, [sp, #8]
    if(argc >= 3) {
 800a28c:	d009      	beq.n	800a2a2 <cmdMax+0x92>
        tune.useVCOAutotune = (strToInt(argv[2], 10) > 0);
 800a28e:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800a292:	f7f9 ff9e 	bl	80041d2 <strToInt>
 800a296:	2800      	cmp	r0, #0
 800a298:	bfd4      	ite	le
 800a29a:	2000      	movle	r0, #0
 800a29c:	2001      	movgt	r0, #1
 800a29e:	f88d 0010 	strb.w	r0, [sp, #16]
    MAX2870TuneResult result = max2870Tune(pll, &tune);
 800a2a2:	4669      	mov	r1, sp
 800a2a4:	4620      	mov	r0, r4
 800a2a6:	f7fe ffb9 	bl	800921c <max2870Tune>
    if(result == TUNE_OK) {
 800a2aa:	2800      	cmp	r0, #0
 800a2ac:	f040 80b9 	bne.w	800a422 <cmdMax+0x212>
        max2870StatusPrint(pll, chp);
 800a2b0:	4629      	mov	r1, r5
 800a2b2:	4620      	mov	r0, r4
 800a2b4:	f7fe fbe0 	bl	8008a78 <max2870StatusPrint>
        chprintf(chp, SHELL_NEWLINE_STR);
 800a2b8:	4628      	mov	r0, r5
 800a2ba:	495d      	ldr	r1, [pc, #372]	; (800a430 <cmdMax+0x220>)
 800a2bc:	f7fe fa0d 	bl	80086da <chprintf>
    return lock == 0xFF;
}

const char* max2870TuneResultToString(MAX2870TuneResult result)
{
    if(result == TUNE_OK) return "OK";
 800a2c0:	4a5c      	ldr	r2, [pc, #368]	; (800a434 <cmdMax+0x224>)
    chprintf(chp, "Tuning result: %s"SHELL_NEWLINE_STR, max2870TuneResultToString(result));
 800a2c2:	4628      	mov	r0, r5
 800a2c4:	495c      	ldr	r1, [pc, #368]	; (800a438 <cmdMax+0x228>)
 800a2c6:	f7fe fa08 	bl	80086da <chprintf>
}
 800a2ca:	b007      	add	sp, #28
 800a2cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(result == TUNE_CANT_FASTLOCK) return "Invalid fastlock command";
    if(result == TUNE_NOT_LOCKED) return "Lock failed";
 800a2d0:	1d06      	adds	r6, r0, #4
 800a2d2:	d008      	beq.n	800a2e6 <cmdMax+0xd6>
    if(result == TUNE_PLL_N_OUT_OF_RANGE) return "N out of range";
 800a2d4:	1c84      	adds	r4, r0, #2
 800a2d6:	d008      	beq.n	800a2ea <cmdMax+0xda>
    if(result == TUNE_FREQUENCY_OUT_OF_RANGE) return "Frequency out of range";
 800a2d8:	4a58      	ldr	r2, [pc, #352]	; (800a43c <cmdMax+0x22c>)
 800a2da:	4b59      	ldr	r3, [pc, #356]	; (800a440 <cmdMax+0x230>)
 800a2dc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800a2e0:	bf08      	it	eq
 800a2e2:	461a      	moveq	r2, r3
 800a2e4:	e7ed      	b.n	800a2c2 <cmdMax+0xb2>
    if(result == TUNE_NOT_LOCKED) return "Lock failed";
 800a2e6:	4a57      	ldr	r2, [pc, #348]	; (800a444 <cmdMax+0x234>)
 800a2e8:	e7eb      	b.n	800a2c2 <cmdMax+0xb2>
    if(result == TUNE_PLL_N_OUT_OF_RANGE) return "N out of range";
 800a2ea:	4a57      	ldr	r2, [pc, #348]	; (800a448 <cmdMax+0x238>)
 800a2ec:	e7e9      	b.n	800a2c2 <cmdMax+0xb2>
    } else if(!strcmp(argv[0], "status")) {
 800a2ee:	4638      	mov	r0, r7
 800a2f0:	4956      	ldr	r1, [pc, #344]	; (800a44c <cmdMax+0x23c>)
 800a2f2:	f7f9 fc65 	bl	8003bc0 <strcmp>
 800a2f6:	b930      	cbnz	r0, 800a306 <cmdMax+0xf6>
        max2870StatusPrint(pll, chp);
 800a2f8:	4629      	mov	r1, r5
 800a2fa:	4620      	mov	r0, r4
}
 800a2fc:	b007      	add	sp, #28
 800a2fe:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        max2870StatusPrint(pll, chp);
 800a302:	f7fe bbb9 	b.w	8008a78 <max2870StatusPrint>
    } else if(!strcmp(argv[0], "vcocache")) {
 800a306:	4638      	mov	r0, r7
 800a308:	4951      	ldr	r1, [pc, #324]	; (800a450 <cmdMax+0x240>)
 800a30a:	f7f9 fc59 	bl	8003bc0 <strcmp>
 800a30e:	2800      	cmp	r0, #0
 800a310:	d15f      	bne.n	800a3d2 <cmdMax+0x1c2>
    if(argc == 0) {
 800a312:	1e77      	subs	r7, r6, #1
 800a314:	d121      	bne.n	800a35a <cmdMax+0x14a>
    uint32_t frequency = MAX2870_VCO_MIN_FREQUENCY/1000000 + MAX2870_VCO_INCREMENT/2000000;
 800a316:	f640 36c2 	movw	r6, #3010	; 0xbc2
        chprintf(stdout, "Frequency: %u MHz, VCO Band: ", frequency);
 800a31a:	4f4e      	ldr	r7, [pc, #312]	; (800a454 <cmdMax+0x244>)
            chprintf(stdout, "Invalid"SHELL_NEWLINE_STR);
 800a31c:	f8df 8138 	ldr.w	r8, [pc, #312]	; 800a458 <cmdMax+0x248>
            chprintf(stdout, "%u"SHELL_NEWLINE_STR, vco & 0x3f);
 800a320:	f8df 9138 	ldr.w	r9, [pc, #312]	; 800a45c <cmdMax+0x24c>
 800a324:	3420      	adds	r4, #32
        chprintf(stdout, "Frequency: %u MHz, VCO Band: ", frequency);
 800a326:	4632      	mov	r2, r6
 800a328:	4639      	mov	r1, r7
 800a32a:	4628      	mov	r0, r5
 800a32c:	f7fe f9d5 	bl	80086da <chprintf>
        uint8_t vco = driver->vcoCache[i];
 800a330:	f814 2b01 	ldrb.w	r2, [r4], #1
        if(vco & 0x80) {
 800a334:	0610      	lsls	r0, r2, #24
 800a336:	d50b      	bpl.n	800a350 <cmdMax+0x140>
            chprintf(stdout, "%u"SHELL_NEWLINE_STR, vco & 0x3f);
 800a338:	4649      	mov	r1, r9
 800a33a:	4628      	mov	r0, r5
 800a33c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800a340:	f7fe f9cb 	bl	80086da <chprintf>
    for(unsigned int i=0; i<sizeof(driver->vcoCache); i++) {
 800a344:	f241 737a 	movw	r3, #6010	; 0x177a
        frequency += MAX2870_VCO_INCREMENT/1000000;
 800a348:	3614      	adds	r6, #20
    for(unsigned int i=0; i<sizeof(driver->vcoCache); i++) {
 800a34a:	429e      	cmp	r6, r3
 800a34c:	d1eb      	bne.n	800a326 <cmdMax+0x116>
 800a34e:	e7bc      	b.n	800a2ca <cmdMax+0xba>
            chprintf(stdout, "Invalid"SHELL_NEWLINE_STR);
 800a350:	4641      	mov	r1, r8
 800a352:	4628      	mov	r0, r5
 800a354:	f7fe f9c1 	bl	80086da <chprintf>
 800a358:	e7f4      	b.n	800a344 <cmdMax+0x134>
    } else if(!strcmp(argv[0], "calibrate")) {
 800a35a:	f8d8 6004 	ldr.w	r6, [r8, #4]
 800a35e:	4940      	ldr	r1, [pc, #256]	; (800a460 <cmdMax+0x250>)
 800a360:	4630      	mov	r0, r6
 800a362:	f7f9 fc2d 	bl	8003bc0 <strcmp>
 800a366:	b948      	cbnz	r0, 800a37c <cmdMax+0x16c>
        max2870VcoPrecal(pll);
 800a368:	4620      	mov	r0, r4
 800a36a:	f7fe ff85 	bl	8009278 <max2870VcoPrecal>
        chprintf(chp, "Done"SHELL_NEWLINE_STR);
 800a36e:	493d      	ldr	r1, [pc, #244]	; (800a464 <cmdMax+0x254>)
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a370:	4628      	mov	r0, r5
}
 800a372:	b007      	add	sp, #28
 800a374:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a378:	f7fe b9af 	b.w	80086da <chprintf>
    } else if(argc >= 2 && !strcmp(argv[0], "set")) {
 800a37c:	2f01      	cmp	r7, #1
 800a37e:	f77f af4f 	ble.w	800a220 <cmdMax+0x10>
 800a382:	4630      	mov	r0, r6
 800a384:	4938      	ldr	r1, [pc, #224]	; (800a468 <cmdMax+0x258>)
 800a386:	f7f9 fc1b 	bl	8003bc0 <strcmp>
 800a38a:	4606      	mov	r6, r0
 800a38c:	2800      	cmp	r0, #0
 800a38e:	f47f af47 	bne.w	800a220 <cmdMax+0x10>
        unsigned int a = strToInt(argv[1], 10);
 800a392:	210a      	movs	r1, #10
 800a394:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800a398:	f7f9 ff1b 	bl	80041d2 <strToInt>
        if(argc == 3) {
 800a39c:	2f03      	cmp	r7, #3
        unsigned int a = strToInt(argv[1], 10);
 800a39e:	4681      	mov	r9, r0
        if(argc == 3) {
 800a3a0:	d10a      	bne.n	800a3b8 <cmdMax+0x1a8>
            b = strToInt(argv[2], 10) | 0x80;
 800a3a2:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800a3a6:	f7f9 ff14 	bl	80041d2 <strToInt>
 800a3aa:	f040 0380 	orr.w	r3, r0, #128	; 0x80
    return &driver->currentTune;
}

bool max2870VcoCacheSet(MAX2870Driver* driver, unsigned int vcoIndex, uint8_t value)
{
    if(vcoIndex > sizeof(driver->vcoCache)) {
 800a3ae:	f1b9 0f96 	cmp.w	r9, #150	; 0x96
 800a3b2:	d903      	bls.n	800a3bc <cmdMax+0x1ac>
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a3b4:	492d      	ldr	r1, [pc, #180]	; (800a46c <cmdMax+0x25c>)
 800a3b6:	e7db      	b.n	800a370 <cmdMax+0x160>
        unsigned int b = 0;
 800a3b8:	4633      	mov	r3, r6
 800a3ba:	e7f8      	b.n	800a3ae <cmdMax+0x19e>
            chprintf(chp, "%u=0x%02x"SHELL_NEWLINE_STR,a,b);
 800a3bc:	464a      	mov	r2, r9
 800a3be:	4628      	mov	r0, r5
 800a3c0:	492b      	ldr	r1, [pc, #172]	; (800a470 <cmdMax+0x260>)
        return false;
    }

    driver->vcoCache[vcoIndex] = value;
 800a3c2:	444c      	add	r4, r9
        if(max2870VcoCacheSet(pll, a , b)) {
 800a3c4:	f884 3020 	strb.w	r3, [r4, #32]
}
 800a3c8:	b007      	add	sp, #28
 800a3ca:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            chprintf(chp, "%u=0x%02x"SHELL_NEWLINE_STR,a,b);
 800a3ce:	f7fe b984 	b.w	80086da <chprintf>
    } else if(!strcmp(argv[0], "dld")) {
 800a3d2:	4638      	mov	r0, r7
 800a3d4:	4927      	ldr	r1, [pc, #156]	; (800a474 <cmdMax+0x264>)
 800a3d6:	f7f9 fbf3 	bl	8003bc0 <strcmp>
 800a3da:	2800      	cmp	r0, #0
 800a3dc:	f47f af20 	bne.w	800a220 <cmdMax+0x10>
    max2870SpiState(driver, true);
 800a3e0:	4620      	mov	r0, r4
 800a3e2:	f7fd fe67 	bl	80080b4 <max2870SpiState.constprop.0>
    max2870SetMUXOut(driver, 0x6);
 800a3e6:	4620      	mov	r0, r4
 800a3e8:	2106      	movs	r1, #6
 800a3ea:	f7fd ff65 	bl	80082b8 <max2870SetMUXOut>
    spiReceive(driver->config->spiPort, 1, &lock);
 800a3ee:	6823      	ldr	r3, [r4, #0]
 800a3f0:	6818      	ldr	r0, [r3, #0]
 800a3f2:	b910      	cbnz	r0, 800a3fa <cmdMax+0x1ea>
 800a3f4:	f7fa fae6 	bl	80049c4 <vTaskEndScheduler>
 800a3f8:	e7fe      	b.n	800a3f8 <cmdMax+0x1e8>
 800a3fa:	466a      	mov	r2, sp
 800a3fc:	2101      	movs	r1, #1
 800a3fe:	f7fc f90f 	bl	8006620 <spiReceive.part.0>
    if(enable) {
 800a402:	4620      	mov	r0, r4
 800a404:	f7fe f924 	bl	8008650 <max2870SpiState.part.0>
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
 800a408:	4628      	mov	r0, r5
    return lock == 0xFF;
 800a40a:	f89d 2000 	ldrb.w	r2, [sp]
 800a40e:	f1a2 01ff 	sub.w	r1, r2, #255	; 0xff
 800a412:	424a      	negs	r2, r1
 800a414:	414a      	adcs	r2, r1
 800a416:	4918      	ldr	r1, [pc, #96]	; (800a478 <cmdMax+0x268>)
}
 800a418:	b007      	add	sp, #28
 800a41a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
 800a41e:	f7fe b95c 	b.w	80086da <chprintf>
    if(result == TUNE_CANT_FASTLOCK) return "Invalid fastlock command";
 800a422:	1cc3      	adds	r3, r0, #3
 800a424:	f47f af54 	bne.w	800a2d0 <cmdMax+0xc0>
 800a428:	4a14      	ldr	r2, [pc, #80]	; (800a47c <cmdMax+0x26c>)
 800a42a:	e74a      	b.n	800a2c2 <cmdMax+0xb2>
 800a42c:	0800c406 	.word	0x0800c406
 800a430:	0800be0f 	.word	0x0800be0f
 800a434:	0800ba21 	.word	0x0800ba21
 800a438:	0800c40b 	.word	0x0800c40b
 800a43c:	0800c3ad 	.word	0x0800c3ad
 800a440:	0800c3d6 	.word	0x0800c3d6
 800a444:	0800c3ca 	.word	0x0800c3ca
 800a448:	0800c3bb 	.word	0x0800c3bb
 800a44c:	0800c01e 	.word	0x0800c01e
 800a450:	0800c41f 	.word	0x0800c41f
 800a454:	0800c428 	.word	0x0800c428
 800a458:	0800c446 	.word	0x0800c446
 800a45c:	0800c13c 	.word	0x0800c13c
 800a460:	0800c450 	.word	0x0800c450
 800a464:	0800c45a 	.word	0x0800c45a
 800a468:	0800c056 	.word	0x0800c056
 800a46c:	0800c461 	.word	0x0800c461
 800a470:	0800c475 	.word	0x0800c475
 800a474:	0800c481 	.word	0x0800c481
 800a478:	0800c485 	.word	0x0800c485
 800a47c:	0800c3ed 	.word	0x0800c3ed

0800a480 <cmdSof>:

void cmdSof(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
    (void) user;

    if(argc > 0) {
 800a480:	2a00      	cmp	r2, #0
{
 800a482:	b538      	push	{r3, r4, r5, lr}
 800a484:	460c      	mov	r4, r1
 800a486:	4d16      	ldr	r5, [pc, #88]	; (800a4e0 <cmdSof+0x60>)
    if(argc > 0) {
 800a488:	dd06      	ble.n	800a498 <cmdSof+0x18>
        if(!strcmp(argv[0],"1")) {
 800a48a:	4916      	ldr	r1, [pc, #88]	; (800a4e4 <cmdSof+0x64>)
 800a48c:	6818      	ldr	r0, [r3, #0]
 800a48e:	f7f9 fb97 	bl	8003bc0 <strcmp>
 800a492:	b9f0      	cbnz	r0, 800a4d2 <cmdSof+0x52>
    sofNeededCallback
};

void usbDisableSOF(bool doIt)
{
    allowDisableSOF = doIt;
 800a494:	2301      	movs	r3, #1
 800a496:	702b      	strb	r3, [r5, #0]
            usbDisableSOF(true);
        } else {
            usbDisableSOF(false);
        }
    }
    printfFixed(chp, 21, "SoF Disable Allowed:");
 800a498:	2115      	movs	r1, #21
 800a49a:	4a13      	ldr	r2, [pc, #76]	; (800a4e8 <cmdSof+0x68>)
 800a49c:	4620      	mov	r0, r4
 800a49e:	f7fe fac5 	bl	8008a2c <printfFixed>
    }
}

uint32_t usbGetSofCounter(bool* sofDisableAllowed)
{
    osalSysLock();
 800a4a2:	f7fa fa7f 	bl	80049a4 <vPortEnterCritical>
    if(sofDisableAllowed) *sofDisableAllowed=allowDisableSOF;

    uint32_t count = sofCounter;
 800a4a6:	4b11      	ldr	r3, [pc, #68]	; (800a4ec <cmdSof+0x6c>)
    if(sofDisableAllowed) *sofDisableAllowed=allowDisableSOF;
 800a4a8:	7828      	ldrb	r0, [r5, #0]
    uint32_t count = sofCounter;
 800a4aa:	681d      	ldr	r5, [r3, #0]
    osalSysUnlock();
 800a4ac:	f7fa fc9e 	bl	8004dec <osalSysUnlock.lto_priv.0>
    bool allowDisable;
    uint32_t cnt = usbGetSofCounter(&allowDisable);
    chprintf(chp, "%u"SHELL_NEWLINE_STR, allowDisable);
 800a4b0:	4602      	mov	r2, r0
 800a4b2:	490f      	ldr	r1, [pc, #60]	; (800a4f0 <cmdSof+0x70>)
 800a4b4:	4620      	mov	r0, r4
 800a4b6:	f7fe f910 	bl	80086da <chprintf>
    printfFixed(chp, 21, "SoF Count:");
 800a4ba:	2115      	movs	r1, #21
 800a4bc:	4620      	mov	r0, r4
 800a4be:	4a0d      	ldr	r2, [pc, #52]	; (800a4f4 <cmdSof+0x74>)
 800a4c0:	f7fe fab4 	bl	8008a2c <printfFixed>
    chprintf(chp, "%u"SHELL_NEWLINE_STR, cnt);
 800a4c4:	462a      	mov	r2, r5
 800a4c6:	4620      	mov	r0, r4
}
 800a4c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chprintf(chp, "%u"SHELL_NEWLINE_STR, cnt);
 800a4cc:	4908      	ldr	r1, [pc, #32]	; (800a4f0 <cmdSof+0x70>)
 800a4ce:	f7fe b904 	b.w	80086da <chprintf>
    allowDisableSOF = doIt;
 800a4d2:	2300      	movs	r3, #0
        sofNeededCallback(&USBD1, true);
 800a4d4:	2101      	movs	r1, #1
 800a4d6:	4808      	ldr	r0, [pc, #32]	; (800a4f8 <cmdSof+0x78>)
    allowDisableSOF = doIt;
 800a4d8:	702b      	strb	r3, [r5, #0]
        sofNeededCallback(&USBD1, true);
 800a4da:	f7fb fc8d 	bl	8005df8 <sofNeededCallback>
 800a4de:	e7db      	b.n	800a498 <cmdSof+0x18>
 800a4e0:	20000800 	.word	0x20000800
 800a4e4:	0800bb4f 	.word	0x0800bb4f
 800a4e8:	0800c49f 	.word	0x0800c49f
 800a4ec:	200012c8 	.word	0x200012c8
 800a4f0:	0800c13c 	.word	0x0800c13c
 800a4f4:	0800c4b4 	.word	0x0800c4b4
 800a4f8:	20000f54 	.word	0x20000f54

0800a4fc <cmdSanity>:

void cmdSanity(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
    (void)user;

    if(argc == 1) {
 800a4fc:	2a01      	cmp	r2, #1
{
 800a4fe:	b570      	push	{r4, r5, r6, lr}
 800a500:	460c      	mov	r4, r1
 800a502:	4615      	mov	r5, r2
    if(argc == 1) {
 800a504:	d117      	bne.n	800a536 <cmdSanity+0x3a>
        if(sanitySettingsLocked){
 800a506:	4e11      	ldr	r6, [pc, #68]	; (800a54c <cmdSanity+0x50>)
 800a508:	7832      	ldrb	r2, [r6, #0]
 800a50a:	b12a      	cbz	r2, 800a518 <cmdSanity+0x1c>
            chprintf(chp, "Settings locked!"SHELL_NEWLINE_STR);
 800a50c:	4910      	ldr	r1, [pc, #64]	; (800a550 <cmdSanity+0x54>)
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a50e:	4620      	mov	r0, r4
        }
        return;
    };

    cmdSanityUsage(chp);
}
 800a510:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a514:	f7fe b8e1 	b.w	80086da <chprintf>
        }else if(!strcmp(argv[0], "lock")) {
 800a518:	681c      	ldr	r4, [r3, #0]
 800a51a:	490e      	ldr	r1, [pc, #56]	; (800a554 <cmdSanity+0x58>)
 800a51c:	4620      	mov	r0, r4
 800a51e:	f7f9 fb4f 	bl	8003bc0 <strcmp>
 800a522:	b908      	cbnz	r0, 800a528 <cmdSanity+0x2c>
            sanitySettingsLocked = true;
 800a524:	7035      	strb	r5, [r6, #0]
}
 800a526:	bd70      	pop	{r4, r5, r6, pc}
            sanityRebootSeconds = strToInt(argv[0], 10);
 800a528:	210a      	movs	r1, #10
 800a52a:	4620      	mov	r0, r4
 800a52c:	f7f9 fe51 	bl	80041d2 <strToInt>
 800a530:	4b09      	ldr	r3, [pc, #36]	; (800a558 <cmdSanity+0x5c>)
 800a532:	6018      	str	r0, [r3, #0]
 800a534:	e7f7      	b.n	800a526 <cmdSanity+0x2a>
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 800a536:	4909      	ldr	r1, [pc, #36]	; (800a55c <cmdSanity+0x60>)
 800a538:	4620      	mov	r0, r4
 800a53a:	f7fe f8ce 	bl	80086da <chprintf>
    chprintf(chp, "\tsanity lock"SHELL_NEWLINE_STR);
 800a53e:	4908      	ldr	r1, [pc, #32]	; (800a560 <cmdSanity+0x64>)
 800a540:	4620      	mov	r0, r4
 800a542:	f7fe f8ca 	bl	80086da <chprintf>
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a546:	4907      	ldr	r1, [pc, #28]	; (800a564 <cmdSanity+0x68>)
 800a548:	e7e1      	b.n	800a50e <cmdSanity+0x12>
 800a54a:	bf00      	nop
 800a54c:	20001230 	.word	0x20001230
 800a550:	0800c4bf 	.word	0x0800c4bf
 800a554:	0800c4d2 	.word	0x0800c4d2
 800a558:	20000858 	.word	0x20000858
 800a55c:	0800bc18 	.word	0x0800bc18
 800a560:	0800c4d7 	.word	0x0800c4d7
 800a564:	0800c4e6 	.word	0x0800c4e6

0800a568 <i2cSafeWriteRegStandard>:
{
 800a568:	b530      	push	{r4, r5, lr}
 800a56a:	460d      	mov	r5, r1
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 800a56c:	4604      	mov	r4, r0
{
 800a56e:	b085      	sub	sp, #20
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 800a570:	b910      	cbnz	r0, 800a578 <i2cSafeWriteRegStandard+0x10>
 800a572:	f7fa fa27 	bl	80049c4 <vTaskEndScheduler>
 800a576:	e7fe      	b.n	800a576 <i2cSafeWriteRegStandard+0xe>
    txBuf[0]=addr;
 800a578:	f88d 200c 	strb.w	r2, [sp, #12]
    memcpy(&txBuf[1], values, len);
 800a57c:	f88d 300d 	strb.w	r3, [sp, #13]
    i2cAcquireBus(i2c);
 800a580:	f7fb f8da 	bl	8005738 <i2cAcquireBus>
    i2c_status = i2cSafeMasterTransmitTimeoutWithRetry(i2c, devAddr, txBuf,
 800a584:	2300      	movs	r3, #0
 800a586:	4629      	mov	r1, r5
 800a588:	e9cd 3300 	strd	r3, r3, [sp]
 800a58c:	aa03      	add	r2, sp, #12
 800a58e:	2302      	movs	r3, #2
 800a590:	4620      	mov	r0, r4
 800a592:	f7fe fef5 	bl	8009380 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>
 800a596:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 800a598:	4620      	mov	r0, r4
 800a59a:	f7fe f84f 	bl	800863c <i2cReleaseBus>
}
 800a59e:	4628      	mov	r0, r5
 800a5a0:	b005      	add	sp, #20
 800a5a2:	bd30      	pop	{r4, r5, pc}

0800a5a4 <main_>:
{
 800a5a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    void* syslogBuffer = pvPortMalloc(bufferSize);
 800a5a6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800a5aa:	b085      	sub	sp, #20
 800a5ac:	f7fa fe32 	bl	8005214 <pvPortMalloc>
    memset(queue, 0, sizeof(*queue));
 800a5b0:	4c56      	ldr	r4, [pc, #344]	; (800a70c <main_+0x168>)
 800a5b2:	4605      	mov	r5, r0
 800a5b4:	221c      	movs	r2, #28
 800a5b6:	2100      	movs	r1, #0
 800a5b8:	f104 0008 	add.w	r0, r4, #8
 800a5bc:	f001 f8fe 	bl	800b7bc <memset>

    queue->buffer = buffer;
    queue->bufferSize = bufferSize;
 800a5c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800a5c4:	2050      	movs	r0, #80	; 0x50
    queue->buffer = buffer;
 800a5c6:	6025      	str	r5, [r4, #0]
    queue->bufferSize = bufferSize;
 800a5c8:	6063      	str	r3, [r4, #4]
 800a5ca:	f7fa fe23 	bl	8005214 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800a5ce:	4604      	mov	r4, r0
 800a5d0:	b160      	cbz	r0, 800a5ec <main_+0x48>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a5d2:	2300      	movs	r3, #0
	pxNewQueue->uxLength = uxQueueLength;
 800a5d4:	2501      	movs	r5, #1
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a5d6:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 800a5da:	e9c0 530f 	strd	r5, r3, [r0, #60]	; 0x3c
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800a5de:	6000      	str	r0, [r0, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800a5e0:	f7fe f851 	bl	8008686 <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800a5e4:	f880 504c 	strb.w	r5, [r0, #76]	; 0x4c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800a5e8:	f7fe f847 	bl	800867a <prvInitialiseMutex.part.0>
    syslogSemaphore = xSemaphoreCreateMutex();
 800a5ec:	4b48      	ldr	r3, [pc, #288]	; (800a710 <main_+0x16c>)
    syslog("Syslog started.");
 800a5ee:	4849      	ldr	r0, [pc, #292]	; (800a714 <main_+0x170>)
    syslogSemaphore = xSemaphoreCreateMutex();
 800a5f0:	601c      	str	r4, [r3, #0]
    syslog("Syslog started.");
 800a5f2:	f7fe fb8b 	bl	8008d0c <syslog>
    usbDisconnectBus(serusbcfg.usbp);
 800a5f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
    event_source->setEvents = 0;
 800a5fa:	2400      	movs	r4, #0
 800a5fc:	4d46      	ldr	r5, [pc, #280]	; (800a718 <main_+0x174>)
 800a5fe:	4847      	ldr	r0, [pc, #284]	; (800a71c <main_+0x178>)
 800a600:	616b      	str	r3, [r5, #20]
    event_source->firstRepeater = NULL;
 800a602:	e9c0 4400 	strd	r4, r4, [r0]
    event_source->waitThread = NULL;
 800a606:	6084      	str	r4, [r0, #8]
    osalSysLock();
 800a608:	f7fa f9cc 	bl	80049a4 <vPortEnterCritical>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800a60c:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800a610:	b1b3      	cbz	r3, 800a640 <main_+0x9c>

void osalEventRegisterCallbackI(event_source_t* source, void (*eventCallback)(event_source_t* source, eventflags_t set)){
    osalDbgCheck(source != NULL);
    osalDbgCheckClassI();

    source->eventCallback = eventCallback;
 800a612:	4b43      	ldr	r3, [pc, #268]	; (800a720 <main_+0x17c>)
    GPIODriverData.numPorts = numPorts;
 800a614:	4e43      	ldr	r6, [pc, #268]	; (800a724 <main_+0x180>)
 800a616:	60c3      	str	r3, [r0, #12]
    osalSysUnlock();
 800a618:	f7fa fbe8 	bl	8004dec <osalSysUnlock.lto_priv.0>
 800a61c:	2304      	movs	r3, #4
    GPIODriverData.ports = pvPortMalloc(sizeof(GPIOPort) * numPorts);
 800a61e:	2030      	movs	r0, #48	; 0x30
    GPIODriverData.numPorts = numPorts;
 800a620:	7133      	strb	r3, [r6, #4]
    GPIODriverData.ports = pvPortMalloc(sizeof(GPIOPort) * numPorts);
 800a622:	f7fa fdf7 	bl	8005214 <pvPortMalloc>
 800a626:	6030      	str	r0, [r6, #0]
    if(!GPIODriverData.ports) {
 800a628:	b968      	cbnz	r0, 800a646 <main_+0xa2>
        syslog("GPIO subsystem init failed.");
 800a62a:	483f      	ldr	r0, [pc, #252]	; (800a728 <main_+0x184>)
    syslog("USB init done.");
 800a62c:	f7fe fb6e 	bl	8008d0c <syslog>
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
 800a630:	2200      	movs	r2, #0
 800a632:	493e      	ldr	r1, [pc, #248]	; (800a72c <main_+0x188>)
 800a634:	483e      	ldr	r0, [pc, #248]	; (800a730 <main_+0x18c>)
}
 800a636:	b005      	add	sp, #20
 800a638:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
 800a63c:	f7fd bb46 	b.w	8007ccc <shellStart.constprop.0>
    osalDbgCheckClassI();
 800a640:	f7fa f9c0 	bl	80049c4 <vTaskEndScheduler>
 800a644:	e7fe      	b.n	800a644 <main_+0xa0>
        GPIODriverData.ports[i].numPins = 0;
 800a646:	4623      	mov	r3, r4
        GPIODriverData.ports[i].functions = &gpioDummyFunctions;
 800a648:	4a3a      	ldr	r2, [pc, #232]	; (800a734 <main_+0x190>)
        GPIODriverData.ports[i].driver = (void*)(unsigned int)i;
 800a64a:	6004      	str	r4, [r0, #0]
    for(uint8_t i=0; i<numPorts; i++) {
 800a64c:	3401      	adds	r4, #1
 800a64e:	2c04      	cmp	r4, #4
        GPIODriverData.ports[i].numPins = 0;
 800a650:	e9c0 3201 	strd	r3, r2, [r0, #4]
    for(uint8_t i=0; i<numPorts; i++) {
 800a654:	f100 000c 	add.w	r0, r0, #12
 800a658:	d1f7      	bne.n	800a64a <main_+0xa6>
        syslog("GPIO subsystem init done.");
 800a65a:	4837      	ldr	r0, [pc, #220]	; (800a738 <main_+0x194>)
 800a65c:	f7fe fb56 	bl	8008d0c <syslog>
        gpioCPUInit(GPIO_PORT_GPIOA, GPIOA);
 800a660:	492d      	ldr	r1, [pc, #180]	; (800a718 <main_+0x174>)
 800a662:	2000      	movs	r0, #0
 800a664:	f7f9 ff18 	bl	8004498 <gpioCPUInit>
        gpioCPUInit(GPIO_PORT_GPIOB, GPIOB);
 800a668:	2001      	movs	r0, #1
 800a66a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800a66e:	f7f9 ff13 	bl	8004498 <gpioCPUInit>
        gpioCPUInit(GPIO_PORT_GPIOC, GPIOC);
 800a672:	2002      	movs	r0, #2
 800a674:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800a678:	f7f9 ff0e 	bl	8004498 <gpioCPUInit>
        shellCommandRegister("gpio", cmdGPIO, NULL);
 800a67c:	2200      	movs	r2, #0
 800a67e:	492f      	ldr	r1, [pc, #188]	; (800a73c <main_+0x198>)
 800a680:	482f      	ldr	r0, [pc, #188]	; (800a740 <main_+0x19c>)
 800a682:	f7f9 fde7 	bl	8004254 <shellCommandRegister>
    gpioSetPinMode(gpioPin, PAL_MODE_INPUT_PULLUP);
 800a686:	2103      	movs	r1, #3
 800a688:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a68c:	f7fc fe42 	bl	8007314 <gpioSetPinMode.isra.0>
    osalThreadSleepMilliseconds(1);
 800a690:	2001      	movs	r0, #1
 800a692:	f7fa fe79 	bl	8005388 <vTaskDelay>
    if(gpioGetPin(gpioPin) == 0) {
 800a696:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a69a:	f7f9 fe9b 	bl	80043d4 <gpioGetPin>
 800a69e:	b1f0      	cbz	r0, 800a6de <main_+0x13a>
    gpioSetPinMode(gpioPin, PAL_MODE_INPUT_PULLDOWN);
 800a6a0:	4621      	mov	r1, r4
 800a6a2:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a6a6:	f7fc fe35 	bl	8007314 <gpioSetPinMode.isra.0>
    osalThreadSleepMilliseconds(1);
 800a6aa:	2001      	movs	r0, #1
 800a6ac:	f7fa fe6c 	bl	8005388 <vTaskDelay>
    if(gpioGetPin(gpioPin) == 1) {
 800a6b0:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a6b4:	f7f9 fe8e 	bl	80043d4 <gpioGetPin>
 800a6b8:	4606      	mov	r6, r0
    uint32_t index = 0;

    for(;;) {
        const GPIOPinInit* pin = &pins[index];

        if(pin->gpioPin == 0xffff) {
 800a6ba:	f64f 77ff 	movw	r7, #65535	; 0xffff
 800a6be:	4c21      	ldr	r4, [pc, #132]	; (800a744 <main_+0x1a0>)
 800a6c0:	f834 0b04 	ldrh.w	r0, [r4], #4
 800a6c4:	42b8      	cmp	r0, r7
 800a6c6:	d00c      	beq.n	800a6e2 <main_+0x13e>
            return;
        }

        gpioSetPinMode(pin->gpioPin, pin->gpioMode);
 800a6c8:	f814 1c02 	ldrb.w	r1, [r4, #-2]
 800a6cc:	f7fc fe22 	bl	8007314 <gpioSetPinMode.isra.0>
        gpioSetPin(pin->gpioPin, pin->defaultValue);
 800a6d0:	f814 1c01 	ldrb.w	r1, [r4, #-1]
 800a6d4:	f834 0c04 	ldrh.w	r0, [r4, #-4]
 800a6d8:	f7fc ff48 	bl	800756c <gpioSetPin.isra.0>
    for(;;) {
 800a6dc:	e7f0      	b.n	800a6c0 <main_+0x11c>
    bool hasLoPLL = false, hasSWMix = true;
 800a6de:	2601      	movs	r6, #1
 800a6e0:	e7eb      	b.n	800a6ba <main_+0x116>
    i2c->i2cSafeConfig = (void*)config;
 800a6e2:	4c19      	ldr	r4, [pc, #100]	; (800a748 <main_+0x1a4>)
 800a6e4:	4b19      	ldr	r3, [pc, #100]	; (800a74c <main_+0x1a8>)
    i2cSafeRawHardwareControl(i2c);
 800a6e6:	4620      	mov	r0, r4
    i2c->i2cSafeConfig = (void*)config;
 800a6e8:	67e3      	str	r3, [r4, #124]	; 0x7c
    i2cSafeRawHardwareControl(i2c);
 800a6ea:	f7fc fe37 	bl	800735c <i2cSafeRawHardwareControl>
    shellCommandRegister("i2c", cmdI2C, &I2CD1);
 800a6ee:	4622      	mov	r2, r4
 800a6f0:	4917      	ldr	r1, [pc, #92]	; (800a750 <main_+0x1ac>)
 800a6f2:	4818      	ldr	r0, [pc, #96]	; (800a754 <main_+0x1b0>)
 800a6f4:	f7f9 fdae 	bl	8004254 <shellCommandRegister>
  osalSysLock();
 800a6f8:	f7fa f954 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800a6fc:	490c      	ldr	r1, [pc, #48]	; (800a730 <main_+0x18c>)
 800a6fe:	7d0b      	ldrb	r3, [r1, #20]
 800a700:	1e5a      	subs	r2, r3, #1
 800a702:	2a01      	cmp	r2, #1
 800a704:	d928      	bls.n	800a758 <main_+0x1b4>
 800a706:	f7fa f95d 	bl	80049c4 <vTaskEndScheduler>
 800a70a:	e7fe      	b.n	800a70a <main_+0x166>
 800a70c:	20001310 	.word	0x20001310
 800a710:	20001334 	.word	0x20001334
 800a714:	0800c4fb 	.word	0x0800c4fb
 800a718:	40010800 	.word	0x40010800
 800a71c:	200012b8 	.word	0x200012b8
 800a720:	08008d81 	.word	0x08008d81
 800a724:	20000928 	.word	0x20000928
 800a728:	0800c50b 	.word	0x0800c50b
 800a72c:	0800c62f 	.word	0x0800c62f
 800a730:	200009bc 	.word	0x200009bc
 800a734:	0800c9f8 	.word	0x0800c9f8
 800a738:	0800c527 	.word	0x0800c527
 800a73c:	080095dd 	.word	0x080095dd
 800a740:	0800c541 	.word	0x0800c541
 800a744:	0800ca48 	.word	0x0800ca48
 800a748:	20000934 	.word	0x20000934
 800a74c:	0800c804 	.word	0x0800c804
 800a750:	0800ab09 	.word	0x0800ab09
 800a754:	0800c546 	.word	0x0800c546
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 800a758:	2b01      	cmp	r3, #1
 800a75a:	d10c      	bne.n	800a776 <main_+0x1d2>
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 800a75c:	4ab3      	ldr	r2, [pc, #716]	; (800aa2c <main_+0x488>)
 800a75e:	69d3      	ldr	r3, [r2, #28]
 800a760:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800a764:	61d3      	str	r3, [r2, #28]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a766:	22c0      	movs	r2, #192	; 0xc0
 800a768:	4bb1      	ldr	r3, [pc, #708]	; (800aa30 <main_+0x48c>)
 800a76a:	f883 2327 	strb.w	r2, [r3, #807]	; 0x327
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a76e:	2280      	movs	r2, #128	; 0x80
 800a770:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a774:	605a      	str	r2, [r3, #4]
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800a776:	f44f 729c 	mov.w	r2, #312	; 0x138
  USART_TypeDef *u = sdp->usart;
 800a77a:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
  u->SR = 0;
 800a77e:	2700      	movs	r7, #0
    u->BRR = STM32_PCLK2 / config->speed;
 800a780:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800a782:	2040      	movs	r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800a784:	2401      	movs	r4, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800a786:	f242 122c 	movw	r2, #8492	; 0x212c
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800a78a:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800a78c:	615c      	str	r4, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800a78e:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 800a790:	601f      	str	r7, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 800a792:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800a794:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0xFF;
 800a796:	23ff      	movs	r3, #255	; 0xff
 800a798:	f881 3084 	strb.w	r3, [r1, #132]	; 0x84
  sdp->state = SD_READY;
 800a79c:	2302      	movs	r3, #2
 800a79e:	750b      	strb	r3, [r1, #20]
    osalOsRescheduleS();
 800a7a0:	f7fa f986 	bl	8004ab0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800a7a4:	f7fa fb16 	bl	8004dd4 <vPortExitCritical>
    xTaskCreate(mixLedTask, "Led", 64, (void*)&mixLedDelay, 1, &mixLedTaskHandle);
 800a7a8:	4ba2      	ldr	r3, [pc, #648]	; (800aa34 <main_+0x490>)
 800a7aa:	4602      	mov	r2, r0
 800a7ac:	e9cd 4300 	strd	r4, r3, [sp]
    memset(driver, 0, sizeof(*driver));
 800a7b0:	4ca1      	ldr	r4, [pc, #644]	; (800aa38 <main_+0x494>)
 800a7b2:	4ba2      	ldr	r3, [pc, #648]	; (800aa3c <main_+0x498>)
 800a7b4:	49a2      	ldr	r1, [pc, #648]	; (800aa40 <main_+0x49c>)
 800a7b6:	48a3      	ldr	r0, [pc, #652]	; (800aa44 <main_+0x4a0>)
 800a7b8:	f7fd fa58 	bl	8007c6c <xTaskCreate.isra.0>
 800a7bc:	22fc      	movs	r2, #252	; 0xfc
 800a7be:	4639      	mov	r1, r7
 800a7c0:	1d20      	adds	r0, r4, #4
 800a7c2:	f000 fffb 	bl	800b7bc <memset>
    driver->config = config;
 800a7c6:	4ba0      	ldr	r3, [pc, #640]	; (800aa48 <main_+0x4a4>)
    max2870Tune(driver, &driver->currentTune);
 800a7c8:	f104 0108 	add.w	r1, r4, #8
    driver->config = config;
 800a7cc:	6023      	str	r3, [r4, #0]
    driver->currentTune.powerA = -127;
 800a7ce:	f248 1381 	movw	r3, #33153	; 0x8181
    max2870Tune(driver, &driver->currentTune);
 800a7d2:	4620      	mov	r0, r4
    driver->currentTune.powerA = -127;
 800a7d4:	8223      	strh	r3, [r4, #16]
    max2870Tune(driver, &driver->currentTune);
 800a7d6:	f7fe fd21 	bl	800921c <max2870Tune>
    uint16_t pfdDivider = driver->config->referenceToPfdDivider;
 800a7da:	6820      	ldr	r0, [r4, #0]
 800a7dc:	8a83      	ldrh	r3, [r0, #20]
    uint32_t pfdFrequency = driver->config->inputFrequency;
 800a7de:	6902      	ldr	r2, [r0, #16]
    if(!(pfdDivider % 2)) {
 800a7e0:	07d9      	lsls	r1, r3, #31
        pfdDivider /= 2;
 800a7e2:	bf57      	itett	pl
 800a7e4:	085b      	lsrpl	r3, r3, #1
    uint32_t register2 = 0;
 800a7e6:	4639      	movmi	r1, r7
        register2 |= _BV(MAX2870_REG2_RDIV2_OFFSET);
 800a7e8:	f04f 7180 	movpl.w	r1, #16777216	; 0x1000000
        pfdFrequency /= 2;
 800a7ec:	0852      	lsrpl	r2, r2, #1
    if(pfdDivider > 1023) {
 800a7ee:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a7f2:	4f96      	ldr	r7, [pc, #600]	; (800aa4c <main_+0x4a8>)
 800a7f4:	f080 80a2 	bcs.w	800a93c <main_+0x398>
    pfdFrequency /= pfdDivider;
 800a7f8:	fbb2 f2f3 	udiv	r2, r2, r3
    if(pfdFrequency % driver->config->stepFrequency) {
 800a7fc:	6980      	ldr	r0, [r0, #24]
        pfdDivider = 0;
 800a7fe:	2b01      	cmp	r3, #1
    if(pfdFrequency % driver->config->stepFrequency) {
 800a800:	fbb2 fcf0 	udiv	ip, r2, r0
 800a804:	fb00 201c 	mls	r0, r0, ip, r2
        pfdDivider = 0;
 800a808:	bf08      	it	eq
 800a80a:	2300      	moveq	r3, #0
    if(pfdFrequency % driver->config->stepFrequency) {
 800a80c:	2800      	cmp	r0, #0
 800a80e:	f040 8095 	bne.w	800a93c <main_+0x398>
    if(fracDivider > 4095) {
 800a812:	f5bc 5f80 	cmp.w	ip, #4096	; 0x1000
 800a816:	f080 8091 	bcs.w	800a93c <main_+0x398>
    register2 |= pfdDivider << MAX2870_REG2_R_OFFSET;
 800a81a:	ea41 3383 	orr.w	r3, r1, r3, lsl #14
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a81e:	f24c 3150 	movw	r1, #50000	; 0xc350
    driver->refDividerRegister2 = register2;
 800a822:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a826:	f502 4343 	add.w	r3, r2, #49920	; 0xc300
 800a82a:	334f      	adds	r3, #79	; 0x4f
 800a82c:	fbb3 f3f1 	udiv	r3, r3, r1
 800a830:	b29b      	uxth	r3, r3
    if(driver->bsValue > 1023) {
 800a832:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    driver->fracDivider = fracDivider;
 800a836:	f8a4 c0bc 	strh.w	ip, [r4, #188]	; 0xbc
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a83a:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
    if(driver->bsValue > 1023) {
 800a83e:	d27d      	bcs.n	800a93c <main_+0x398>
    entry->name = name;
 800a840:	4b83      	ldr	r3, [pc, #524]	; (800aa50 <main_+0x4ac>)
    driver->pfdFrequency = pfdFrequency;
 800a842:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
 800a846:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    entry->callback = callback;
 800a84a:	4b82      	ldr	r3, [pc, #520]	; (800aa54 <main_+0x4b0>)
    entry->param = param;
 800a84c:	e9c4 343a 	strd	r3, r4, [r4, #232]	; 0xe8
    entry->next = monThreadFirst;
 800a850:	683b      	ldr	r3, [r7, #0]
 800a852:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    monThreadFirst = entry;
 800a856:	4c80      	ldr	r4, [pc, #512]	; (800aa58 <main_+0x4b4>)
    if(max2870Init(&loPLL, &max2870Config) && max2870VcoPrecal(&loPLL)) {
 800a858:	f1a4 00e8 	sub.w	r0, r4, #232	; 0xe8
 800a85c:	603c      	str	r4, [r7, #0]
 800a85e:	f7fe fd0b 	bl	8009278 <max2870VcoPrecal>
 800a862:	2800      	cmp	r0, #0
 800a864:	d06a      	beq.n	800a93c <main_+0x398>
		shellCommandRegister("max", cmdMax, &loPLL);
 800a866:	487d      	ldr	r0, [pc, #500]	; (800aa5c <main_+0x4b8>)
 800a868:	497d      	ldr	r1, [pc, #500]	; (800aa60 <main_+0x4bc>)
 800a86a:	f1a4 02e8 	sub.w	r2, r4, #232	; 0xe8
 800a86e:	f7f9 fcf1 	bl	8004254 <shellCommandRegister>
		syslog("MAX2870 init done.");
 800a872:	487c      	ldr	r0, [pc, #496]	; (800aa64 <main_+0x4c0>)
    	syslog("MAX2870 init failed.");
 800a874:	f7fe fa4a 	bl	8008d0c <syslog>

bool MCP9804Init(MCP9804Driver* driver, const MCP9804Driver_config* config)
{
    memset(driver, 0, sizeof(*driver));
 800a878:	2300      	movs	r3, #0
 800a87a:	4c7b      	ldr	r4, [pc, #492]	; (800aa68 <main_+0x4c4>)

    driver->config = config;

    /* Read device id */
    uint8_t devId;
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a87c:	2207      	movs	r2, #7
    memset(driver, 0, sizeof(*driver));
 800a87e:	6063      	str	r3, [r4, #4]
    driver->config = config;
 800a880:	4b7a      	ldr	r3, [pc, #488]	; (800aa6c <main_+0x4c8>)
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a882:	2118      	movs	r1, #24
    driver->config = config;
 800a884:	6023      	str	r3, [r4, #0]
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a886:	487a      	ldr	r0, [pc, #488]	; (800aa70 <main_+0x4cc>)
 800a888:	f10d 030f 	add.w	r3, sp, #15
 800a88c:	f7fe fe28 	bl	80094e0 <i2cSafeReadRegStandard>
 800a890:	b998      	cbnz	r0, 800a8ba <main_+0x316>
        return false;
    }

    if(devId != 0x2) {
 800a892:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800a896:	2b02      	cmp	r3, #2
 800a898:	d10f      	bne.n	800a8ba <main_+0x316>
        return false;
    }

    /* Set resolution to the highest */
    if(i2cSafeWriteRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x8, 0x3) != MSG_OK) {
 800a89a:	6820      	ldr	r0, [r4, #0]
 800a89c:	2303      	movs	r3, #3
 800a89e:	7901      	ldrb	r1, [r0, #4]
 800a8a0:	2208      	movs	r2, #8
 800a8a2:	6800      	ldr	r0, [r0, #0]
 800a8a4:	f7ff fe60 	bl	800a568 <i2cSafeWriteRegStandard>
 800a8a8:	b938      	cbnz	r0, 800a8ba <main_+0x316>
 800a8aa:	4620      	mov	r0, r4
 800a8ac:	f7fe fe26 	bl	80094fc <MCP9804MeasureTemperature.part.0>
    if(!MCP9804Init(&tcxoTempSensor, &mcp9804Config)) {
 800a8b0:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800a8b4:	4298      	cmp	r0, r3
        return false;
    }

    driver->temperature = MCP9804MeasureTemperature(driver, true);
 800a8b6:	80a0      	strh	r0, [r4, #4]
 800a8b8:	d147      	bne.n	800a94a <main_+0x3a6>
        syslog("Temperature sensor init failed.");
 800a8ba:	486e      	ldr	r0, [pc, #440]	; (800aa74 <main_+0x4d0>)
 800a8bc:	f7fe fa26 	bl	8008d0c <syslog>
    converter->activeBand = 0xff;
 800a8c0:	23ff      	movs	r3, #255	; 0xff
 800a8c2:	4c6d      	ldr	r4, [pc, #436]	; (800aa78 <main_+0x4d4>)
    shellCommandRegister("convert", cmdConvert, &converter);
 800a8c4:	496d      	ldr	r1, [pc, #436]	; (800aa7c <main_+0x4d8>)
 800a8c6:	7623      	strb	r3, [r4, #24]
    converter->bands = bands;
 800a8c8:	4b6d      	ldr	r3, [pc, #436]	; (800aa80 <main_+0x4dc>)
 800a8ca:	4622      	mov	r2, r4
 800a8cc:	6163      	str	r3, [r4, #20]
    converter->setConverterGpio = setGpio;
 800a8ce:	4b6d      	ldr	r3, [pc, #436]	; (800aa84 <main_+0x4e0>)
 800a8d0:	486d      	ldr	r0, [pc, #436]	; (800aa88 <main_+0x4e4>)
 800a8d2:	6223      	str	r3, [r4, #32]
 800a8d4:	f7f9 fcbe 	bl	8004254 <shellCommandRegister>
    if(!hasSWMix) {
 800a8d8:	b936      	cbnz	r6, 800a8e8 <main_+0x344>
        syslog("SW band disabled!");
 800a8da:	486c      	ldr	r0, [pc, #432]	; (800aa8c <main_+0x4e8>)
 800a8dc:	f7fe fa16 	bl	8008d0c <syslog>
        converter.disabledBands |= _BV(0);
 800a8e0:	69e3      	ldr	r3, [r4, #28]
 800a8e2:	f043 0301 	orr.w	r3, r3, #1
 800a8e6:	61e3      	str	r3, [r4, #28]
    if(!converterTune(&converter, &startupTuneRequest)) {
 800a8e8:	4969      	ldr	r1, [pc, #420]	; (800aa90 <main_+0x4ec>)
 800a8ea:	4863      	ldr	r0, [pc, #396]	; (800aa78 <main_+0x4d4>)
 800a8ec:	f7f9 fdf2 	bl	80044d4 <converterTune>
 800a8f0:	2800      	cmp	r0, #0
 800a8f2:	d133      	bne.n	800a95c <main_+0x3b8>
        syslog("Converter startup failed.");
 800a8f4:	4867      	ldr	r0, [pc, #412]	; (800aa94 <main_+0x4f0>)
    entry->param = param;
 800a8f6:	2600      	movs	r6, #0
        syslog("Converter startup done.");
 800a8f8:	f7fe fa08 	bl	8008d0c <syslog>
    entry->name = name;
 800a8fc:	4866      	ldr	r0, [pc, #408]	; (800aa98 <main_+0x4f4>)
 800a8fe:	4b67      	ldr	r3, [pc, #412]	; (800aa9c <main_+0x4f8>)
    monitorKick(&sanityReboot, true);
 800a900:	2101      	movs	r1, #1
 800a902:	60c3      	str	r3, [r0, #12]
    entry->callback = callback;
 800a904:	4b66      	ldr	r3, [pc, #408]	; (800aaa0 <main_+0x4fc>)
    entry->param = param;
 800a906:	6046      	str	r6, [r0, #4]
    entry->callback = callback;
 800a908:	6003      	str	r3, [r0, #0]
    entry->next = monThreadFirst;
 800a90a:	683b      	ldr	r3, [r7, #0]
    monThreadFirst = entry;
 800a90c:	6038      	str	r0, [r7, #0]
    entry->next = monThreadFirst;
 800a90e:	6083      	str	r3, [r0, #8]
 800a910:	f7fa faa4 	bl	8004e5c <monitorKick>
    xTaskCreate(taskPeriodicMon, "Monitor", stackSize, NULL, 1, &monThreadHandle );
 800a914:	4b63      	ldr	r3, [pc, #396]	; (800aaa4 <main_+0x500>)
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800a916:	4c64      	ldr	r4, [pc, #400]	; (800aaa8 <main_+0x504>)
 800a918:	9301      	str	r3, [sp, #4]
 800a91a:	2301      	movs	r3, #1
 800a91c:	2280      	movs	r2, #128	; 0x80
 800a91e:	4963      	ldr	r1, [pc, #396]	; (800aaac <main_+0x508>)
 800a920:	9300      	str	r3, [sp, #0]
 800a922:	4863      	ldr	r0, [pc, #396]	; (800aab0 <main_+0x50c>)
 800a924:	4633      	mov	r3, r6
 800a926:	f7fd f9a1 	bl	8007c6c <xTaskCreate.isra.0>
  osalSysLock();
 800a92a:	f7fa f83b 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800a92e:	7827      	ldrb	r7, [r4, #0]
 800a930:	1e7b      	subs	r3, r7, #1
 800a932:	2b01      	cmp	r3, #1
 800a934:	d914      	bls.n	800a960 <main_+0x3bc>
 800a936:	f7fa f845 	bl	80049c4 <vTaskEndScheduler>
 800a93a:	e7fe      	b.n	800a93a <main_+0x396>
        shellCommandRegister("max", cmdMax, &loPLL);
 800a93c:	4847      	ldr	r0, [pc, #284]	; (800aa5c <main_+0x4b8>)
 800a93e:	4a3e      	ldr	r2, [pc, #248]	; (800aa38 <main_+0x494>)
 800a940:	4947      	ldr	r1, [pc, #284]	; (800aa60 <main_+0x4bc>)
 800a942:	f7f9 fc87 	bl	8004254 <shellCommandRegister>
    	syslog("MAX2870 init failed.");
 800a946:	485b      	ldr	r0, [pc, #364]	; (800aab4 <main_+0x510>)
 800a948:	e794      	b.n	800a874 <main_+0x2d0>
        syslog("Temperature sensor init done.");
 800a94a:	485b      	ldr	r0, [pc, #364]	; (800aab8 <main_+0x514>)
 800a94c:	f7fe f9de 	bl	8008d0c <syslog>
        shellCommandRegister("temp", cmdTemp, &tcxoTempSensor);
 800a950:	4622      	mov	r2, r4
 800a952:	495a      	ldr	r1, [pc, #360]	; (800aabc <main_+0x518>)
 800a954:	485a      	ldr	r0, [pc, #360]	; (800aac0 <main_+0x51c>)
 800a956:	f7f9 fc7d 	bl	8004254 <shellCommandRegister>
 800a95a:	e7b1      	b.n	800a8c0 <main_+0x31c>
        syslog("Converter startup done.");
 800a95c:	4859      	ldr	r0, [pc, #356]	; (800aac4 <main_+0x520>)
 800a95e:	e7ca      	b.n	800a8f6 <main_+0x352>
  usbp->config = config;
 800a960:	4b59      	ldr	r3, [pc, #356]	; (800aac8 <main_+0x524>)
    usbp->epc[i] = NULL;
 800a962:	2220      	movs	r2, #32
 800a964:	4631      	mov	r1, r6
 800a966:	f104 000c 	add.w	r0, r4, #12
  usbp->config = config;
 800a96a:	6063      	str	r3, [r4, #4]
    usbp->epc[i] = NULL;
 800a96c:	f000 ff26 	bl	800b7bc <memset>
  if (usbp->state == USB_STOP) {
 800a970:	2f01      	cmp	r7, #1
 800a972:	d11a      	bne.n	800a9aa <main_+0x406>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a974:	21d0      	movs	r1, #208	; 0xd0
      rccEnableUSB(FALSE);
 800a976:	4a2d      	ldr	r2, [pc, #180]	; (800aa2c <main_+0x488>)
 800a978:	69d3      	ldr	r3, [r2, #28]
 800a97a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800a97e:	61d3      	str	r3, [r2, #28]
 800a980:	4a2b      	ldr	r2, [pc, #172]	; (800aa30 <main_+0x48c>)
      STM32_USB->CNTR = CNTR_FRES;
 800a982:	4b52      	ldr	r3, [pc, #328]	; (800aacc <main_+0x528>)
 800a984:	641f      	str	r7, [r3, #64]	; 0x40
 800a986:	f882 1313 	strb.w	r1, [r2, #787]	; 0x313
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a98a:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 800a98e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a992:	6011      	str	r1, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a994:	21e0      	movs	r1, #224	; 0xe0
 800a996:	f882 1314 	strb.w	r1, [r2, #788]	; 0x314
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a99a:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800a99e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a9a2:	6011      	str	r1, [r2, #0]
      STM32_USB->CNTR = 0;
 800a9a4:	641e      	str	r6, [r3, #64]	; 0x40
    _usb_reset(usbp);
 800a9a6:	f7fb fbe7 	bl	8006178 <_usb_reset.constprop.0>
  usbp->state = USB_READY;
 800a9aa:	2602      	movs	r6, #2
  sdup->vmt = &vmt;
 800a9ac:	4848      	ldr	r0, [pc, #288]	; (800aad0 <main_+0x52c>)
 800a9ae:	7026      	strb	r6, [r4, #0]
    osalOsRescheduleS();
 800a9b0:	f7fa f87e 	bl	8004ab0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800a9b4:	f7fa fa0e 	bl	8004dd4 <vPortExitCritical>
 800a9b8:	4b46      	ldr	r3, [pc, #280]	; (800aad4 <main_+0x530>)
  sdup->state = SDU_STOP;
 800a9ba:	2101      	movs	r1, #1
  sdup->vmt = &vmt;
 800a9bc:	6003      	str	r3, [r0, #0]
    event_source->setEvents = 0;
 800a9be:	2300      	movs	r3, #0
  ibqp->bsize     = size + sizeof (size_t);
 800a9c0:	f44f 7c82 	mov.w	ip, #260	; 0x104
  ibqp->brdptr    = bp;
 800a9c4:	f100 0788 	add.w	r7, r0, #136	; 0x88
  ibqp->ptr       = NULL;
 800a9c8:	e9c0 730f 	strd	r7, r3, [r0, #60]	; 0x3c
  ibqp->bcounter  = 0;
 800a9cc:	6243      	str	r3, [r0, #36]	; 0x24
    event_source->firstRepeater = NULL;
 800a9ce:	e9c0 3301 	strd	r3, r3, [r0, #4]
    thread_queue->tail = NULL;
 800a9d2:	e9c0 3306 	strd	r3, r3, [r0, #24]
  ibqp->bwrptr    = bp;
 800a9d6:	e9c0 770a 	strd	r7, r7, [r0, #40]	; 0x28
 800a9da:	e9c0 3314 	strd	r3, r3, [r0, #80]	; 0x50
  obqp->top       = NULL;
 800a9de:	e9c0 331e 	strd	r3, r3, [r0, #120]	; 0x78
    event_source->waitThread = NULL;
 800a9e2:	60c3      	str	r3, [r0, #12]
  ibqp->top       = NULL;
 800a9e4:	6443      	str	r3, [r0, #68]	; 0x44
  ibqp->notify    = infy;
 800a9e6:	4f3c      	ldr	r7, [pc, #240]	; (800aad8 <main_+0x534>)
  obqp->notify    = onfy;
 800a9e8:	4b3c      	ldr	r3, [pc, #240]	; (800aadc <main_+0x538>)
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800a9ea:	f500 7224 	add.w	r2, r0, #656	; 0x290
  sdup->state = SDU_STOP;
 800a9ee:	7501      	strb	r1, [r0, #20]
  ibqp->suspended = suspended;
 800a9f0:	f880 1020 	strb.w	r1, [r0, #32]
  obqp->suspended = suspended;
 800a9f4:	f880 1058 	strb.w	r1, [r0, #88]	; 0x58
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800a9f8:	f500 6193 	add.w	r1, r0, #1176	; 0x498
  ibqp->bn        = n;
 800a9fc:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
  obqp->bwrptr    = bp;
 800aa00:	e9c0 2218 	strd	r2, r2, [r0, #96]	; 0x60
  obqp->bsize     = size + sizeof (size_t);
 800aa04:	e9c0 1c1a 	strd	r1, ip, [r0, #104]	; 0x68
  obqp->buffers   = bp;
 800aa08:	e9c0 621c 	strd	r6, r2, [r0, #112]	; 0x70
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800aa0c:	6302      	str	r2, [r0, #48]	; 0x30
  ibqp->link      = link;
 800aa0e:	e9c0 7012 	strd	r7, r0, [r0, #72]	; 0x48
  obqp->bcounter  = n;
 800aa12:	65c6      	str	r6, [r0, #92]	; 0x5c
  obqp->link      = link;
 800aa14:	e9c0 3020 	strd	r3, r0, [r0, #128]	; 0x80
  osalSysLock();
 800aa18:	f7f9 ffc4 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800aa1c:	7d03      	ldrb	r3, [r0, #20]
 800aa1e:	3b01      	subs	r3, #1
 800aa20:	2b01      	cmp	r3, #1
 800aa22:	d95d      	bls.n	800aae0 <main_+0x53c>
 800aa24:	f7f9 ffce 	bl	80049c4 <vTaskEndScheduler>
 800aa28:	e7fe      	b.n	800aa28 <main_+0x484>
 800aa2a:	bf00      	nop
 800aa2c:	40021000 	.word	0x40021000
 800aa30:	e000e100 	.word	0xe000e100
 800aa34:	2000119c 	.word	0x2000119c
 800aa38:	20001098 	.word	0x20001098
 800aa3c:	20001198 	.word	0x20001198
 800aa40:	0800c54a 	.word	0x0800c54a
 800aa44:	0800b67d 	.word	0x0800b67d
 800aa48:	0800ca20 	.word	0x0800ca20
 800aa4c:	200011a0 	.word	0x200011a0
 800aa50:	0800c54e 	.word	0x0800c54e
 800aa54:	080091ad 	.word	0x080091ad
 800aa58:	20001180 	.word	0x20001180
 800aa5c:	0800c556 	.word	0x0800c556
 800aa60:	0800a211 	.word	0x0800a211
 800aa64:	0800c55a 	.word	0x0800c55a
 800aa68:	20001338 	.word	0x20001338
 800aa6c:	0800ca40 	.word	0x0800ca40
 800aa70:	20000934 	.word	0x20000934
 800aa74:	0800c582 	.word	0x0800c582
 800aa78:	20001020 	.word	0x20001020
 800aa7c:	08009739 	.word	0x08009739
 800aa80:	0800c8e4 	.word	0x0800c8e4
 800aa84:	0800758d 	.word	0x0800758d
 800aa88:	0800c5c5 	.word	0x0800c5c5
 800aa8c:	0800c5cd 	.word	0x0800c5cd
 800aa90:	20000914 	.word	0x20000914
 800aa94:	0800c5df 	.word	0x0800c5df
 800aa98:	2000121c 	.word	0x2000121c
 800aa9c:	0800c611 	.word	0x0800c611
 800aaa0:	08007ecd 	.word	0x08007ecd
 800aaa4:	200011a4 	.word	0x200011a4
 800aaa8:	20000f54 	.word	0x20000f54
 800aaac:	0800c618 	.word	0x0800c618
 800aab0:	08006591 	.word	0x08006591
 800aab4:	0800c56d 	.word	0x0800c56d
 800aab8:	0800c5a2 	.word	0x0800c5a2
 800aabc:	08009539 	.word	0x08009539
 800aac0:	0800c5c0 	.word	0x0800c5c0
 800aac4:	0800c5f9 	.word	0x0800c5f9
 800aac8:	0800cb94 	.word	0x0800cb94
 800aacc:	40005c00 	.word	0x40005c00
 800aad0:	20000a44 	.word	0x20000a44
 800aad4:	0800cce0 	.word	0x0800cce0
 800aad8:	080077d9 	.word	0x080077d9
 800aadc:	08004bd1 	.word	0x08004bd1
  sdup->config = config;
 800aae0:	4b07      	ldr	r3, [pc, #28]	; (800ab00 <main_+0x55c>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800aae2:	62e0      	str	r0, [r4, #44]	; 0x2c
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800aae4:	64a0      	str	r0, [r4, #72]	; 0x48
    usbp->in_params[config->int_in - 1U]  = sdup;
 800aae6:	6320      	str	r0, [r4, #48]	; 0x30
  sdup->config = config;
 800aae8:	f8c0 3498 	str.w	r3, [r0, #1176]	; 0x498
  sdup->state = SDU_READY;
 800aaec:	7506      	strb	r6, [r0, #20]
    osalOsRescheduleS();
 800aaee:	f7f9 ffdf 	bl	8004ab0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800aaf2:	f7fa f96f 	bl	8004dd4 <vPortExitCritical>
{
    usbStart(&USBD1, &usbcfg);
    sduObjectInit(&SDU1);
    sduStart(&SDU1, &serusbcfg);

    usbConnectBus(serusbcfg.usbp);
 800aaf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
    syslog("USB init done.");
 800aafa:	4802      	ldr	r0, [pc, #8]	; (800ab04 <main_+0x560>)
 800aafc:	612b      	str	r3, [r5, #16]
 800aafe:	e595      	b.n	800a62c <main_+0x88>
 800ab00:	0800cb2c 	.word	0x0800cb2c
 800ab04:	0800c620 	.word	0x0800c620

0800ab08 <cmdI2C>:
    }
    chprintf(chp, SHELL_NEWLINE_STR);
}

void cmdI2C(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 800ab08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ab0c:	4606      	mov	r6, r0
 800ab0e:	460c      	mov	r4, r1
 800ab10:	4698      	mov	r8, r3
    I2CDriver* i2c = (I2CDriver*)user;

    if(argc == 0) {
 800ab12:	4615      	mov	r5, r2
{
 800ab14:	b087      	sub	sp, #28
    if(argc == 0) {
 800ab16:	b92a      	cbnz	r2, 800ab24 <cmdI2C+0x1c>
        cmdI2CUsage(chp);
 800ab18:	4620      	mov	r0, r4
        cmdI2CScan(i2c, chp);
    } else {
        cmdI2CUsage(chp);
        return;
    }
}
 800ab1a:	b007      	add	sp, #28
 800ab1c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        cmdI2CUsage(chp);
 800ab20:	f7fd bf22 	b.w	8008968 <cmdI2CUsage>
    if(!strcmp(argv[0], "test")) {
 800ab24:	681f      	ldr	r7, [r3, #0]
 800ab26:	4966      	ldr	r1, [pc, #408]	; (800acc0 <cmdI2C+0x1b8>)
 800ab28:	4638      	mov	r0, r7
 800ab2a:	f7f9 f849 	bl	8003bc0 <strcmp>
 800ab2e:	b9a0      	cbnz	r0, 800ab5a <cmdI2C+0x52>
    i2cAcquireBus(i2c);
 800ab30:	4630      	mov	r0, r6
 800ab32:	f7fa fe01 	bl	8005738 <i2cAcquireBus>
    i2c_result retVal = i2cSafeRawUnclogBus(i2c);
 800ab36:	4630      	mov	r0, r6
 800ab38:	f7fd f9fc 	bl	8007f34 <i2cSafeRawUnclogBus>
 800ab3c:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 800ab3e:	4630      	mov	r0, r6
 800ab40:	f7fd fd7c 	bl	800863c <i2cReleaseBus>
        chprintf(chp, "Verdict: %s"SHELL_NEWLINE_STR, i2cSafeResultToString(i2cSafeTestBus(i2c)));
 800ab44:	4628      	mov	r0, r5
 800ab46:	f7f9 fc03 	bl	8004350 <i2cSafeResultToString>
 800ab4a:	4602      	mov	r2, r0
 800ab4c:	495d      	ldr	r1, [pc, #372]	; (800acc4 <cmdI2C+0x1bc>)
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800ab4e:	4620      	mov	r0, r4
}
 800ab50:	b007      	add	sp, #28
 800ab52:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800ab56:	f7fd bdc0 	b.w	80086da <chprintf>
    if(!strcmp(argv[0], "set")) {
 800ab5a:	4638      	mov	r0, r7
 800ab5c:	495a      	ldr	r1, [pc, #360]	; (800acc8 <cmdI2C+0x1c0>)
 800ab5e:	f7f9 f82f 	bl	8003bc0 <strcmp>
 800ab62:	4681      	mov	r9, r0
 800ab64:	2800      	cmp	r0, #0
 800ab66:	d149      	bne.n	800abfc <cmdI2C+0xf4>
        if(argc<4) return false;
 800ab68:	2d03      	cmp	r5, #3
 800ab6a:	dd5b      	ble.n	800ac24 <cmdI2C+0x11c>
        if(argc>4) stress = true;
 800ab6c:	3d04      	subs	r5, #4
        regValue = strToInt(argv[3], 16);
 800ab6e:	f04f 0110 	mov.w	r1, #16
 800ab72:	f8d8 000c 	ldr.w	r0, [r8, #12]
        if(argc>4) stress = true;
 800ab76:	bf18      	it	ne
 800ab78:	2501      	movne	r5, #1
        regValue = strToInt(argv[3], 16);
 800ab7a:	f7f9 fb2a 	bl	80041d2 <strToInt>
        wantToRead = false;
 800ab7e:	464f      	mov	r7, r9
        regValue = strToInt(argv[3], 16);
 800ab80:	f88d 0017 	strb.w	r0, [sp, #23]
    uint8_t devAddr = strToInt(argv[1], 16);
 800ab84:	2110      	movs	r1, #16
 800ab86:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800ab8a:	f7f9 fb22 	bl	80041d2 <strToInt>
 800ab8e:	fa5f f980 	uxtb.w	r9, r0
    uint8_t regAddr = strToInt(argv[2], 16);
 800ab92:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800ab96:	f7f9 fb1c 	bl	80041d2 <strToInt>
    uint32_t stressCnt = 0;
 800ab9a:	f04f 0a00 	mov.w	sl, #0
    uint8_t regAddr = strToInt(argv[2], 16);
 800ab9e:	9003      	str	r0, [sp, #12]
 800aba0:	f89d b00c 	ldrb.w	fp, [sp, #12]
        if(wantToRead) {
 800aba4:	b3b7      	cbz	r7, 800ac14 <cmdI2C+0x10c>
            result = i2cSafeReadRegStandard(i2c, devAddr, regAddr, &regValue);
 800aba6:	465a      	mov	r2, fp
 800aba8:	4649      	mov	r1, r9
 800abaa:	4630      	mov	r0, r6
 800abac:	f10d 0317 	add.w	r3, sp, #23
 800abb0:	f7fe fc96 	bl	80094e0 <i2cSafeReadRegStandard>
            result = i2cSafeWriteRegStandard(i2c, devAddr, regAddr, regValue);
 800abb4:	4680      	mov	r8, r0
        if(result != I2C_BUS_OK) {
 800abb6:	b110      	cbz	r0, 800abbe <cmdI2C+0xb6>
            regValue = 0;
 800abb8:	2300      	movs	r3, #0
 800abba:	f88d 3017 	strb.w	r3, [sp, #23]
        if(stress) {
 800abbe:	b12d      	cbz	r5, 800abcc <cmdI2C+0xc4>
            printfFixed(chp, 7, "%u", stressCnt);
 800abc0:	4653      	mov	r3, sl
 800abc2:	2107      	movs	r1, #7
 800abc4:	4620      	mov	r0, r4
 800abc6:	4a41      	ldr	r2, [pc, #260]	; (800accc <cmdI2C+0x1c4>)
 800abc8:	f7fd ff30 	bl	8008a2c <printfFixed>
        chprintf(chp, "Status: %s, address: 0x%02x, register: 0x%02x, value: 0x%02x"SHELL_NEWLINE_STR,
 800abcc:	4640      	mov	r0, r8
 800abce:	f7f9 fbbf 	bl	8004350 <i2cSafeResultToString>
 800abd2:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800abd6:	4602      	mov	r2, r0
 800abd8:	9301      	str	r3, [sp, #4]
 800abda:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800abde:	4620      	mov	r0, r4
 800abe0:	9300      	str	r3, [sp, #0]
 800abe2:	493b      	ldr	r1, [pc, #236]	; (800acd0 <cmdI2C+0x1c8>)
 800abe4:	464b      	mov	r3, r9
 800abe6:	f7fd fd78 	bl	80086da <chprintf>
        stressCnt++;
 800abea:	f10a 0a01 	add.w	sl, sl, #1
    } while (stress && stressCnt <= 100000);
 800abee:	b115      	cbz	r5, 800abf6 <cmdI2C+0xee>
 800abf0:	4b38      	ldr	r3, [pc, #224]	; (800acd4 <cmdI2C+0x1cc>)
 800abf2:	459a      	cmp	sl, r3
 800abf4:	d1d6      	bne.n	800aba4 <cmdI2C+0x9c>
}
 800abf6:	b007      	add	sp, #28
 800abf8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if(!strcmp(argv[0], "get")) {
 800abfc:	4638      	mov	r0, r7
 800abfe:	4936      	ldr	r1, [pc, #216]	; (800acd8 <cmdI2C+0x1d0>)
 800ac00:	f7f8 ffde 	bl	8003bc0 <strcmp>
 800ac04:	b970      	cbnz	r0, 800ac24 <cmdI2C+0x11c>
        if(argc<3) return false;
 800ac06:	2d02      	cmp	r5, #2
 800ac08:	dd0c      	ble.n	800ac24 <cmdI2C+0x11c>
        if(argc>3) stress = true;
 800ac0a:	3d03      	subs	r5, #3
 800ac0c:	bf18      	it	ne
 800ac0e:	2501      	movne	r5, #1
        wantToRead = true;
 800ac10:	2701      	movs	r7, #1
 800ac12:	e7b7      	b.n	800ab84 <cmdI2C+0x7c>
            result = i2cSafeWriteRegStandard(i2c, devAddr, regAddr, regValue);
 800ac14:	465a      	mov	r2, fp
 800ac16:	4649      	mov	r1, r9
 800ac18:	4630      	mov	r0, r6
 800ac1a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800ac1e:	f7ff fca3 	bl	800a568 <i2cSafeWriteRegStandard>
 800ac22:	e7c7      	b.n	800abb4 <cmdI2C+0xac>
    } else if(!strcmp(argv[0], "errors")) {
 800ac24:	4638      	mov	r0, r7
 800ac26:	492d      	ldr	r1, [pc, #180]	; (800acdc <cmdI2C+0x1d4>)
 800ac28:	f7f8 ffca 	bl	8003bc0 <strcmp>
 800ac2c:	b940      	cbnz	r0, 800ac40 <cmdI2C+0x138>

uint32_t i2cSafeGetNumberOfErrors(I2CDriver* i2c)
{
    osalSysLock();
 800ac2e:	f7f9 feb9 	bl	80049a4 <vPortEnterCritical>
    uint32_t result = i2c->i2cErrors;
 800ac32:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
    osalSysUnlock();
 800ac36:	f7fa f8d9 	bl	8004dec <osalSysUnlock.lto_priv.0>
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800ac3a:	4602      	mov	r2, r0
 800ac3c:	4928      	ldr	r1, [pc, #160]	; (800ace0 <cmdI2C+0x1d8>)
 800ac3e:	e786      	b.n	800ab4e <cmdI2C+0x46>
    } else if(!strcmp(argv[0], "scan")) {
 800ac40:	4638      	mov	r0, r7
 800ac42:	4928      	ldr	r1, [pc, #160]	; (800ace4 <cmdI2C+0x1dc>)
 800ac44:	f7f8 ffbc 	bl	8003bc0 <strcmp>
 800ac48:	4605      	mov	r5, r0
 800ac4a:	2800      	cmp	r0, #0
 800ac4c:	f47f af64 	bne.w	800ab18 <cmdI2C+0x10>
    chprintf(chp, "   ");
 800ac50:	4620      	mov	r0, r4
 800ac52:	4925      	ldr	r1, [pc, #148]	; (800ace8 <cmdI2C+0x1e0>)
 800ac54:	f7fd fd41 	bl	80086da <chprintf>
    for(int addr = 0; addr <= 0xF; addr++) {
 800ac58:	462f      	mov	r7, r5
        chprintf(chp, "%1x  ", addr);
 800ac5a:	f8df 8090 	ldr.w	r8, [pc, #144]	; 800acec <cmdI2C+0x1e4>
 800ac5e:	463a      	mov	r2, r7
 800ac60:	4641      	mov	r1, r8
 800ac62:	4620      	mov	r0, r4
    for(int addr = 0; addr <= 0xF; addr++) {
 800ac64:	3701      	adds	r7, #1
        chprintf(chp, "%1x  ", addr);
 800ac66:	f7fd fd38 	bl	80086da <chprintf>
    for(int addr = 0; addr <= 0xF; addr++) {
 800ac6a:	2f10      	cmp	r7, #16
 800ac6c:	d1f7      	bne.n	800ac5e <cmdI2C+0x156>
            chprintf(chp, SHELL_NEWLINE_STR"%1x ", addr/16);
 800ac6e:	4f20      	ldr	r7, [pc, #128]	; (800acf0 <cmdI2C+0x1e8>)
            chprintf(chp, "EE ");
 800ac70:	f8df 8080 	ldr.w	r8, [pc, #128]	; 800acf4 <cmdI2C+0x1ec>
            chprintf(chp, "-- ");
 800ac74:	f8df 9080 	ldr.w	r9, [pc, #128]	; 800acf8 <cmdI2C+0x1f0>
        if(addr % 16 == 0) {
 800ac78:	072b      	lsls	r3, r5, #28
 800ac7a:	d104      	bne.n	800ac86 <cmdI2C+0x17e>
            chprintf(chp, SHELL_NEWLINE_STR"%1x ", addr/16);
 800ac7c:	4639      	mov	r1, r7
 800ac7e:	4620      	mov	r0, r4
 800ac80:	112a      	asrs	r2, r5, #4
 800ac82:	f7fd fd2a 	bl	80086da <chprintf>
        i2c_result result = i2cSafeReadRegStandard(i2c, addr, 0, &regValue);
 800ac86:	2200      	movs	r2, #0
 800ac88:	4630      	mov	r0, r6
 800ac8a:	f10d 0317 	add.w	r3, sp, #23
 800ac8e:	b2e9      	uxtb	r1, r5
 800ac90:	f7fe fc26 	bl	80094e0 <i2cSafeReadRegStandard>
        if(result == I2C_BUS_OK) {
 800ac94:	b960      	cbnz	r0, 800acb0 <cmdI2C+0x1a8>
            chprintf(chp, "%02x ", addr);
 800ac96:	462a      	mov	r2, r5
 800ac98:	4620      	mov	r0, r4
 800ac9a:	4918      	ldr	r1, [pc, #96]	; (800acfc <cmdI2C+0x1f4>)
 800ac9c:	f7fd fd1d 	bl	80086da <chprintf>
    for(int addr = 0; addr <= 0x7F; addr++) {
 800aca0:	3501      	adds	r5, #1
 800aca2:	2d80      	cmp	r5, #128	; 0x80
 800aca4:	d1e8      	bne.n	800ac78 <cmdI2C+0x170>
    chprintf(chp, SHELL_NEWLINE_STR);
 800aca6:	4620      	mov	r0, r4
 800aca8:	4915      	ldr	r1, [pc, #84]	; (800ad00 <cmdI2C+0x1f8>)
 800acaa:	f7fd fd16 	bl	80086da <chprintf>
}
 800acae:	e7a2      	b.n	800abf6 <cmdI2C+0xee>
        } else if(result == I2C_BUS_RESET) {
 800acb0:	3002      	adds	r0, #2
            chprintf(chp, "-- ");
 800acb2:	bf0c      	ite	eq
 800acb4:	4649      	moveq	r1, r9
            chprintf(chp, "EE ");
 800acb6:	4641      	movne	r1, r8
 800acb8:	4620      	mov	r0, r4
 800acba:	f7fd fd0e 	bl	80086da <chprintf>
 800acbe:	e7ef      	b.n	800aca0 <cmdI2C+0x198>
 800acc0:	0800c638 	.word	0x0800c638
 800acc4:	0800c63d 	.word	0x0800c63d
 800acc8:	0800c056 	.word	0x0800c056
 800accc:	0800c0bc 	.word	0x0800c0bc
 800acd0:	0800c64f 	.word	0x0800c64f
 800acd4:	000186a1 	.word	0x000186a1
 800acd8:	0800c64b 	.word	0x0800c64b
 800acdc:	0800c68e 	.word	0x0800c68e
 800ace0:	0800c695 	.word	0x0800c695
 800ace4:	0800c6a6 	.word	0x0800c6a6
 800ace8:	0800bb7c 	.word	0x0800bb7c
 800acec:	0800c6ab 	.word	0x0800c6ab
 800acf0:	0800c6b1 	.word	0x0800c6b1
 800acf4:	0800c6c2 	.word	0x0800c6c2
 800acf8:	0800c6be 	.word	0x0800c6be
 800acfc:	0800c6b8 	.word	0x0800c6b8
 800ad00:	0800be0f 	.word	0x0800be0f

0800ad04 <syslogISRUnknownPriority>:

static bool syslogISRHasSomething;
static char syslogISRBuffer[64];

bool syslogISRUnknownPriority(const char *format, ...)
{
 800ad04:	b40f      	push	{r0, r1, r2, r3}
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad06:	f04f 0201 	mov.w	r2, #1
{
 800ad0a:	b530      	push	{r4, r5, lr}
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad0c:	4b11      	ldr	r3, [pc, #68]	; (800ad54 <syslogISRUnknownPriority+0x50>)
{
 800ad0e:	b087      	sub	sp, #28
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad10:	e8d3 5f4f 	ldrexb	r5, [r3]
 800ad14:	e8c3 2f41 	strexb	r1, r2, [r3]
 800ad18:	2900      	cmp	r1, #0
 800ad1a:	d1f9      	bne.n	800ad10 <syslogISRUnknownPriority+0xc>
 800ad1c:	b2eb      	uxtb	r3, r5
 800ad1e:	f3bf 8f5b 	dmb	ish
 800ad22:	b9ab      	cbnz	r3, 800ad50 <syslogISRUnknownPriority+0x4c>
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800ad24:	490c      	ldr	r1, [pc, #48]	; (800ad58 <syslogISRUnknownPriority+0x54>)
  msp->buffer = buffer;
 800ad26:	4c0d      	ldr	r4, [pc, #52]	; (800ad5c <syslogISRUnknownPriority+0x58>)
  msp->vmt    = &vmt;
 800ad28:	9101      	str	r1, [sp, #4]
  msp->size   = size;
 800ad2a:	213f      	movs	r1, #63	; 0x3f
        return false;
    }

    va_list args;
    va_start(args, format);
 800ad2c:	aa0b      	add	r2, sp, #44	; 0x2c
  msp->eos    = eos;
 800ad2e:	e9cd 1303 	strd	r1, r3, [sp, #12]

    MemoryStream ms;
    msObjectInit(&ms, (uint8_t *)syslogISRBuffer, sizeof(syslogISRBuffer)-1, 0);
    BaseSequentialStream *chp = (BaseSequentialStream *)(void *)&ms;

    chvprintf(chp, format, args);
 800ad32:	a801      	add	r0, sp, #4
 800ad34:	990a      	ldr	r1, [sp, #40]	; 0x28
  msp->offset = 0;
 800ad36:	9305      	str	r3, [sp, #20]
    va_start(args, format);
 800ad38:	9200      	str	r2, [sp, #0]
  msp->buffer = buffer;
 800ad3a:	9402      	str	r4, [sp, #8]
    chvprintf(chp, format, args);
 800ad3c:	f7fb fede 	bl	8006afc <chvprintf>
    syslogISRBuffer[ms.eos] = 0;

    va_end(args);

    return true;
 800ad40:	2001      	movs	r0, #1
    syslogISRBuffer[ms.eos] = 0;
 800ad42:	9b04      	ldr	r3, [sp, #16]
 800ad44:	54e5      	strb	r5, [r4, r3]
}
 800ad46:	b007      	add	sp, #28
 800ad48:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800ad4c:	b004      	add	sp, #16
 800ad4e:	4770      	bx	lr
        return false;
 800ad50:	2000      	movs	r0, #0
 800ad52:	e7f8      	b.n	800ad46 <syslogISRUnknownPriority+0x42>
 800ad54:	2000130c 	.word	0x2000130c
 800ad58:	0800cd00 	.word	0x0800cd00
 800ad5c:	200012cc 	.word	0x200012cc

0800ad60 <BusFault_Handler>:
#error "the constant CORTEX_NUM_VECTORS must be between 8 and 240 inclusive"
#endif

extern void unhandledException(void);

void _unhandled_exception(void){
 800ad60:	b508      	push	{r3, lr}
}

void unhandledException(void)
{
    /* Check which vector is active */
    unsigned int vectorId = NVIC_ICSR & 0x1ff;
 800ad62:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800ad66:	f8d3 1d04 	ldr.w	r1, [r3, #3332]	; 0xd04

    if(vectorId >= 16) {
 800ad6a:	f411 7ff8 	tst.w	r1, #496	; 0x1f0
 800ad6e:	d013      	beq.n	800ad98 <BusFault_Handler+0x38>
    *pendReg = _BV(vectorId%32);
 800ad70:	2301      	movs	r3, #1
    unsigned int vectorId = NVIC_ICSR & 0x1ff;
 800ad72:	f3c1 0108 	ubfx	r1, r1, #0, #9
        /* This can be masked */
        vectorId -= 16;
 800ad76:	3910      	subs	r1, #16
    *pendReg = _BV(vectorId%32);
 800ad78:	f001 001f 	and.w	r0, r1, #31
 800ad7c:	4083      	lsls	r3, r0
 800ad7e:	4808      	ldr	r0, [pc, #32]	; (800ada0 <BusFault_Handler+0x40>)
    volatile uint32_t* pendReg = (&NVIC_CPR) + (vectorId / 32);
 800ad80:	094a      	lsrs	r2, r1, #5
    *pendReg = _BV(vectorId%32);
 800ad82:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
        volatile uint32_t* ceReg = (&NVIC_CER) + (vectorId / 32);
 800ad86:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
        *ceReg = _BV(vectorId%32);
 800ad8a:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
        clearInterrupt(vectorId, true);

        /* Report it */
        syslogISRUnknownPriority("Unhandled vector %u.", vectorId);
 800ad8e:	4805      	ldr	r0, [pc, #20]	; (800ada4 <BusFault_Handler+0x44>)
	unhandledException();
}
 800ad90:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800ad94:	f7ff bfb6 	b.w	800ad04 <syslogISRUnknownPriority>
    } else {
        osalSysHalt("Fault");
 800ad98:	f7f9 fe14 	bl	80049c4 <vTaskEndScheduler>
 800ad9c:	e7fe      	b.n	800ad9c <BusFault_Handler+0x3c>
 800ad9e:	bf00      	nop
 800ada0:	e000e280 	.word	0xe000e280
 800ada4:	0800c6c6 	.word	0x0800c6c6

0800ada8 <usb_event>:
{
 800ada8:	b538      	push	{r3, r4, r5, lr}
 800adaa:	4604      	mov	r4, r0
 800adac:	2905      	cmp	r1, #5
 800adae:	d878      	bhi.n	800aea2 <usb_event+0xfa>
 800adb0:	e8df f001 	tbb	[pc, r1]
 800adb4:	4e08034e 	.word	0x4e08034e
 800adb8:	6a4e      	.short	0x6a4e
            syslogISRUnknownPriority("USB address assigned.");
 800adba:	483a      	ldr	r0, [pc, #232]	; (800aea4 <usb_event+0xfc>)
}
 800adbc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            syslogISRUnknownPriority("USB address assigned.");
 800adc0:	f7ff bfa0 	b.w	800ad04 <syslogISRUnknownPriority>
            osalSysLockFromISR();
 800adc4:	f7fa fd38 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
            usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 800adc8:	2101      	movs	r1, #1
 800adca:	4620      	mov	r0, r4
 800adcc:	4a36      	ldr	r2, [pc, #216]	; (800aea8 <usb_event+0x100>)
 800adce:	f7fc fe75 	bl	8007abc <usbInitEndpointI>
            usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800add2:	2102      	movs	r1, #2
 800add4:	4620      	mov	r0, r4
 800add6:	4a35      	ldr	r2, [pc, #212]	; (800aeac <usb_event+0x104>)
 800add8:	f7fc fe70 	bl	8007abc <usbInitEndpointI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800addc:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800ade0:	b19b      	cbz	r3, 800ae0a <usb_event+0x62>
  ibqp->bcounter  = 0;
 800ade2:	2500      	movs	r5, #0
 800ade4:	4c32      	ldr	r4, [pc, #200]	; (800aeb0 <usb_event+0x108>)
  ibqp->brdptr    = ibqp->buffers;
 800ade6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  ibqp->top       = NULL;
 800ade8:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
  ibqp->bwrptr    = ibqp->buffers;
 800adec:	e9c4 330a 	strd	r3, r3, [r4, #40]	; 0x28
  ibqp->bcounter  = 0;
 800adf0:	6265      	str	r5, [r4, #36]	; 0x24
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 800adf2:	f104 0018 	add.w	r0, r4, #24
 800adf6:	f7fc f861 	bl	8006ebc <osalThreadDequeueAllI.constprop.0>
  bqResumeX(&sdup->ibqueue);
 800adfa:	f884 5020 	strb.w	r5, [r4, #32]
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800adfe:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800ae02:	b92b      	cbnz	r3, 800ae10 <usb_event+0x68>
  osalDbgCheckClassI();
 800ae04:	f7f9 fdde 	bl	80049c4 <vTaskEndScheduler>
 800ae08:	e7fe      	b.n	800ae08 <usb_event+0x60>
  osalDbgCheckClassI();
 800ae0a:	f7f9 fddb 	bl	80049c4 <vTaskEndScheduler>
 800ae0e:	e7fe      	b.n	800ae0e <usb_event+0x66>
  obqp->bcounter  = bqSizeX(obqp);
 800ae10:	6f23      	ldr	r3, [r4, #112]	; 0x70
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800ae12:	f104 0050 	add.w	r0, r4, #80	; 0x50
  obqp->bcounter  = bqSizeX(obqp);
 800ae16:	65e3      	str	r3, [r4, #92]	; 0x5c
  obqp->brdptr    = obqp->buffers;
 800ae18:	6f63      	ldr	r3, [r4, #116]	; 0x74
  obqp->top       = NULL;
 800ae1a:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
  obqp->bwrptr    = obqp->buffers;
 800ae1e:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800ae22:	f7fc f84b 	bl	8006ebc <osalThreadDequeueAllI.constprop.0>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800ae26:	1d20      	adds	r0, r4, #4
 800ae28:	2101      	movs	r1, #1
  bqResumeX(&sdup->obqueue);
 800ae2a:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800ae2e:	f7fc f859 	bl	8006ee4 <osalEventBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 800ae32:	4620      	mov	r0, r4
        if(!usbConnectState) {
 800ae34:	4c1f      	ldr	r4, [pc, #124]	; (800aeb4 <usb_event+0x10c>)
 800ae36:	f7fc fca9 	bl	800778c <sdu_start_receive.isra.0>
 800ae3a:	7823      	ldrb	r3, [r4, #0]
 800ae3c:	b913      	cbnz	r3, 800ae44 <usb_event+0x9c>
            syslogISRUnknownPriority("USB up.");
 800ae3e:	481e      	ldr	r0, [pc, #120]	; (800aeb8 <usb_event+0x110>)
 800ae40:	f7ff ff60 	bl	800ad04 <syslogISRUnknownPriority>
    usbConnectState = up;
 800ae44:	2301      	movs	r3, #1
 800ae46:	7023      	strb	r3, [r4, #0]
}
 800ae48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            osalSysUnlockFromISR();
 800ae4c:	f7fa bd08 	b.w	8005860 <osalSysUnlockFromISR.lto_priv.0>
  bqSuspendI(&sdup->ibqueue);
 800ae50:	2501      	movs	r5, #1
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 800ae52:	4c17      	ldr	r4, [pc, #92]	; (800aeb0 <usb_event+0x108>)
            osalSysLockFromISR();
 800ae54:	f7fa fcf0 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 800ae58:	2102      	movs	r1, #2
 800ae5a:	1d20      	adds	r0, r4, #4
 800ae5c:	f7fc f842 	bl	8006ee4 <osalEventBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 800ae60:	f104 0018 	add.w	r0, r4, #24
 800ae64:	f884 5020 	strb.w	r5, [r4, #32]
 800ae68:	f7fc f828 	bl	8006ebc <osalThreadDequeueAllI.constprop.0>
  bqSuspendI(&sdup->obqueue);
 800ae6c:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 800ae70:	f104 0050 	add.w	r0, r4, #80	; 0x50
        if(usbConnectState) {
 800ae74:	4c0f      	ldr	r4, [pc, #60]	; (800aeb4 <usb_event+0x10c>)
 800ae76:	f7fc f821 	bl	8006ebc <osalThreadDequeueAllI.constprop.0>
 800ae7a:	7823      	ldrb	r3, [r4, #0]
 800ae7c:	b113      	cbz	r3, 800ae84 <usb_event+0xdc>
            syslogISRUnknownPriority("USB down.");
 800ae7e:	480f      	ldr	r0, [pc, #60]	; (800aebc <usb_event+0x114>)
 800ae80:	f7ff ff40 	bl	800ad04 <syslogISRUnknownPriority>
    usbConnectState = up;
 800ae84:	2300      	movs	r3, #0
 800ae86:	e7de      	b.n	800ae46 <usb_event+0x9e>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800ae88:	4c09      	ldr	r4, [pc, #36]	; (800aeb0 <usb_event+0x108>)
            osalSysLockFromISR();
 800ae8a:	f7fa fcd5 	bl	8005838 <osalSysLockFromISR.lto_priv.0>
 800ae8e:	2101      	movs	r1, #1
 800ae90:	1d20      	adds	r0, r4, #4
 800ae92:	f7fc f827 	bl	8006ee4 <osalEventBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 800ae96:	2300      	movs	r3, #0
 800ae98:	f884 3020 	strb.w	r3, [r4, #32]
  bqResumeX(&sdup->obqueue);
 800ae9c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
 800aea0:	e7d2      	b.n	800ae48 <usb_event+0xa0>
}
 800aea2:	bd38      	pop	{r3, r4, r5, pc}
 800aea4:	0800c6db 	.word	0x0800c6db
 800aea8:	0800c998 	.word	0x0800c998
 800aeac:	0800c9bc 	.word	0x0800c9bc
 800aeb0:	20000a44 	.word	0x20000a44
 800aeb4:	20001354 	.word	0x20001354
 800aeb8:	0800c6f1 	.word	0x0800c6f1
 800aebc:	0800c6f9 	.word	0x0800c6f9

0800aec0 <prvIdleTask>:
{
 800aec0:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800aec2:	4c97      	ldr	r4, [pc, #604]	; (800b120 <prvIdleTask+0x260>)
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800aec4:	4d97      	ldr	r5, [pc, #604]	; (800b124 <prvIdleTask+0x264>)
				--uxCurrentNumberOfTasks;
 800aec6:	4e98      	ldr	r6, [pc, #608]	; (800b128 <prvIdleTask+0x268>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800aec8:	6823      	ldr	r3, [r4, #0]
 800aeca:	2b00      	cmp	r3, #0
 800aecc:	d178      	bne.n	800afc0 <prvIdleTask+0x100>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800aece:	4b97      	ldr	r3, [pc, #604]	; (800b12c <prvIdleTask+0x26c>)
 800aed0:	681b      	ldr	r3, [r3, #0]
 800aed2:	2b01      	cmp	r3, #1
 800aed4:	d91c      	bls.n	800af10 <prvIdleTask+0x50>
				taskYIELD();
 800aed6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800aeda:	4a95      	ldr	r2, [pc, #596]	; (800b130 <prvIdleTask+0x270>)
 800aedc:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800aee0:	6011      	str	r1, [r2, #0]
 800aee2:	4a94      	ldr	r2, [pc, #592]	; (800b134 <prvIdleTask+0x274>)
 800aee4:	6812      	ldr	r2, [r2, #0]
 800aee6:	b14a      	cbz	r2, 800aefc <prvIdleTask+0x3c>
 800aee8:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800aeec:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800aef0:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800aef4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800aef8:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800aefc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800af00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800af04:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800af08:	f3bf 8f4f 	dsb	sy
 800af0c:	f3bf 8f6f 	isb	sy
    /*
     * Some events may happen from IRQs with unknown priority (possibly above kernel),
     * so they are written to a buffer (one entry only) and added to the syslog in
     * the IDLE thread.
     */
    if(__atomic_load_n(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800af10:	f8df 8224 	ldr.w	r8, [pc, #548]	; 800b138 <prvIdleTask+0x278>
 800af14:	f898 3000 	ldrb.w	r3, [r8]
 800af18:	f3bf 8f5b 	dmb	ish
 800af1c:	b373      	cbz	r3, 800af7c <prvIdleTask+0xbc>
        if(xSemaphoreTake(syslogSemaphore, 0)) {
 800af1e:	f8df 921c 	ldr.w	r9, [pc, #540]	; 800b13c <prvIdleTask+0x27c>
 800af22:	2100      	movs	r1, #0
 800af24:	f8d9 0000 	ldr.w	r0, [r9]
 800af28:	f7fa fa8a 	bl	8005440 <xQueueSemaphoreTake>
 800af2c:	b330      	cbz	r0, 800af7c <prvIdleTask+0xbc>
    queue->pktLen = 0;
 800af2e:	2600      	movs	r6, #0
    queue->lenHeaderStart = queue->writePtr;
 800af30:	4f83      	ldr	r7, [pc, #524]	; (800b140 <prvIdleTask+0x280>)
    packetQueueWriteByte(queue, 0x00);
 800af32:	2000      	movs	r0, #0
    queue->lenHeaderStart = queue->writePtr;
 800af34:	693b      	ldr	r3, [r7, #16]
 800af36:	61fb      	str	r3, [r7, #28]
    packetQueueWriteByte(queue, 0x00);
 800af38:	f7fb f824 	bl	8005f84 <packetQueueWriteByte.constprop.0>
    packetQueueWriteByte(queue, 0x00);
 800af3c:	2000      	movs	r0, #0
 800af3e:	f7fb f821 	bl	8005f84 <packetQueueWriteByte.constprop.0>
    queue->pktLen = 0;
 800af42:	61be      	str	r6, [r7, #24]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800af44:	f7fa ffea 	bl	8005f1c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800af48:	4b7e      	ldr	r3, [pc, #504]	; (800b144 <prvIdleTask+0x284>)
            packetQueueStartWritePacket(&syslogQueue);
            chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] {ISR} ", osalOsGetSystemTimeX());
            syslogISRBuffer[sizeof(syslogISRBuffer)-1] = 0;
 800af4a:	4f7f      	ldr	r7, [pc, #508]	; (800b148 <prvIdleTask+0x288>)
 800af4c:	681a      	ldr	r2, [r3, #0]
            chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] {ISR} ", osalOsGetSystemTimeX());
 800af4e:	497f      	ldr	r1, [pc, #508]	; (800b14c <prvIdleTask+0x28c>)
 800af50:	487f      	ldr	r0, [pc, #508]	; (800b150 <prvIdleTask+0x290>)
 800af52:	f7fd fbc2 	bl	80086da <chprintf>
            packetQueuePutBytes(&syslogQueue, (uint8_t*)syslogISRBuffer, strlen(syslogISRBuffer));
 800af56:	4638      	mov	r0, r7
            syslogISRBuffer[sizeof(syslogISRBuffer)-1] = 0;
 800af58:	f887 603f 	strb.w	r6, [r7, #63]	; 0x3f
            packetQueuePutBytes(&syslogQueue, (uint8_t*)syslogISRBuffer, strlen(syslogISRBuffer));
 800af5c:	f000 fce6 	bl	800b92c <strlen>
 800af60:	b281      	uxth	r1, r0
 800af62:	4638      	mov	r0, r7
 800af64:	f7fb f83c 	bl	8005fe0 <packetQueuePutBytes.constprop.0>
            packetQueueEndWritePacket(&syslogQueue);
 800af68:	f7fb f860 	bl	800602c <packetQueueEndWritePacket.constprop.0>
            xSemaphoreGive(syslogSemaphore);
 800af6c:	f8d9 0000 	ldr.w	r0, [r9]
 800af70:	f7fd fa4e 	bl	8008410 <xQueueGenericSend.constprop.0>

            __atomic_clear(&syslogISRHasSomething, __ATOMIC_RELEASE);
 800af74:	f3bf 8f5b 	dmb	ish
 800af78:	f888 6000 	strb.w	r6, [r8]

void vApplicationIdleHook(void)
{
    syslogIdleHook();

    if(usbConnectState && !usbShellIsUp) {
 800af7c:	4b75      	ldr	r3, [pc, #468]	; (800b154 <prvIdleTask+0x294>)
 800af7e:	781b      	ldrb	r3, [r3, #0]
 800af80:	b18b      	cbz	r3, 800afa6 <prvIdleTask+0xe6>
 800af82:	4e75      	ldr	r6, [pc, #468]	; (800b158 <prvIdleTask+0x298>)
 800af84:	7833      	ldrb	r3, [r6, #0]
 800af86:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 800af8a:	b963      	cbnz	r3, 800afa6 <prvIdleTask+0xe6>
        usbShellIsUp = true;
 800af8c:	2301      	movs	r3, #1
        /*
         * Setting the pin from the idle hook requires a non-blocking
         * GPIO driver. In practice this means almost always a native
         * CPU pin.
         */
        gpioSetPin(GPIO_LED_USB, false);
 800af8e:	f240 1003 	movw	r0, #259	; 0x103
        usbShellIsUp = true;
 800af92:	7033      	strb	r3, [r6, #0]
        gpioSetPin(GPIO_LED_USB, false);
 800af94:	f7fc faea 	bl	800756c <gpioSetPin.isra.0>

        /* Try to start the shell */
        if(!shellStart((BaseSequentialStream*)&SDU1, 128, "ShellUSB", usbShellTerminated, NULL)) {
 800af98:	4a70      	ldr	r2, [pc, #448]	; (800b15c <prvIdleTask+0x29c>)
 800af9a:	4971      	ldr	r1, [pc, #452]	; (800b160 <prvIdleTask+0x2a0>)
 800af9c:	4871      	ldr	r0, [pc, #452]	; (800b164 <prvIdleTask+0x2a4>)
 800af9e:	f7fc fe95 	bl	8007ccc <shellStart.constprop.0>
 800afa2:	b900      	cbnz	r0, 800afa6 <prvIdleTask+0xe6>
            /* We are very low on memory. This will keep trying, but priority is IDLE */
            usbShellIsUp = false;
 800afa4:	7030      	strb	r0, [r6, #0]
			xExpectedIdleTime = prvGetExpectedIdleTime();
 800afa6:	f7f9 fb99 	bl	80046dc <prvGetExpectedIdleTime>
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 800afaa:	2801      	cmp	r0, #1
 800afac:	d98b      	bls.n	800aec6 <prvIdleTask+0x6>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 800afae:	4e6e      	ldr	r6, [pc, #440]	; (800b168 <prvIdleTask+0x2a8>)
 800afb0:	4964      	ldr	r1, [pc, #400]	; (800b144 <prvIdleTask+0x284>)
				vTaskSuspendAll();
 800afb2:	f7f9 fb8b 	bl	80046cc <vTaskSuspendAll>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 800afb6:	6832      	ldr	r2, [r6, #0]
 800afb8:	680b      	ldr	r3, [r1, #0]
 800afba:	429a      	cmp	r2, r3
 800afbc:	d213      	bcs.n	800afe6 <prvIdleTask+0x126>
 800afbe:	e7fe      	b.n	800afbe <prvIdleTask+0xfe>
			taskENTER_CRITICAL();
 800afc0:	f7f9 fcf0 	bl	80049a4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800afc4:	68eb      	ldr	r3, [r5, #12]
 800afc6:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800afc8:	1d38      	adds	r0, r7, #4
 800afca:	f7f9 fb6e 	bl	80046aa <uxListRemove>
				--uxCurrentNumberOfTasks;
 800afce:	6833      	ldr	r3, [r6, #0]
			prvDeleteTCB( pxTCB );
 800afd0:	4638      	mov	r0, r7
				--uxCurrentNumberOfTasks;
 800afd2:	3b01      	subs	r3, #1
 800afd4:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 800afd6:	6823      	ldr	r3, [r4, #0]
 800afd8:	3b01      	subs	r3, #1
 800afda:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 800afdc:	f7f9 fefa 	bl	8004dd4 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 800afe0:	f7fa f9be 	bl	8005360 <prvDeleteTCB>
 800afe4:	e770      	b.n	800aec8 <prvIdleTask+0x8>
					xExpectedIdleTime = prvGetExpectedIdleTime();
 800afe6:	f7f9 fb79 	bl	80046dc <prvGetExpectedIdleTime>
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 800afea:	2801      	cmp	r0, #1
 800afec:	d97a      	bls.n	800b0e4 <prvIdleTask+0x224>
		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 800afee:	4b5f      	ldr	r3, [pc, #380]	; (800b16c <prvIdleTask+0x2ac>)
		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
 800aff0:	4f5f      	ldr	r7, [pc, #380]	; (800b170 <prvIdleTask+0x2b0>)
 800aff2:	681b      	ldr	r3, [r3, #0]
		if( ulReloadValue > ulStoppedTimerCompensation )
 800aff4:	f8df 817c 	ldr.w	r8, [pc, #380]	; 800b174 <prvIdleTask+0x2b4>
 800aff8:	4298      	cmp	r0, r3
 800affa:	bf28      	it	cs
 800affc:	4618      	movcs	r0, r3
		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
 800affe:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b002:	691a      	ldr	r2, [r3, #16]
 800b004:	f022 0201 	bic.w	r2, r2, #1
 800b008:	611a      	str	r2, [r3, #16]
		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
 800b00a:	699b      	ldr	r3, [r3, #24]
 800b00c:	f8d7 c000 	ldr.w	ip, [r7]
 800b010:	1e42      	subs	r2, r0, #1
 800b012:	fb0c 3902 	mla	r9, ip, r2, r3
		if( ulReloadValue > ulStoppedTimerCompensation )
 800b016:	f8d8 3000 	ldr.w	r3, [r8]
 800b01a:	4599      	cmp	r9, r3
			ulReloadValue -= ulStoppedTimerCompensation;
 800b01c:	bf88      	it	hi
 800b01e:	eba9 0903 	subhi.w	r9, r9, r3
		__asm volatile( "cpsid i" ::: "memory" );
 800b022:	b672      	cpsid	i
		__asm volatile( "dsb" );
 800b024:	f3bf 8f4f 	dsb	sy
		__asm volatile( "isb" );
 800b028:	f3bf 8f6f 	isb	sy
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
 800b02c:	4b52      	ldr	r3, [pc, #328]	; (800b178 <prvIdleTask+0x2b8>)
 800b02e:	681b      	ldr	r3, [r3, #0]
 800b030:	2b00      	cmp	r3, #0
 800b032:	d14b      	bne.n	800b0cc <prvIdleTask+0x20c>
		else if( xYieldPending != pdFALSE )
 800b034:	4b51      	ldr	r3, [pc, #324]	; (800b17c <prvIdleTask+0x2bc>)
 800b036:	681b      	ldr	r3, [r3, #0]
 800b038:	2b00      	cmp	r3, #0
 800b03a:	d147      	bne.n	800b0cc <prvIdleTask+0x20c>
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
 800b03c:	f8df c140 	ldr.w	ip, [pc, #320]	; 800b180 <prvIdleTask+0x2c0>
 800b040:	f8dc c000 	ldr.w	ip, [ip]
 800b044:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 800b128 <prvIdleTask+0x268>
 800b048:	f8dc c000 	ldr.w	ip, [ip]
			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 800b04c:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
 800b050:	f8cc 9014 	str.w	r9, [ip, #20]
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800b054:	f8cc 3018 	str.w	r3, [ip, #24]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b058:	f8dc 3010 	ldr.w	r3, [ip, #16]
 800b05c:	f043 0301 	orr.w	r3, r3, #1
 800b060:	f8cc 3010 	str.w	r3, [ip, #16]
			if( xModifiableIdleTime > 0 )
 800b064:	2800      	cmp	r0, #0
 800b066:	d140      	bne.n	800b0ea <prvIdleTask+0x22a>
			__asm volatile( "cpsie i" ::: "memory" );
 800b068:	b662      	cpsie	i
			__asm volatile( "dsb" );
 800b06a:	f3bf 8f4f 	dsb	sy
			__asm volatile( "isb" );
 800b06e:	f3bf 8f6f 	isb	sy
			__asm volatile( "cpsid i" ::: "memory" );
 800b072:	b672      	cpsid	i
			__asm volatile( "dsb" );
 800b074:	f3bf 8f4f 	dsb	sy
			__asm volatile( "isb" );
 800b078:	f3bf 8f6f 	isb	sy
			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
 800b07c:	f04f 2ee0 	mov.w	lr, #3758153728	; 0xe000e000
 800b080:	2302      	movs	r3, #2
 800b082:	f8ce 3010 	str.w	r3, [lr, #16]
			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 800b086:	f8de 3010 	ldr.w	r3, [lr, #16]
 800b08a:	03db      	lsls	r3, r3, #15
 800b08c:	d533      	bpl.n	800b0f6 <prvIdleTask+0x236>
				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
 800b08e:	6838      	ldr	r0, [r7, #0]
 800b090:	f8de 3018 	ldr.w	r3, [lr, #24]
				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
 800b094:	f8d8 c000 	ldr.w	ip, [r8]
				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
 800b098:	4403      	add	r3, r0
 800b09a:	3b01      	subs	r3, #1
 800b09c:	eba3 0309 	sub.w	r3, r3, r9
				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
 800b0a0:	4563      	cmp	r3, ip
 800b0a2:	d301      	bcc.n	800b0a8 <prvIdleTask+0x1e8>
 800b0a4:	4298      	cmp	r0, r3
 800b0a6:	d200      	bcs.n	800b0aa <prvIdleTask+0x1ea>
					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
 800b0a8:	1e43      	subs	r3, r0, #1
				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
 800b0aa:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
 800b0ae:	6143      	str	r3, [r0, #20]
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800b0b0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b0b4:	2000      	movs	r0, #0
 800b0b6:	6198      	str	r0, [r3, #24]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b0b8:	6918      	ldr	r0, [r3, #16]
 800b0ba:	f040 0001 	orr.w	r0, r0, #1
 800b0be:	6118      	str	r0, [r3, #16]
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
 800b0c0:	6808      	ldr	r0, [r1, #0]
 800b0c2:	6836      	ldr	r6, [r6, #0]
 800b0c4:	4410      	add	r0, r2
 800b0c6:	42b0      	cmp	r0, r6
 800b0c8:	d925      	bls.n	800b116 <prvIdleTask+0x256>
 800b0ca:	e7fe      	b.n	800b0ca <prvIdleTask+0x20a>
			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 800b0cc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b0d0:	699a      	ldr	r2, [r3, #24]
 800b0d2:	615a      	str	r2, [r3, #20]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b0d4:	691a      	ldr	r2, [r3, #16]
 800b0d6:	f042 0201 	orr.w	r2, r2, #1
 800b0da:	611a      	str	r2, [r3, #16]
			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 800b0dc:	683a      	ldr	r2, [r7, #0]
 800b0de:	3a01      	subs	r2, #1
 800b0e0:	615a      	str	r2, [r3, #20]
			__asm volatile( "cpsie i" ::: "memory" );
 800b0e2:	b662      	cpsie	i
				( void ) xTaskResumeAll();
 800b0e4:	f7fa f812 	bl	800510c <xTaskResumeAll>
 800b0e8:	e6ed      	b.n	800aec6 <prvIdleTask+0x6>
				__asm volatile( "dsb" ::: "memory" );
 800b0ea:	f3bf 8f4f 	dsb	sy
				__asm volatile( "wfi" );
 800b0ee:	bf30      	wfi
				__asm volatile( "isb" );
 800b0f0:	f3bf 8f6f 	isb	sy
 800b0f4:	e7b8      	b.n	800b068 <prvIdleTask+0x1a8>
				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
 800b0f6:	683b      	ldr	r3, [r7, #0]
 800b0f8:	f8de c018 	ldr.w	ip, [lr, #24]
 800b0fc:	4358      	muls	r0, r3
 800b0fe:	eba0 020c 	sub.w	r2, r0, ip
				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
 800b102:	fbb2 f2f3 	udiv	r2, r2, r3
				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
 800b106:	fb02 3303 	mla	r3, r2, r3, r3
 800b10a:	ebac 0000 	sub.w	r0, ip, r0
 800b10e:	4403      	add	r3, r0
 800b110:	f8ce 3014 	str.w	r3, [lr, #20]
 800b114:	e7cc      	b.n	800b0b0 <prvIdleTask+0x1f0>
		xTickCount += xTicksToJump;
 800b116:	6808      	ldr	r0, [r1, #0]
 800b118:	4402      	add	r2, r0
 800b11a:	600a      	str	r2, [r1, #0]
 800b11c:	e7de      	b.n	800b0dc <prvIdleTask+0x21c>
 800b11e:	bf00      	nop
 800b120:	20001360 	.word	0x20001360
 800b124:	20001634 	.word	0x20001634
 800b128:	2000135c 	.word	0x2000135c
 800b12c:	200011b8 	.word	0x200011b8
 800b130:	2000134c 	.word	0x2000134c
 800b134:	20001358 	.word	0x20001358
 800b138:	2000130c 	.word	0x2000130c
 800b13c:	20001334 	.word	0x20001334
 800b140:	20001310 	.word	0x20001310
 800b144:	20001648 	.word	0x20001648
 800b148:	200012cc 	.word	0x200012cc
 800b14c:	0800c703 	.word	0x0800c703
 800b150:	0800cb80 	.word	0x0800cb80
 800b154:	20001354 	.word	0x20001354
 800b158:	20001355 	.word	0x20001355
 800b15c:	080076ad 	.word	0x080076ad
 800b160:	0800c712 	.word	0x0800c712
 800b164:	20000a44 	.word	0x20000a44
 800b168:	200015f8 	.word	0x200015f8
 800b16c:	200015f0 	.word	0x200015f0
 800b170:	20001350 	.word	0x20001350
 800b174:	20001348 	.word	0x20001348
 800b178:	20001600 	.word	0x20001600
 800b17c:	2000164c 	.word	0x2000164c
 800b180:	20001620 	.word	0x20001620

0800b184 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800b184:	4770      	bx	lr

0800b186 <__late_init>:
 800b186:	4770      	bx	lr

0800b188 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 800b188:	e7fe      	b.n	800b188 <__default_exit>
	...

0800b18c <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800b18c:	b570      	push	{r4, r5, r6, lr}
 800b18e:	2508      	movs	r5, #8
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800b190:	4c13      	ldr	r4, [pc, #76]	; (800b1e0 <__init_ram_areas+0x54>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800b192:	e9d4 0201 	ldrd	r0, r2, [r4, #4]
    uint32_t *p = rap->init_area;
 800b196:	4601      	mov	r1, r0
 800b198:	6823      	ldr	r3, [r4, #0]
 800b19a:	3b04      	subs	r3, #4
    while (p < rap->clear_area) {
 800b19c:	428a      	cmp	r2, r1
 800b19e:	d819      	bhi.n	800b1d4 <__init_ram_areas+0x48>
 800b1a0:	1cd3      	adds	r3, r2, #3
 800b1a2:	1a1b      	subs	r3, r3, r0
 800b1a4:	1ec1      	subs	r1, r0, #3
 800b1a6:	f023 0303 	bic.w	r3, r3, #3
 800b1aa:	428a      	cmp	r2, r1
 800b1ac:	bf38      	it	cc
 800b1ae:	2300      	movcc	r3, #0
 800b1b0:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800b1b2:	68e3      	ldr	r3, [r4, #12]
 800b1b4:	1ec1      	subs	r1, r0, #3
 800b1b6:	1cda      	adds	r2, r3, #3
 800b1b8:	1a12      	subs	r2, r2, r0
 800b1ba:	f022 0203 	bic.w	r2, r2, #3
 800b1be:	4299      	cmp	r1, r3
 800b1c0:	bf88      	it	hi
 800b1c2:	2200      	movhi	r2, #0
 800b1c4:	2100      	movs	r1, #0
 800b1c6:	f000 faf9 	bl	800b7bc <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b1ca:	3d01      	subs	r5, #1
    rap++;
 800b1cc:	f104 0410 	add.w	r4, r4, #16
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b1d0:	d1df      	bne.n	800b192 <__init_ram_areas+0x6>
#endif
}
 800b1d2:	bd70      	pop	{r4, r5, r6, pc}
      *p = *tp;
 800b1d4:	f853 6f04 	ldr.w	r6, [r3, #4]!
 800b1d8:	f841 6b04 	str.w	r6, [r1], #4
      tp++;
 800b1dc:	e7de      	b.n	800b19c <__init_ram_areas+0x10>
 800b1de:	bf00      	nop
 800b1e0:	0800caac 	.word	0x0800caac

0800b1e4 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800b1e4:	4b1c      	ldr	r3, [pc, #112]	; (800b258 <__early_init+0x74>)
 800b1e6:	681a      	ldr	r2, [r3, #0]
 800b1e8:	f042 0201 	orr.w	r2, r2, #1
 800b1ec:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800b1ee:	681a      	ldr	r2, [r3, #0]
 800b1f0:	0792      	lsls	r2, r2, #30
 800b1f2:	d5fc      	bpl.n	800b1ee <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800b1f4:	681a      	ldr	r2, [r3, #0]
 800b1f6:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800b1fa:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800b1fc:	2200      	movs	r2, #0
 800b1fe:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800b200:	685a      	ldr	r2, [r3, #4]
 800b202:	f012 0f0c 	tst.w	r2, #12
 800b206:	d1fb      	bne.n	800b200 <__early_init+0x1c>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 800b208:	681a      	ldr	r2, [r3, #0]
 800b20a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b20e:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 800b210:	681a      	ldr	r2, [r3, #0]
 800b212:	0390      	lsls	r0, r2, #14
 800b214:	d5fc      	bpl.n	800b210 <__early_init+0x2c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800b216:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b218:	f042 0201 	orr.w	r2, r2, #1
 800b21c:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800b21e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b220:	0791      	lsls	r1, r2, #30
 800b222:	d5fc      	bpl.n	800b21e <__early_init+0x3a>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800b224:	685a      	ldr	r2, [r3, #4]
 800b226:	f442 12f8 	orr.w	r2, r2, #2031616	; 0x1f0000
 800b22a:	605a      	str	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
 800b22c:	681a      	ldr	r2, [r3, #0]
 800b22e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b232:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800b234:	681a      	ldr	r2, [r3, #0]
 800b236:	0192      	lsls	r2, r2, #6
 800b238:	d5fc      	bpl.n	800b234 <__early_init+0x50>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800b23a:	2112      	movs	r1, #18
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800b23c:	4a07      	ldr	r2, [pc, #28]	; (800b25c <__early_init+0x78>)
 800b23e:	605a      	str	r2, [r3, #4]
  FLASH->ACR = STM32_FLASHBITS;
 800b240:	4a07      	ldr	r2, [pc, #28]	; (800b260 <__early_init+0x7c>)
 800b242:	6011      	str	r1, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800b244:	685a      	ldr	r2, [r3, #4]
 800b246:	f042 0202 	orr.w	r2, r2, #2
 800b24a:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800b24c:	685a      	ldr	r2, [r3, #4]
 800b24e:	f002 020c 	and.w	r2, r2, #12
 800b252:	2a08      	cmp	r2, #8
 800b254:	d1fa      	bne.n	800b24c <__early_init+0x68>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800b256:	4770      	bx	lr
 800b258:	40021000 	.word	0x40021000
 800b25c:	001f6400 	.word	0x001f6400
 800b260:	40022000 	.word	0x40022000

0800b264 <main>:
  rccResetAPB1(0xFFFFFFFF);
 800b264:	4bb5      	ldr	r3, [pc, #724]	; (800b53c <main+0x2d8>)
 800b266:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b26a:	691a      	ldr	r2, [r3, #16]
 800b26c:	2200      	movs	r2, #0
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b26e:	4614      	mov	r4, r2
/*
 * This main function starts FreeRTOS, we also create one thread that
 * will eventually run main_.
 */
int main(void)
{
 800b270:	b580      	push	{r7, lr}
 800b272:	6119      	str	r1, [r3, #16]
 800b274:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800b276:	68d8      	ldr	r0, [r3, #12]
 800b278:	60d9      	str	r1, [r3, #12]
 800b27a:	60da      	str	r2, [r3, #12]
  rccEnablePWRInterface(FALSE);
 800b27c:	69d9      	ldr	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 800b27e:	48b0      	ldr	r0, [pc, #704]	; (800b540 <main+0x2dc>)
  rccEnablePWRInterface(FALSE);
 800b280:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800b284:	61d9      	str	r1, [r3, #28]
  rccEnableBKPInterface(FALSE);
 800b286:	69d9      	ldr	r1, [r3, #28]
 800b288:	b08a      	sub	sp, #40	; 0x28
 800b28a:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 800b28e:	61d9      	str	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 800b290:	6801      	ldr	r1, [r0, #0]
 800b292:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800b296:	6001      	str	r1, [r0, #0]
  dma_streams_mask = 0U;
 800b298:	49aa      	ldr	r1, [pc, #680]	; (800b544 <main+0x2e0>)
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800b29a:	48ab      	ldr	r0, [pc, #684]	; (800b548 <main+0x2e4>)
  dma_streams_mask = 0U;
 800b29c:	600a      	str	r2, [r1, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b29e:	49ab      	ldr	r1, [pc, #684]	; (800b54c <main+0x2e8>)
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b2a0:	684d      	ldr	r5, [r1, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b2a2:	3114      	adds	r1, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b2a4:	602c      	str	r4, [r5, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800b2a6:	f840 4032 	str.w	r4, [r0, r2, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b2aa:	3201      	adds	r2, #1
 800b2ac:	2a07      	cmp	r2, #7
 800b2ae:	d1f7      	bne.n	800b2a0 <main+0x3c>
  DMA1->IFCR = 0xFFFFFFFFU;
 800b2b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b2b4:	49a6      	ldr	r1, [pc, #664]	; (800b550 <main+0x2ec>)
  i2cp->state  = I2C_STOP;
 800b2b6:	2601      	movs	r6, #1
 800b2b8:	604a      	str	r2, [r1, #4]
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800b2ba:	6999      	ldr	r1, [r3, #24]
 800b2bc:	4da5      	ldr	r5, [pc, #660]	; (800b554 <main+0x2f0>)
 800b2be:	f041 017d 	orr.w	r1, r1, #125	; 0x7d
 800b2c2:	6199      	str	r1, [r3, #24]
  GPIOA->ODR = config->PAData.odr;
 800b2c4:	f46f 1340 	mvn.w	r3, #3145728	; 0x300000
 800b2c8:	49a3      	ldr	r1, [pc, #652]	; (800b558 <main+0x2f4>)
 800b2ca:	60cb      	str	r3, [r1, #12]
  GPIOA->CRH = config->PAData.crh;
 800b2cc:	4ba3      	ldr	r3, [pc, #652]	; (800b55c <main+0x2f8>)
 800b2ce:	604b      	str	r3, [r1, #4]
  GPIOA->CRL = config->PAData.crl;
 800b2d0:	f04f 3388 	mov.w	r3, #2290649224	; 0x88888888
 800b2d4:	600b      	str	r3, [r1, #0]
  GPIOB->ODR = config->PBData.odr;
 800b2d6:	f8c1 240c 	str.w	r2, [r1, #1036]	; 0x40c
  GPIOB->CRH = config->PBData.crh;
 800b2da:	f8c1 3404 	str.w	r3, [r1, #1028]	; 0x404
  GPIOB->CRL = config->PBData.crl;
 800b2de:	f8c1 3400 	str.w	r3, [r1, #1024]	; 0x400
  GPIOC->ODR = config->PCData.odr;
 800b2e2:	f8c1 280c 	str.w	r2, [r1, #2060]	; 0x80c
  GPIOC->CRH = config->PCData.crh;
 800b2e6:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
  GPIOC->CRL = config->PCData.crl;
 800b2ea:	f8c1 3800 	str.w	r3, [r1, #2048]	; 0x800
  GPIOD->ODR = config->PDData.odr;
 800b2ee:	f8c1 2c0c 	str.w	r2, [r1, #3084]	; 0xc0c
  GPIOD->CRH = config->PDData.crh;
 800b2f2:	f8c1 3c04 	str.w	r3, [r1, #3076]	; 0xc04
  GPIOD->CRL = config->PDData.crl;
 800b2f6:	f8c1 3c00 	str.w	r3, [r1, #3072]	; 0xc00
  GPIOB->ODR = config->PBData.odr;
 800b2fa:	f501 6180 	add.w	r1, r1, #1024	; 0x400
  GPIOE->ODR = config->PEData.odr;
 800b2fe:	f8c1 2c0c 	str.w	r2, [r1, #3084]	; 0xc0c
  GPIOE->CRH = config->PEData.crh;
 800b302:	f8c1 3c04 	str.w	r3, [r1, #3076]	; 0xc04
  GPIOE->CRL = config->PEData.crl;
 800b306:	f8c1 3c00 	str.w	r3, [r1, #3072]	; 0xc00
			volatile size_t xSize = sizeof( StaticQueue_t );
 800b30a:	2350      	movs	r3, #80	; 0x50
 800b30c:	9306      	str	r3, [sp, #24]
			configASSERT( xSize == sizeof( Queue_t ) );
 800b30e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800b312:	702e      	strb	r6, [r5, #0]
 800b314:	4598      	cmp	r8, r3
  i2cp->config = NULL;
 800b316:	606c      	str	r4, [r5, #4]
 800b318:	d000      	beq.n	800b31c <main+0xb8>
 800b31a:	e7fe      	b.n	800b31a <main+0xb6>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b31c:	f105 0710 	add.w	r7, r5, #16
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b320:	4638      	mov	r0, r7
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b322:	612f      	str	r7, [r5, #16]
	pxNewQueue->uxItemSize = uxItemSize;
 800b324:	e9c5 6413 	strd	r6, r4, [r5, #76]	; 0x4c
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800b328:	f885 6056 	strb.w	r6, [r5, #86]	; 0x56
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b32c:	f7fd f9ab 	bl	8008686 <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800b330:	f885 605c 	strb.w	r6, [r5, #92]	; 0x5c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800b334:	f7fd f9a1 	bl	800867a <prvInitialiseMutex.part.0>
  oqp->q_counter = size;
 800b338:	2110      	movs	r1, #16
    mutex->handle = xSemaphoreCreateMutexStatic(&mutex->staticData);
 800b33a:	60ef      	str	r7, [r5, #12]
  I2CD1.i2c    = I2C1;
 800b33c:	4b88      	ldr	r3, [pc, #544]	; (800b560 <main+0x2fc>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800b33e:	4f89      	ldr	r7, [pc, #548]	; (800b564 <main+0x300>)
  I2CD1.i2c    = I2C1;
 800b340:	67ab      	str	r3, [r5, #120]	; 0x78
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800b342:	f1a7 0314 	sub.w	r3, r7, #20
 800b346:	676b      	str	r3, [r5, #116]	; 0x74
  sdp->vmt = &vmt;
 800b348:	4a87      	ldr	r2, [pc, #540]	; (800b568 <main+0x304>)
 800b34a:	4b88      	ldr	r3, [pc, #544]	; (800b56c <main+0x308>)
  I2CD1.thread = NULL;
 800b34c:	662c      	str	r4, [r5, #96]	; 0x60
 800b34e:	601a      	str	r2, [r3, #0]
  iqp->q_buffer  = bp;
 800b350:	f103 0260 	add.w	r2, r3, #96	; 0x60
  iqp->q_wrptr   = bp;
 800b354:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  iqp->q_buffer  = bp;
 800b358:	625a      	str	r2, [r3, #36]	; 0x24
  iqp->q_top     = bp + size;
 800b35a:	f103 0270 	add.w	r2, r3, #112	; 0x70
  oqp->q_wrptr   = bp;
 800b35e:	e9c3 2214 	strd	r2, r2, [r3, #80]	; 0x50
  iqp->q_top     = bp + size;
 800b362:	629a      	str	r2, [r3, #40]	; 0x28
  oqp->q_buffer  = bp;
 800b364:	649a      	str	r2, [r3, #72]	; 0x48
  oqp->q_top     = bp + size;
 800b366:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800b36a:	64da      	str	r2, [r3, #76]	; 0x4c
  oqp->q_notify  = onfy;
 800b36c:	4a80      	ldr	r2, [pc, #512]	; (800b570 <main+0x30c>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800b36e:	672f      	str	r7, [r5, #112]	; 0x70
  oqp->q_link    = link;
 800b370:	e9c3 2316 	strd	r2, r3, [r3, #88]	; 0x58
  spip->state = SPI_STOP;
 800b374:	4d7f      	ldr	r5, [pc, #508]	; (800b574 <main+0x310>)
  SD3.usart = USART3;
 800b376:	4a80      	ldr	r2, [pc, #512]	; (800b578 <main+0x314>)
  iqp->q_counter = 0;
 800b378:	621c      	str	r4, [r3, #32]
    event_source->firstRepeater = NULL;
 800b37a:	e9c3 4401 	strd	r4, r4, [r3, #4]
    thread_queue->tail = NULL;
 800b37e:	e9c3 4406 	strd	r4, r4, [r3, #24]
  iqp->q_link    = link;
 800b382:	e9c3 430d 	strd	r4, r3, [r3, #52]	; 0x34
 800b386:	e9c3 440f 	strd	r4, r4, [r3, #60]	; 0x3c
    event_source->waitThread = NULL;
 800b38a:	60dc      	str	r4, [r3, #12]
  sdp->state = SD_STOP;
 800b38c:	751e      	strb	r6, [r3, #20]
  oqp->q_counter = size;
 800b38e:	6459      	str	r1, [r3, #68]	; 0x44
 800b390:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  spip->thread = NULL;
 800b394:	e9c5 4401 	strd	r4, r4, [r5, #4]
  spip->state = SPI_STOP;
 800b398:	702e      	strb	r6, [r5, #0]
			volatile size_t xSize = sizeof( StaticQueue_t );
 800b39a:	f8cd 801c 	str.w	r8, [sp, #28]
			configASSERT( xSize == sizeof( Queue_t ) );
 800b39e:	9b07      	ldr	r3, [sp, #28]
 800b3a0:	2b50      	cmp	r3, #80	; 0x50
 800b3a2:	d000      	beq.n	800b3a6 <main+0x142>
 800b3a4:	e7fe      	b.n	800b3a4 <main+0x140>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b3a6:	f105 0810 	add.w	r8, r5, #16
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b3aa:	4640      	mov	r0, r8
	pxNewQueue->uxItemSize = uxItemSize;
 800b3ac:	e9c5 6413 	strd	r6, r4, [r5, #76]	; 0x4c
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800b3b0:	f885 6056 	strb.w	r6, [r5, #86]	; 0x56
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b3b4:	f8c5 8010 	str.w	r8, [r5, #16]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b3b8:	f7fd f965 	bl	8008686 <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800b3bc:	f885 605c 	strb.w	r6, [r5, #92]	; 0x5c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800b3c0:	f7fd f95b 	bl	800867a <prvInitialiseMutex.part.0>
  SPID1.spi       = SPI1;
 800b3c4:	4b6d      	ldr	r3, [pc, #436]	; (800b57c <main+0x318>)
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b3c6:	f241 000a 	movw	r0, #4106	; 0x100a
  SPID1.spi       = SPI1;
 800b3ca:	662b      	str	r3, [r5, #96]	; 0x60
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 800b3cc:	f1a7 0364 	sub.w	r3, r7, #100	; 0x64
 800b3d0:	666b      	str	r3, [r5, #100]	; 0x64
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b3d2:	f241 0318 	movw	r3, #4120	; 0x1018
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800b3d6:	3f50      	subs	r7, #80	; 0x50
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b3d8:	e9c5 031b 	strd	r0, r3, [r5, #108]	; 0x6c
    mutex->handle = xSemaphoreCreateMutexStatic(&mutex->staticData);
 800b3dc:	f8c5 800c 	str.w	r8, [r5, #12]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800b3e0:	66af      	str	r7, [r5, #104]	; 0x68
  usbp->state        = USB_STOP;
 800b3e2:	4d67      	ldr	r5, [pc, #412]	; (800b580 <main+0x31c>)
    usbp->in_params[i]  = NULL;
 800b3e4:	2238      	movs	r2, #56	; 0x38
  usbp->state        = USB_STOP;
 800b3e6:	4628      	mov	r0, r5
    usbp->in_params[i]  = NULL;
 800b3e8:	2100      	movs	r1, #0
  usbp->state        = USB_STOP;
 800b3ea:	f800 6b2c 	strb.w	r6, [r0], #44
    usbp->in_params[i]  = NULL;
 800b3ee:	f000 f9e5 	bl	800b7bc <memset>
/*
 * Board-specific initialization code.
 */
void boardInit(void) {
    /* Use SWD only */
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE;
 800b3f2:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  WDGD1.state = WDG_STOP;
 800b3f6:	4863      	ldr	r0, [pc, #396]	; (800b584 <main+0x320>)
  WDGD1.wdg   = IWDG;
 800b3f8:	4b63      	ldr	r3, [pc, #396]	; (800b588 <main+0x324>)
  usbp->transmitting = 0;
 800b3fa:	e9c5 4401 	strd	r4, r4, [r5, #4]
 800b3fe:	6083      	str	r3, [r0, #8]
 800b400:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
  WDGD1.state = WDG_STOP;
 800b404:	7006      	strb	r6, [r0, #0]
 800b406:	605a      	str	r2, [r3, #4]
  osalSysLock();
 800b408:	f7f9 facc 	bl	80049a4 <vPortEnterCritical>
  osalDbgAssert((wdgp->state == WDG_STOP) || (wdgp->state == WDG_READY),
 800b40c:	7803      	ldrb	r3, [r0, #0]
 800b40e:	3b01      	subs	r3, #1
 800b410:	2b01      	cmp	r3, #1
 800b412:	d902      	bls.n	800b41a <main+0x1b6>
 800b414:	f7f9 fad6 	bl	80049c4 <vTaskEndScheduler>
 800b418:	e7fe      	b.n	800b418 <main+0x1b4>
  wdgp->wdg->KR   = KR_KEY_WRITE;
 800b41a:	f245 5255 	movw	r2, #21845	; 0x5555
  wdgp->config = config;
 800b41e:	4b5b      	ldr	r3, [pc, #364]	; (800b58c <main+0x328>)
 800b420:	6043      	str	r3, [r0, #4]
 800b422:	6883      	ldr	r3, [r0, #8]
 800b424:	601a      	str	r2, [r3, #0]
  while (wdgp->wdg->SR != 0)
 800b426:	68dc      	ldr	r4, [r3, #12]
 800b428:	2c00      	cmp	r4, #0
 800b42a:	d1fc      	bne.n	800b426 <main+0x1c2>
  wdgp->wdg->PR   = wdgp->config->pr;
 800b42c:	2206      	movs	r2, #6
 800b42e:	605a      	str	r2, [r3, #4]
  wdgp->wdg->RLR  = wdgp->config->rlr;
 800b430:	f640 72ff 	movw	r2, #4095	; 0xfff
 800b434:	609a      	str	r2, [r3, #8]
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 800b436:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800b43a:	601a      	str	r2, [r3, #0]
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 800b43c:	f64c 42cc 	movw	r2, #52428	; 0xcccc
  wdgp->state = WDG_READY;
 800b440:	2702      	movs	r7, #2

    /* Before anything else, start watchdog (~25 seconds timeout) */
    wdgStart(&WDGD1, &watchdogConfig);

    TaskHandle_t handle;
    xTaskCreate(runInThreadBody, "Init", 256, main_, 1, &handle);
 800b442:	2601      	movs	r6, #1
 800b444:	601a      	str	r2, [r3, #0]
 800b446:	7007      	strb	r7, [r0, #0]
  osalSysUnlock();
 800b448:	f7f9 fcd0 	bl	8004dec <osalSysUnlock.lto_priv.0>
 800b44c:	ab05      	add	r3, sp, #20
 800b44e:	9301      	str	r3, [sp, #4]
 800b450:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b454:	4b4e      	ldr	r3, [pc, #312]	; (800b590 <main+0x32c>)
 800b456:	494f      	ldr	r1, [pc, #316]	; (800b594 <main+0x330>)
 800b458:	484f      	ldr	r0, [pc, #316]	; (800b598 <main+0x334>)
 800b45a:	9600      	str	r6, [sp, #0]
 800b45c:	f7fc fc06 	bl	8007c6c <xTaskCreate.isra.0>
			volatile size_t xSize = sizeof( StaticTask_t );
 800b460:	2368      	movs	r3, #104	; 0x68
 800b462:	9308      	str	r3, [sp, #32]
			configASSERT( xSize == sizeof( TCB_t ) );
 800b464:	9b08      	ldr	r3, [sp, #32]
 800b466:	2b68      	cmp	r3, #104	; 0x68
 800b468:	d000      	beq.n	800b46c <main+0x208>
 800b46a:	e7fe      	b.n	800b46a <main+0x206>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b46c:	4d4b      	ldr	r5, [pc, #300]	; (800b59c <main+0x338>)
 800b46e:	4b4c      	ldr	r3, [pc, #304]	; (800b5a0 <main+0x33c>)
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b470:	f885 7065 	strb.w	r7, [r5, #101]	; 0x65
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b474:	632b      	str	r3, [r5, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800b476:	ab09      	add	r3, sp, #36	; 0x24
 800b478:	2278      	movs	r2, #120	; 0x78
 800b47a:	e9cd 4300 	strd	r4, r3, [sp]
 800b47e:	4949      	ldr	r1, [pc, #292]	; (800b5a4 <main+0x340>)
 800b480:	4623      	mov	r3, r4
 800b482:	4849      	ldr	r0, [pc, #292]	; (800b5a8 <main+0x344>)
 800b484:	9502      	str	r5, [sp, #8]
 800b486:	f7fc fba3 	bl	8007bd0 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800b48a:	4628      	mov	r0, r5
 800b48c:	f7f9 fd8a 	bl	8004fa4 <prvAddNewTaskToReadyList>
		return xReturn;
 800b490:	9b09      	ldr	r3, [sp, #36]	; 0x24
		if( xIdleTaskHandle != NULL )
 800b492:	2b00      	cmp	r3, #0
 800b494:	f000 80a7 	beq.w	800b5e6 <main+0x382>
		portDISABLE_INTERRUPTS();
 800b498:	f7f9 fa84 	bl	80049a4 <vPortEnterCritical>
		xNextTaskUnblockTime = portMAX_DELAY;
 800b49c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b4a0:	4b42      	ldr	r3, [pc, #264]	; (800b5ac <main+0x348>)
 800b4a2:	6019      	str	r1, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800b4a4:	4b42      	ldr	r3, [pc, #264]	; (800b5b0 <main+0x34c>)
 800b4a6:	601e      	str	r6, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 800b4a8:	4b42      	ldr	r3, [pc, #264]	; (800b5b4 <main+0x350>)
 800b4aa:	601c      	str	r4, [r3, #0]
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800b4ac:	4b42      	ldr	r3, [pc, #264]	; (800b5b8 <main+0x354>)
 800b4ae:	781a      	ldrb	r2, [r3, #0]
 800b4b0:	b2d2      	uxtb	r2, r2
 800b4b2:	9209      	str	r2, [sp, #36]	; 0x24
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800b4b4:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800b4b6:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800b4b8:	4a40      	ldr	r2, [pc, #256]	; (800b5bc <main+0x358>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800b4ba:	b2db      	uxtb	r3, r3
 800b4bc:	f88d 3013 	strb.w	r3, [sp, #19]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800b4c0:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800b4c4:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
 800b4c8:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800b4ca:	2307      	movs	r3, #7
 800b4cc:	4a3c      	ldr	r2, [pc, #240]	; (800b5c0 <main+0x35c>)
 800b4ce:	6013      	str	r3, [r2, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800b4d0:	f89d 1013 	ldrb.w	r1, [sp, #19]
 800b4d4:	1e58      	subs	r0, r3, #1
 800b4d6:	0609      	lsls	r1, r1, #24
 800b4d8:	d47c      	bmi.n	800b5d4 <main+0x370>
 800b4da:	b104      	cbz	r4, 800b4de <main+0x27a>
 800b4dc:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800b4de:	6813      	ldr	r3, [r2, #0]
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 800b4e0:	f242 3128 	movw	r1, #9000	; 0x2328
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800b4e4:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800b4e6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b4ea:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800b4ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b4ee:	4a32      	ldr	r2, [pc, #200]	; (800b5b8 <main+0x354>)
 800b4f0:	b2db      	uxtb	r3, r3
 800b4f2:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800b4f4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b4f8:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b4fc:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 800b500:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800b504:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b508:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 800b50c:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 800b510:	4a2c      	ldr	r2, [pc, #176]	; (800b5c4 <main+0x360>)
 800b512:	6011      	str	r1, [r2, #0]
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 800b514:	f44f 61e9 	mov.w	r1, #1864	; 0x748
 800b518:	4a2b      	ldr	r2, [pc, #172]	; (800b5c8 <main+0x364>)
 800b51a:	6011      	str	r1, [r2, #0]
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 800b51c:	2105      	movs	r1, #5
 800b51e:	4a2b      	ldr	r2, [pc, #172]	; (800b5cc <main+0x368>)
 800b520:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800b522:	f242 3227 	movw	r2, #8999	; 0x2327
 800b526:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800b528:	2203      	movs	r2, #3
 800b52a:	611a      	str	r2, [r3, #16]
	uxCriticalNesting = 0;
 800b52c:	2200      	movs	r2, #0
 800b52e:	4b28      	ldr	r3, [pc, #160]	; (800b5d0 <main+0x36c>)
 800b530:	601a      	str	r2, [r3, #0]
	prvPortStartFirstTask();
 800b532:	f7f9 fa27 	bl	8004984 <prvPortStartFirstTask>
	prvTaskExitError();
 800b536:	f7f9 fc41 	bl	8004dbc <prvTaskExitError>
 800b53a:	bf00      	nop
 800b53c:	40021000 	.word	0x40021000
 800b540:	40007000 	.word	0x40007000
 800b544:	20001044 	.word	0x20001044
 800b548:	20000fe8 	.word	0x20000fe8
 800b54c:	0800c818 	.word	0x0800c818
 800b550:	40020000 	.word	0x40020000
 800b554:	20000934 	.word	0x20000934
 800b558:	40010800 	.word	0x40010800
 800b55c:	88888288 	.word	0x88888288
 800b560:	40005400 	.word	0x40005400
 800b564:	0800c890 	.word	0x0800c890
 800b568:	0800ccc0 	.word	0x0800ccc0
 800b56c:	200009bc 	.word	0x200009bc
 800b570:	08004151 	.word	0x08004151
 800b574:	20000ee0 	.word	0x20000ee0
 800b578:	40004800 	.word	0x40004800
 800b57c:	40013000 	.word	0x40013000
 800b580:	20000f54 	.word	0x20000f54
 800b584:	20000fdc 	.word	0x20000fdc
 800b588:	40003000 	.word	0x40003000
 800b58c:	0800cd10 	.word	0x0800cd10
 800b590:	0800a5a5 	.word	0x0800a5a5
 800b594:	0800c71b 	.word	0x0800c71b
 800b598:	0800616d 	.word	0x0800616d
 800b59c:	20001588 	.word	0x20001588
 800b5a0:	200013a8 	.word	0x200013a8
 800b5a4:	0800c337 	.word	0x0800c337
 800b5a8:	0800aec1 	.word	0x0800aec1
 800b5ac:	200015f8 	.word	0x200015f8
 800b5b0:	20001614 	.word	0x20001614
 800b5b4:	20001648 	.word	0x20001648
 800b5b8:	e000e400 	.word	0xe000e400
 800b5bc:	20001340 	.word	0x20001340
 800b5c0:	20001344 	.word	0x20001344
 800b5c4:	20001350 	.word	0x20001350
 800b5c8:	200015f0 	.word	0x200015f0
 800b5cc:	20001348 	.word	0x20001348
 800b5d0:	20001358 	.word	0x20001358
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800b5d4:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800b5d8:	2401      	movs	r4, #1
 800b5da:	005b      	lsls	r3, r3, #1
 800b5dc:	b2db      	uxtb	r3, r3
 800b5de:	f88d 3013 	strb.w	r3, [sp, #19]
 800b5e2:	4603      	mov	r3, r0
 800b5e4:	e774      	b.n	800b4d0 <main+0x26c>

    osalSysEnable();

    /* Does not happen */
    osalSysHalt("Return in main?");
 800b5e6:	f7f9 f9ed 	bl	80049c4 <vTaskEndScheduler>
 800b5ea:	e7fe      	b.n	800b5ea <main+0x386>

0800b5ec <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800b5ec:	4b1e      	ldr	r3, [pc, #120]	; (800b668 <vTaskSwitchContext+0x7c>)
{
 800b5ee:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800b5f0:	681a      	ldr	r2, [r3, #0]
 800b5f2:	4b1e      	ldr	r3, [pc, #120]	; (800b66c <vTaskSwitchContext+0x80>)
 800b5f4:	b112      	cbz	r2, 800b5fc <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800b5f6:	2201      	movs	r2, #1
 800b5f8:	601a      	str	r2, [r3, #0]
}
 800b5fa:	bd30      	pop	{r4, r5, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 800b5fc:	481c      	ldr	r0, [pc, #112]	; (800b670 <vTaskSwitchContext+0x84>)
		xYieldPending = pdFALSE;
 800b5fe:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 800b600:	6803      	ldr	r3, [r0, #0]
 800b602:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b604:	681a      	ldr	r2, [r3, #0]
 800b606:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b60a:	d10b      	bne.n	800b624 <vTaskSwitchContext+0x38>
 800b60c:	685a      	ldr	r2, [r3, #4]
 800b60e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b612:	d107      	bne.n	800b624 <vTaskSwitchContext+0x38>
 800b614:	689a      	ldr	r2, [r3, #8]
 800b616:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b61a:	d103      	bne.n	800b624 <vTaskSwitchContext+0x38>
 800b61c:	68db      	ldr	r3, [r3, #12]
 800b61e:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 800b622:	d002      	beq.n	800b62a <vTaskSwitchContext+0x3e>
 800b624:	6803      	ldr	r3, [r0, #0]
 800b626:	6803      	ldr	r3, [r0, #0]
 800b628:	e7fe      	b.n	800b628 <vTaskSwitchContext+0x3c>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800b62a:	4b12      	ldr	r3, [pc, #72]	; (800b674 <vTaskSwitchContext+0x88>)
 800b62c:	681a      	ldr	r2, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 800b62e:	fab2 f282 	clz	r2, r2
 800b632:	2314      	movs	r3, #20
 800b634:	b2d2      	uxtb	r2, r2
 800b636:	f1c2 021f 	rsb	r2, r2, #31
 800b63a:	4353      	muls	r3, r2
 800b63c:	490e      	ldr	r1, [pc, #56]	; (800b678 <vTaskSwitchContext+0x8c>)
 800b63e:	58cd      	ldr	r5, [r1, r3]
 800b640:	18cc      	adds	r4, r1, r3
 800b642:	b905      	cbnz	r5, 800b646 <vTaskSwitchContext+0x5a>
 800b644:	e7fe      	b.n	800b644 <vTaskSwitchContext+0x58>
 800b646:	6865      	ldr	r5, [r4, #4]
 800b648:	3308      	adds	r3, #8
 800b64a:	686d      	ldr	r5, [r5, #4]
 800b64c:	440b      	add	r3, r1
 800b64e:	429d      	cmp	r5, r3
 800b650:	bf08      	it	eq
 800b652:	686b      	ldreq	r3, [r5, #4]
 800b654:	6065      	str	r5, [r4, #4]
 800b656:	bf08      	it	eq
 800b658:	6063      	streq	r3, [r4, #4]
 800b65a:	2314      	movs	r3, #20
 800b65c:	fb03 1202 	mla	r2, r3, r2, r1
 800b660:	6853      	ldr	r3, [r2, #4]
 800b662:	68db      	ldr	r3, [r3, #12]
 800b664:	6003      	str	r3, [r0, #0]
}
 800b666:	e7c8      	b.n	800b5fa <vTaskSwitchContext+0xe>
 800b668:	2000136c 	.word	0x2000136c
 800b66c:	2000164c 	.word	0x2000164c
 800b670:	200011a8 	.word	0x200011a8
 800b674:	20001374 	.word	0x20001374
 800b678:	200011b8 	.word	0x200011b8

0800b67c <mixLedTask>:
{
 800b67c:	4605      	mov	r5, r0
 800b67e:	b580      	push	{r7, lr}
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800b680:	4e45      	ldr	r6, [pc, #276]	; (800b798 <mixLedTask+0x11c>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 800b682:	4f46      	ldr	r7, [pc, #280]	; (800b79c <mixLedTask+0x120>)
        gpioSetPin(GPIO_LED_MIX, true);
 800b684:	2101      	movs	r1, #1
 800b686:	f240 1005 	movw	r0, #261	; 0x105
 800b68a:	f7fb ff6f 	bl	800756c <gpioSetPin.isra.0>
        if(!*delay) {
 800b68e:	682b      	ldr	r3, [r5, #0]
 800b690:	2b00      	cmp	r3, #0
 800b692:	d165      	bne.n	800b760 <mixLedTask+0xe4>
		taskENTER_CRITICAL();
 800b694:	f7f9 f986 	bl	80049a4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800b698:	6834      	ldr	r4, [r6, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b69a:	f104 0804 	add.w	r8, r4, #4
 800b69e:	4640      	mov	r0, r8
 800b6a0:	f7f9 f803 	bl	80046aa <uxListRemove>
 800b6a4:	b978      	cbnz	r0, 800b6c6 <mixLedTask+0x4a>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800b6a6:	2014      	movs	r0, #20
 800b6a8:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
 800b6ac:	4b3c      	ldr	r3, [pc, #240]	; (800b7a0 <mixLedTask+0x124>)
 800b6ae:	fb00 f00c 	mul.w	r0, r0, ip
 800b6b2:	581b      	ldr	r3, [r3, r0]
 800b6b4:	b93b      	cbnz	r3, 800b6c6 <mixLedTask+0x4a>
 800b6b6:	2201      	movs	r2, #1
 800b6b8:	493a      	ldr	r1, [pc, #232]	; (800b7a4 <mixLedTask+0x128>)
 800b6ba:	fa02 f20c 	lsl.w	r2, r2, ip
 800b6be:	680b      	ldr	r3, [r1, #0]
 800b6c0:	ea23 0302 	bic.w	r3, r3, r2
 800b6c4:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800b6c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b6c8:	b11b      	cbz	r3, 800b6d2 <mixLedTask+0x56>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b6ca:	f104 0018 	add.w	r0, r4, #24
 800b6ce:	f7f8 ffec 	bl	80046aa <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 800b6d2:	4638      	mov	r0, r7
 800b6d4:	4641      	mov	r1, r8
 800b6d6:	f7f8 ffc5 	bl	8004664 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 800b6da:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		if( xSchedulerRunning != pdFALSE )
 800b6de:	4832      	ldr	r0, [pc, #200]	; (800b7a8 <mixLedTask+0x12c>)
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 800b6e0:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800b6e2:	bf04      	itt	eq
 800b6e4:	2300      	moveq	r3, #0
 800b6e6:	f884 3064 	strbeq.w	r3, [r4, #100]	; 0x64
		taskEXIT_CRITICAL();
 800b6ea:	f7f9 fb73 	bl	8004dd4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800b6ee:	6803      	ldr	r3, [r0, #0]
 800b6f0:	b12b      	cbz	r3, 800b6fe <mixLedTask+0x82>
			taskENTER_CRITICAL();
 800b6f2:	f7f9 f957 	bl	80049a4 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 800b6f6:	f7f9 f80f 	bl	8004718 <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 800b6fa:	f7f9 fb6b 	bl	8004dd4 <vPortExitCritical>
		if( pxTCB == pxCurrentTCB )
 800b6fe:	6833      	ldr	r3, [r6, #0]
 800b700:	429c      	cmp	r4, r3
 800b702:	d1bf      	bne.n	800b684 <mixLedTask+0x8>
			if( xSchedulerRunning != pdFALSE )
 800b704:	6803      	ldr	r3, [r0, #0]
 800b706:	b30b      	cbz	r3, 800b74c <mixLedTask+0xd0>
				configASSERT( uxSchedulerSuspended == 0 );
 800b708:	4b28      	ldr	r3, [pc, #160]	; (800b7ac <mixLedTask+0x130>)
 800b70a:	681b      	ldr	r3, [r3, #0]
 800b70c:	b103      	cbz	r3, 800b710 <mixLedTask+0x94>
 800b70e:	e7fe      	b.n	800b70e <mixLedTask+0x92>
				portYIELD_WITHIN_API();
 800b710:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b714:	4a26      	ldr	r2, [pc, #152]	; (800b7b0 <mixLedTask+0x134>)
 800b716:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800b71a:	6011      	str	r1, [r2, #0]
 800b71c:	4a25      	ldr	r2, [pc, #148]	; (800b7b4 <mixLedTask+0x138>)
 800b71e:	6812      	ldr	r2, [r2, #0]
 800b720:	b14a      	cbz	r2, 800b736 <mixLedTask+0xba>
 800b722:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b726:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800b72a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800b72e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b732:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800b736:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b73a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b73e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800b742:	f3bf 8f4f 	dsb	sy
 800b746:	f3bf 8f6f 	isb	sy
 800b74a:	e79b      	b.n	800b684 <mixLedTask+0x8>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800b74c:	4a1a      	ldr	r2, [pc, #104]	; (800b7b8 <mixLedTask+0x13c>)
 800b74e:	6839      	ldr	r1, [r7, #0]
 800b750:	6812      	ldr	r2, [r2, #0]
 800b752:	4291      	cmp	r1, r2
 800b754:	d101      	bne.n	800b75a <mixLedTask+0xde>
					pxCurrentTCB = NULL;
 800b756:	6033      	str	r3, [r6, #0]
 800b758:	e794      	b.n	800b684 <mixLedTask+0x8>
					vTaskSwitchContext();
 800b75a:	f7ff ff47 	bl	800b5ec <vTaskSwitchContext>
 800b75e:	e791      	b.n	800b684 <mixLedTask+0x8>
        osalThreadSleepMilliseconds(*delay);
 800b760:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800b764:	6828      	ldr	r0, [r5, #0]
 800b766:	4360      	muls	r0, r4
 800b768:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 800b76c:	fbb0 f0f4 	udiv	r0, r0, r4
 800b770:	f7f9 fe0a 	bl	8005388 <vTaskDelay>
        gpioSetPin(GPIO_LED_MIX, false);
 800b774:	2100      	movs	r1, #0
 800b776:	f240 1005 	movw	r0, #261	; 0x105
 800b77a:	f7fb fef7 	bl	800756c <gpioSetPin.isra.0>
        if(*delay) {
 800b77e:	682b      	ldr	r3, [r5, #0]
 800b780:	2b00      	cmp	r3, #0
 800b782:	f43f af7f 	beq.w	800b684 <mixLedTask+0x8>
            osalThreadSleepMilliseconds(*delay);
 800b786:	6828      	ldr	r0, [r5, #0]
 800b788:	4360      	muls	r0, r4
 800b78a:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 800b78e:	fbb0 f0f4 	udiv	r0, r0, r4
 800b792:	f7f9 fdf9 	bl	8005388 <vTaskDelay>
 800b796:	e775      	b.n	800b684 <mixLedTask+0x8>
 800b798:	200011a8 	.word	0x200011a8
 800b79c:	20001620 	.word	0x20001620
 800b7a0:	200011b8 	.word	0x200011b8
 800b7a4:	20001374 	.word	0x20001374
 800b7a8:	20001614 	.word	0x20001614
 800b7ac:	2000136c 	.word	0x2000136c
 800b7b0:	2000134c 	.word	0x2000134c
 800b7b4:	20001358 	.word	0x20001358
 800b7b8:	2000135c 	.word	0x2000135c

0800b7bc <memset>:
 800b7bc:	0783      	lsls	r3, r0, #30
 800b7be:	b530      	push	{r4, r5, lr}
 800b7c0:	d048      	beq.n	800b854 <memset+0x98>
 800b7c2:	1e54      	subs	r4, r2, #1
 800b7c4:	2a00      	cmp	r2, #0
 800b7c6:	d03f      	beq.n	800b848 <memset+0x8c>
 800b7c8:	4603      	mov	r3, r0
 800b7ca:	b2ca      	uxtb	r2, r1
 800b7cc:	e001      	b.n	800b7d2 <memset+0x16>
 800b7ce:	3c01      	subs	r4, #1
 800b7d0:	d33a      	bcc.n	800b848 <memset+0x8c>
 800b7d2:	f803 2b01 	strb.w	r2, [r3], #1
 800b7d6:	079d      	lsls	r5, r3, #30
 800b7d8:	d1f9      	bne.n	800b7ce <memset+0x12>
 800b7da:	2c03      	cmp	r4, #3
 800b7dc:	d92d      	bls.n	800b83a <memset+0x7e>
 800b7de:	b2cd      	uxtb	r5, r1
 800b7e0:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800b7e4:	2c0f      	cmp	r4, #15
 800b7e6:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800b7ea:	d936      	bls.n	800b85a <memset+0x9e>
 800b7ec:	f1a4 0210 	sub.w	r2, r4, #16
 800b7f0:	f022 0c0f 	bic.w	ip, r2, #15
 800b7f4:	f103 0e20 	add.w	lr, r3, #32
 800b7f8:	44e6      	add	lr, ip
 800b7fa:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 800b7fe:	f103 0210 	add.w	r2, r3, #16
 800b802:	e942 5504 	strd	r5, r5, [r2, #-16]
 800b806:	e942 5502 	strd	r5, r5, [r2, #-8]
 800b80a:	3210      	adds	r2, #16
 800b80c:	4572      	cmp	r2, lr
 800b80e:	d1f8      	bne.n	800b802 <memset+0x46>
 800b810:	f10c 0201 	add.w	r2, ip, #1
 800b814:	f014 0f0c 	tst.w	r4, #12
 800b818:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800b81c:	f004 0c0f 	and.w	ip, r4, #15
 800b820:	d013      	beq.n	800b84a <memset+0x8e>
 800b822:	f1ac 0304 	sub.w	r3, ip, #4
 800b826:	f023 0303 	bic.w	r3, r3, #3
 800b82a:	3304      	adds	r3, #4
 800b82c:	4413      	add	r3, r2
 800b82e:	f842 5b04 	str.w	r5, [r2], #4
 800b832:	4293      	cmp	r3, r2
 800b834:	d1fb      	bne.n	800b82e <memset+0x72>
 800b836:	f00c 0403 	and.w	r4, ip, #3
 800b83a:	b12c      	cbz	r4, 800b848 <memset+0x8c>
 800b83c:	b2ca      	uxtb	r2, r1
 800b83e:	441c      	add	r4, r3
 800b840:	f803 2b01 	strb.w	r2, [r3], #1
 800b844:	429c      	cmp	r4, r3
 800b846:	d1fb      	bne.n	800b840 <memset+0x84>
 800b848:	bd30      	pop	{r4, r5, pc}
 800b84a:	4664      	mov	r4, ip
 800b84c:	4613      	mov	r3, r2
 800b84e:	2c00      	cmp	r4, #0
 800b850:	d1f4      	bne.n	800b83c <memset+0x80>
 800b852:	e7f9      	b.n	800b848 <memset+0x8c>
 800b854:	4603      	mov	r3, r0
 800b856:	4614      	mov	r4, r2
 800b858:	e7bf      	b.n	800b7da <memset+0x1e>
 800b85a:	461a      	mov	r2, r3
 800b85c:	46a4      	mov	ip, r4
 800b85e:	e7e0      	b.n	800b822 <memset+0x66>

0800b860 <strchr>:
 800b860:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 800b864:	4603      	mov	r3, r0
 800b866:	d044      	beq.n	800b8f2 <strchr+0x92>
 800b868:	0782      	lsls	r2, r0, #30
 800b86a:	d132      	bne.n	800b8d2 <strchr+0x72>
 800b86c:	b510      	push	{r4, lr}
 800b86e:	6804      	ldr	r4, [r0, #0]
 800b870:	ea41 2e01 	orr.w	lr, r1, r1, lsl #8
 800b874:	ea4e 4e0e 	orr.w	lr, lr, lr, lsl #16
 800b878:	ea8e 0204 	eor.w	r2, lr, r4
 800b87c:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b880:	ea23 0302 	bic.w	r3, r3, r2
 800b884:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800b888:	ea22 0204 	bic.w	r2, r2, r4
 800b88c:	4313      	orrs	r3, r2
 800b88e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b892:	d10f      	bne.n	800b8b4 <strchr+0x54>
 800b894:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800b898:	ea84 0c0e 	eor.w	ip, r4, lr
 800b89c:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 800b8a0:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 800b8a4:	ea23 0304 	bic.w	r3, r3, r4
 800b8a8:	ea22 020c 	bic.w	r2, r2, ip
 800b8ac:	4313      	orrs	r3, r2
 800b8ae:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b8b2:	d0ef      	beq.n	800b894 <strchr+0x34>
 800b8b4:	7803      	ldrb	r3, [r0, #0]
 800b8b6:	b923      	cbnz	r3, 800b8c2 <strchr+0x62>
 800b8b8:	e036      	b.n	800b928 <strchr+0xc8>
 800b8ba:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b8be:	2b00      	cmp	r3, #0
 800b8c0:	d032      	beq.n	800b928 <strchr+0xc8>
 800b8c2:	4299      	cmp	r1, r3
 800b8c4:	d1f9      	bne.n	800b8ba <strchr+0x5a>
 800b8c6:	bd10      	pop	{r4, pc}
 800b8c8:	428a      	cmp	r2, r1
 800b8ca:	d011      	beq.n	800b8f0 <strchr+0x90>
 800b8cc:	079a      	lsls	r2, r3, #30
 800b8ce:	4618      	mov	r0, r3
 800b8d0:	d0cc      	beq.n	800b86c <strchr+0xc>
 800b8d2:	4618      	mov	r0, r3
 800b8d4:	f813 2b01 	ldrb.w	r2, [r3], #1
 800b8d8:	2a00      	cmp	r2, #0
 800b8da:	d1f5      	bne.n	800b8c8 <strchr+0x68>
 800b8dc:	4610      	mov	r0, r2
 800b8de:	4770      	bx	lr
 800b8e0:	0799      	lsls	r1, r3, #30
 800b8e2:	4618      	mov	r0, r3
 800b8e4:	d007      	beq.n	800b8f6 <strchr+0x96>
 800b8e6:	4618      	mov	r0, r3
 800b8e8:	7802      	ldrb	r2, [r0, #0]
 800b8ea:	3301      	adds	r3, #1
 800b8ec:	2a00      	cmp	r2, #0
 800b8ee:	d1f7      	bne.n	800b8e0 <strchr+0x80>
 800b8f0:	4770      	bx	lr
 800b8f2:	0782      	lsls	r2, r0, #30
 800b8f4:	d1f7      	bne.n	800b8e6 <strchr+0x86>
 800b8f6:	6802      	ldr	r2, [r0, #0]
 800b8f8:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b8fc:	ea23 0302 	bic.w	r3, r3, r2
 800b900:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b904:	d108      	bne.n	800b918 <strchr+0xb8>
 800b906:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800b90a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b90e:	ea23 0302 	bic.w	r3, r3, r2
 800b912:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b916:	d0f6      	beq.n	800b906 <strchr+0xa6>
 800b918:	7803      	ldrb	r3, [r0, #0]
 800b91a:	2b00      	cmp	r3, #0
 800b91c:	d0e8      	beq.n	800b8f0 <strchr+0x90>
 800b91e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b922:	2b00      	cmp	r3, #0
 800b924:	d1fb      	bne.n	800b91e <strchr+0xbe>
 800b926:	4770      	bx	lr
 800b928:	4618      	mov	r0, r3
 800b92a:	bd10      	pop	{r4, pc}

0800b92c <strlen>:
 800b92c:	f020 0103 	bic.w	r1, r0, #3
 800b930:	f010 0003 	ands.w	r0, r0, #3
 800b934:	f1c0 0000 	rsb	r0, r0, #0
 800b938:	f851 3b04 	ldr.w	r3, [r1], #4
 800b93c:	f100 0c04 	add.w	ip, r0, #4
 800b940:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800b944:	f06f 0200 	mvn.w	r2, #0
 800b948:	bf1c      	itt	ne
 800b94a:	fa22 f20c 	lsrne.w	r2, r2, ip
 800b94e:	4313      	orrne	r3, r2
 800b950:	f04f 0c01 	mov.w	ip, #1
 800b954:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800b958:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800b95c:	eba3 020c 	sub.w	r2, r3, ip
 800b960:	ea22 0203 	bic.w	r2, r2, r3
 800b964:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800b968:	bf04      	itt	eq
 800b96a:	f851 3b04 	ldreq.w	r3, [r1], #4
 800b96e:	3004      	addeq	r0, #4
 800b970:	d0f4      	beq.n	800b95c <strlen+0x30>
 800b972:	f1c2 0100 	rsb	r1, r2, #0
 800b976:	ea02 0201 	and.w	r2, r2, r1
 800b97a:	fab2 f282 	clz	r2, r2
 800b97e:	f1c2 021f 	rsb	r2, r2, #31
 800b982:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800b986:	4770      	bx	lr

0800b988 <strpbrk>:
 800b988:	4684      	mov	ip, r0
 800b98a:	7800      	ldrb	r0, [r0, #0]
 800b98c:	b1b8      	cbz	r0, 800b9be <strpbrk+0x36>
 800b98e:	b500      	push	{lr}
 800b990:	468e      	mov	lr, r1
 800b992:	7809      	ldrb	r1, [r1, #0]
 800b994:	4672      	mov	r2, lr
 800b996:	460b      	mov	r3, r1
 800b998:	b919      	cbnz	r1, 800b9a2 <strpbrk+0x1a>
 800b99a:	e00b      	b.n	800b9b4 <strpbrk+0x2c>
 800b99c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800b9a0:	b143      	cbz	r3, 800b9b4 <strpbrk+0x2c>
 800b9a2:	4298      	cmp	r0, r3
 800b9a4:	d1fa      	bne.n	800b99c <strpbrk+0x14>
 800b9a6:	7813      	ldrb	r3, [r2, #0]
 800b9a8:	2b00      	cmp	r3, #0
 800b9aa:	bf14      	ite	ne
 800b9ac:	4660      	movne	r0, ip
 800b9ae:	2000      	moveq	r0, #0
 800b9b0:	f85d fb04 	ldr.w	pc, [sp], #4
 800b9b4:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
 800b9b8:	2800      	cmp	r0, #0
 800b9ba:	d1eb      	bne.n	800b994 <strpbrk+0xc>
 800b9bc:	e7f3      	b.n	800b9a6 <strpbrk+0x1e>
 800b9be:	4770      	bx	lr

0800b9c0 <strspn>:
 800b9c0:	b510      	push	{r4, lr}
 800b9c2:	468e      	mov	lr, r1
 800b9c4:	7801      	ldrb	r1, [r0, #0]
 800b9c6:	b199      	cbz	r1, 800b9f0 <strspn+0x30>
 800b9c8:	4604      	mov	r4, r0
 800b9ca:	4684      	mov	ip, r0
 800b9cc:	f89e 0000 	ldrb.w	r0, [lr]
 800b9d0:	b158      	cbz	r0, 800b9ea <strspn+0x2a>
 800b9d2:	4672      	mov	r2, lr
 800b9d4:	4603      	mov	r3, r0
 800b9d6:	e002      	b.n	800b9de <strspn+0x1e>
 800b9d8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800b9dc:	b12b      	cbz	r3, 800b9ea <strspn+0x2a>
 800b9de:	428b      	cmp	r3, r1
 800b9e0:	d1fa      	bne.n	800b9d8 <strspn+0x18>
 800b9e2:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 800b9e6:	2900      	cmp	r1, #0
 800b9e8:	d1f2      	bne.n	800b9d0 <strspn+0x10>
 800b9ea:	ebac 0004 	sub.w	r0, ip, r4
 800b9ee:	bd10      	pop	{r4, pc}
 800b9f0:	4608      	mov	r0, r1
 800b9f2:	bd10      	pop	{r4, pc}
